# demo
_ -> _rt0_amd64_darwin
_ -> runtime.unreachableMethod
_ -> go:main.inittasks
runtime.unreachableMethod -> go:string."unreachable method called. linker bug?"
runtime.unreachableMethod -> runtime.throw
runtime.unreachableMethod -> runtime.morestack_noctxt
runtime.unreachableMethod -> gclocals·g2BeySu+wFnoycgXfElmcg==
runtime.throw -> runtime.throw.func1
runtime.throw -> runtime.systemstack
runtime.throw -> runtime.fatalthrow
runtime.throw -> gclocals·wgcWObbY2HYnK2SU/U22lA==
runtime.throw -> gclocals·odYzRIjT7IX9pYG9TnNVzw==
runtime.throw -> runtime.send.stkobj
runtime.throw -> fmt.parseArgNumber.arginfo1
runtime.throw -> fmt.Errorf.argliveinfo
runtime.throw.func1 -> runtime.printlock
runtime.throw.func1 -> go:string."fatal error: "
runtime.throw.func1 -> runtime.printstring
runtime.throw.func1 -> runtime.printnl
runtime.throw.func1 -> runtime.printunlock
runtime.throw.func1 -> runtime.morestack
runtime.throw.func1 -> gclocals·J5F+7Qw7O7ve2QcWC7DpeQ==
runtime.throw.func1 -> gclocals·CnDyI2HjYXFz19SsOj98tw==
runtime.fatalthrow -> runtime.fatalthrow.func1
runtime.fatalthrow -> gclocals·o6Zg9+zmRBFm//1GHy3gfQ==
runtime.fatalthrow -> os.Mkdir.stkobj
runtime.fatalthrow -> fmt.isSpace.arginfo1
runtime.fatalthrow.func1 -> runtime.secureMode
runtime.fatalthrow.func1 -> runtime.exit
runtime.fatalthrow.func1 -> runtime.startpanic_m
runtime.fatalthrow.func1 -> runtime.dopanic_m
runtime.fatalthrow.func1 -> runtime.dieFromSignal
runtime.startpanic_m -> runtime.mheap_
runtime.startpanic_m -> go:string."runtime: panic before malloc heap initialized\n"
runtime.startpanic_m -> go:string."stack trace unavailable\n"
runtime.startpanic_m -> go:string."panic during panic\n"
runtime.startpanic_m -> runtime.panicking
runtime.startpanic_m -> runtime.paniclk
runtime.startpanic_m -> runtime.lock2
runtime.startpanic_m -> runtime.debug
runtime.startpanic_m -> runtime.schedtrace
runtime.startpanic_m -> runtime.freezetheworld
runtime.lock2 -> runtime.semacreate
runtime.lock2 -> runtime.(*lockTimer).begin
runtime.lock2 -> runtime.ncpu
runtime.lock2 -> runtime.usleep
runtime.lock2 -> runtime.procyield
runtime.lock2 -> runtime.(*lockTimer).end
runtime.lock2 -> runtime.semasleep
runtime.lock2 -> go:string."runtime·lock: lock count"
runtime.lock2 -> gclocals·H9o4QuyhLpiuyqMbvx/BVw==
runtime.lock2 -> gclocals·qOn17YvEnht5QIAe8QjwAw==
runtime.lock2 -> runtime.lock2.stkobj
runtime.lock2 -> fmt.(*wrapError).Error.arginfo1
runtime.(*lockTimer).begin -> runtime.mutexprofilerate
runtime.(*lockTimer).begin -> runtime.nanotime1
runtime.(*lockTimer).begin -> runtime.cputicks
runtime.(*lockTimer).begin -> runtime.panicdivide
runtime.(*lockTimer).begin -> gclocals·ZzMiPAiVBg7DJ6dh/CjSag==
runtime.(*lockTimer).begin -> gclocals·VtCL4RdUwCqwXEPeyJllRA==
runtime.(*lockTimer).end -> runtime.(*mLockProfile).recordLock
runtime.(*lockTimer).end -> gclocals·m/6RUmNv6NBhMUL8eleFFA==
runtime.(*mLockProfile).recordLock -> gclocals·iilYh2zWk/RieCMyRG2Y4w==
runtime.(*mLockProfile).recordLock -> sort.(*IntSlice).Less.arginfo1
runtime.semacreate -> runtime.pthread_mutex_init
runtime.semacreate -> runtime.pthread_cond_init
runtime.semacreate -> go:string."pthread_cond_init"
runtime.semacreate -> go:string."pthread_mutex_init"
runtime.semasleep -> runtime.pthread_mutex_lock
runtime.semasleep -> runtime.pthread_cond_wait
runtime.semasleep -> runtime.pthread_cond_timedwait_relative_np
runtime.semasleep -> runtime.pthread_mutex_unlock
runtime.semasleep -> go:string."semasleep on Darwin signal stack"
runtime.semasleep -> gclocals·ShrCR2lbrdPvyLG+AuFYmA==
runtime.panicdivide -> go:string."integer divide by zero"
runtime.panicdivide -> runtime.panicCheck2
runtime.panicdivide -> runtime.divideError
runtime.panicdivide -> runtime.gopanic
runtime.gopanic -> type:*runtime.PanicNilError <UsedInIface>
runtime.gopanic -> runtime.zerobase
runtime.gopanic -> runtime.panicnil
runtime.gopanic -> runtime.(*godebugInc).IncNonDefault
runtime.gopanic -> runtime.duffzero
runtime.gopanic -> runtime.runningPanicDefers
runtime.gopanic -> runtime.(*_panic).start
runtime.gopanic -> runtime.(*_panic).nextDefer
runtime.gopanic -> runtime.preprintpanics
runtime.gopanic -> runtime.fatalpanic
runtime.gopanic -> go:string."panic: "
runtime.gopanic -> runtime.printany
runtime.gopanic -> go:string."panic holding locks"
runtime.gopanic -> go:string."preempt off reason: "
runtime.gopanic -> go:string."panic during preemptoff"
runtime.gopanic -> go:string."panic during malloc"
runtime.gopanic -> go:string."panic on system stack"
runtime.gopanic -> gclocals·U09Rc6BR+mjJ99vc7yd1jA==
runtime.gopanic -> gclocals·2IYwamjHJeCwStBbpEMxDQ==
runtime.gopanic -> runtime.gopanic.stkobj
runtime.printany -> runtime.printany.jump6
runtime.printany -> type:uintptr
runtime.printany -> runtime.printuint
runtime.printany -> type:uint16
runtime.printany -> type:uint8
runtime.printany -> type:uint32
runtime.printany -> type:complex128
runtime.printany -> runtime.printcomplex
runtime.printany -> type:int8
runtime.printany -> runtime.printint
runtime.printany -> type:complex64
runtime.printany -> type:float32
runtime.printany -> runtime.printfloat
runtime.printany -> type:int32
runtime.printany -> type:uint
runtime.printany -> type:int64
runtime.printany -> type:float64
runtime.printany -> type:string
runtime.printany -> type:uint64
runtime.printany -> type:bool
runtime.printany -> runtime.printbool
runtime.printany -> type:int
runtime.printany -> type:int16
runtime.printany -> runtime.printanycustomtype
runtime.printany -> go:string."nil"
runtime.printany -> gclocals·xHaoWvF9dWwWDyl5o/zypw==
runtime.printany -> gclocals·dGrMWTWIngKGfVYjHi0adA==
runtime.printanycustomtype -> runtime.rtype.string
runtime.printanycustomtype -> runtime.printanycustomtype.jump5
runtime.printanycustomtype -> runtime.gcbits.2800000000000000
runtime.printanycustomtype -> go:string.")"
runtime.printanycustomtype -> go:string."(\""
runtime.printanycustomtype -> go:string."\")"
runtime.printanycustomtype -> go:string.") "
runtime.printanycustomtype -> runtime.printpointer
runtime.printanycustomtype -> gclocals·Igs2C5HwiksxpPLJ0dyi2A==
runtime.printanycustomtype -> gclocals·B72P1YhBbohKkFFbE6vbpQ==
runtime.printanycustomtype -> reflect.TypeOf.stkobj
runtime.preprintpanics -> type:string <UsedInIface>
runtime.preprintpanics -> runtime.preprintpanics.func1·f
runtime.preprintpanics -> runtime..interfaceSwitch.0
runtime.preprintpanics -> runtime.preprintpanics.func1
runtime.preprintpanics -> runtime.interfaceSwitch
runtime.preprintpanics -> runtime.convTstring
runtime.preprintpanics -> runtime.writeBarrier
runtime.preprintpanics -> runtime.gcWriteBarrier2
runtime.preprintpanics -> runtime.deferreturn
runtime.preprintpanics -> gclocals·r15SxNwAVsvfnmWz8xzcSQ==
runtime.preprintpanics -> sync.(*Map).CompareAndSwap.opendefer
runtime.convTstring -> runtime.zeroVal
runtime.convTstring -> runtime.stringType
runtime.convTstring -> runtime.mallocgc
runtime.interfaceSwitch -> runtime.getitab
runtime.interfaceSwitch -> runtime.buildInterfaceSwitchCache
runtime.interfaceSwitch -> runtime.atomicwb
runtime.interfaceSwitch -> runtime.panicunsafeslicelen
runtime.interfaceSwitch -> gclocals·MO9Urgp57c8ZQ3z79wI9pg==
runtime.interfaceSwitch -> gclocals·rODGEJJdX9hPNRPJK+whog==
runtime.interfaceSwitch -> fmt.(*fmt).init.arginfo1
runtime.interfaceSwitch -> fmt.(*ss).getBase.argliveinfo
runtime.atomicwb -> runtime.wbBufFlush
runtime.atomicwb -> gclocals·ROUSt0/vdGh5KGeocNshSw==
runtime.getitab -> runtime.itabTable
runtime.getitab -> runtime.(*itabTableType).find
runtime.getitab -> runtime.itabLock
runtime.getitab -> runtime.unlock2
runtime.getitab -> runtime.memstats
runtime.getitab -> runtime.persistentalloc
runtime.getitab -> runtime.gcWriteBarrier4
runtime.getitab -> runtime.(*itab).init
runtime.getitab -> runtime.itabAdd
runtime.getitab -> type:runtime.TypeAssertionError
runtime.getitab -> runtime.newobject
runtime.getitab -> type:*runtime.TypeAssertionError <UsedInIface>
runtime.getitab -> runtime.gcWriteBarrier3
runtime.getitab -> runtime.resolveNameOff
runtime.getitab -> internal/abi.Name.Name
runtime.getitab -> go:string."internal error - misuse of itab"
runtime.getitab -> gclocals·FdT8tniwBnd/DBNK3LnSfQ==
runtime.getitab -> gclocals·sOJycR3oTON9qE9oB9S+Zw==
runtime.getitab -> fmt.(*pp).fmt0x64.arginfo1
runtime.getitab -> fmt.(*fmt).fmtQ.argliveinfo
runtime.(*itabTableType).find -> gclocals·LlfHo70um+DIUn9rjx/QUA==
runtime.itabAdd -> runtime.(*itabTableType).add-fm
runtime.itabAdd -> runtime.iterate_itabs
runtime.itabAdd -> runtime.(*itabTableType).add
runtime.itabAdd -> go:string."mismatched count during itab table copy"
runtime.itabAdd -> go:string."malloc deadlock"
runtime.itabAdd -> gclocals·NxH6OjKY5C2N4z1wxKNFLQ==
runtime.itabAdd -> gclocals·+T/qqCPEy5pqFUAj0D3ZEg==
runtime.itabAdd -> fmt.(*pp).badVerb.stkobj
runtime.(*itabTableType).add -> gclocals·TjPuuCwdlCpTaRQGRKTrYw==
runtime.(*itab).init -> runtime.(*itab).init.jump7
runtime.(*itab).init -> runtime.resolveTypeOff
runtime.(*itab).init -> runtime.pkgPath
runtime.(*itab).init -> runtime.rtype.textOff
runtime.(*itab).init -> runtime.memequal
runtime.(*itab).init -> runtime.panicIndex
runtime.(*itab).init -> runtime.panicSlice3Alen
runtime.(*itab).init -> gclocals·04UG2v/q4E6o5X4slZgg5w==
runtime.(*itab).init -> gclocals·DKFlLQRrOJFyKHHYAWxdng==
runtime.buildInterfaceSwitchCache -> gclocals·3X/bFQuX8p7oQPV40Ehnog==
runtime.buildInterfaceSwitchCache -> strconv.roundShortest.arginfo1
runtime.buildInterfaceSwitchCache -> fmt.(*fmt).truncate.argliveinfo
runtime.unlock2 -> runtime.semawakeup
runtime.unlock2 -> runtime.(*mLockProfile).recordUnlock
runtime.unlock2 -> go:string."runtime·unlock: lock count"
runtime.unlock2 -> gclocals·KPvG3XfAPUbWf5fguWSJfg==
runtime.mallocgc -> runtime.gcphase
runtime.mallocgc -> runtime.inittrace
runtime.mallocgc -> runtime.deductAssistCredit
runtime.mallocgc -> runtime.mcache0
runtime.mallocgc -> runtime.(*mcache).nextFree
runtime.mallocgc -> runtime.size_to_class8
runtime.mallocgc -> runtime.size_to_class128
runtime.mallocgc -> runtime.class_to_size
runtime.mallocgc -> runtime.memclrNoHeapPointers
runtime.mallocgc -> runtime.(*mcache).allocLarge
runtime.mallocgc -> runtime.heapSetType
runtime.mallocgc -> runtime.publicationBarrier
runtime.mallocgc -> runtime.gcmarknewobject
runtime.mallocgc -> runtime.MemProfileRate
runtime.mallocgc -> runtime.profilealloc
runtime.mallocgc -> runtime.memclrNoHeapPointersChunked
runtime.mallocgc -> runtime.tracealloc
runtime.mallocgc -> runtime.gcTrigger.test
runtime.mallocgc -> runtime.gcStart
runtime.mallocgc -> go:string."unexpected malloc header in delayed zeroing of large object"
runtime.mallocgc -> go:string."delayed zeroing on data that may contain pointers"
runtime.mallocgc -> runtime.panicIndexU
runtime.mallocgc -> go:string."mallocgc called without a P or outside bootstrapping"
runtime.mallocgc -> go:string."malloc during signal"
runtime.mallocgc -> go:string."mallocgc called with gcphase == _GCmarktermination"
runtime.mallocgc -> gclocals·IjVhhQMiZdqRN5Av+ggxcA==
runtime.mallocgc -> gclocals·UbQCWxpH4gKSSEKlYDcxDQ==
runtime.mallocgc -> fmt.(*fmt).padString.argliveinfo
runtime.(*mcache).nextFree -> runtime.(*mspan).nextFreeIndex
runtime.(*mcache).nextFree -> runtime.(*mcache).refill
runtime.(*mcache).nextFree -> go:string."s.allocCount= "
runtime.(*mcache).nextFree -> go:string." s.nelems= "
runtime.(*mcache).nextFree -> go:string."s.allocCount > s.nelems"
runtime.(*mcache).nextFree -> go:string."freeIndex is not valid"
runtime.(*mcache).nextFree -> go:string."runtime: s.allocCount= "
runtime.(*mcache).nextFree -> go:string."s.allocCount != s.nelems && freeIndex == s.nelems"
runtime.(*mcache).nextFree -> fmt.(*fmt).fmtBoolean.arginfo1
runtime.deductAssistCredit -> runtime.gcBlackenEnabled
runtime.deductAssistCredit -> runtime.gcAssistAlloc
runtime.deductAssistCredit -> gclocals·5aa34RaZcmo0NkRpBHp2fg==
runtime.memclrNoHeapPointersChunked -> runtime.goschedguarded_m·f
runtime.memclrNoHeapPointersChunked -> runtime.mcall
runtime.memclrNoHeapPointersChunked -> gclocals·IuErl7MOXaHVn7EZYWzfFA==
runtime.profilealloc -> runtime.fastexprand
runtime.profilealloc -> runtime.mProf_Malloc
runtime.profilealloc -> go:string."profilealloc called without a P or outside bootstrapping"
runtime.profilealloc -> gclocals·LqP3g2EGGEr/6X6Jjn96VQ==
runtime.profilealloc -> gclocals·ykHN0vawYuq1dUW4zEe2gA==
runtime.fastexprand -> runtime.fastlog2Table
runtime.fastexprand -> $f64.3eb0000000000000
runtime.fastexprand -> $f64.403a000000000000
runtime.fastexprand -> $f64.bfe62e42fefa39ef
runtime.persistentalloc -> runtime.persistentalloc.func1
runtime.persistentalloc -> gclocals·pjkiW5J2QfpsfPzMt9QzFQ==
runtime.persistentalloc -> gclocals·91Vv7Jr8iuzVj8waVJz8oQ==
runtime.persistentalloc -> runtime.debugCallWrap.stkobj
runtime.persistentalloc.func1 -> runtime.persistentalloc1
runtime.persistentalloc1 -> runtime.globalAlloc
runtime.persistentalloc1 -> runtime.sysAlloc
runtime.persistentalloc1 -> runtime.(*sysMemStat).add
runtime.persistentalloc1 -> runtime.persistentChunks
runtime.persistentalloc1 -> go:string."runtime: cannot allocate memory"
runtime.persistentalloc1 -> go:string."persistentalloc: align is too large"
runtime.persistentalloc1 -> go:string."persistentalloc: align is not a power of 2"
runtime.persistentalloc1 -> go:string."persistentalloc: size == 0"
runtime.persistentalloc1 -> runtime.morestackc
runtime.persistentalloc1 -> gclocals·fxAY0dnWduWeLyULTXgNwA==
runtime.persistentalloc1 -> gclocals·Ys2QX50FBAYNpNX4cIm9lg==
runtime.persistentalloc1 -> os.genericReadFrom.stkobj
runtime.persistentalloc1 -> fmt.(*pp).WriteString.argliveinfo
runtime.(*mspan).nextFreeIndex -> runtime.(*mspan).refillAllocCache
runtime.(*mspan).nextFreeIndex -> go:string."s.freeindex > s.nelems"
runtime.(*mspan).refillAllocCache -> runtime.(*dlogger).i16.arginfo1
runtime.heapSetType -> runtime.heapSetType.func1
runtime.heapSetType -> runtime.runGCProg
runtime.heapSetType -> runtime.(*mspan).writeHeapBitsSmall
runtime.heapSetType -> go:string."GCProg for type that isn't large"
runtime.heapSetType -> gclocals·8JHXFj/EadDeYa+ijofN/g==
runtime.heapSetType -> gclocals·Tal5oezCuD+q6Trdapm8MA==
runtime.heapSetType -> runtime.cgoCheckMemmove2.arginfo1
runtime.heapSetType -> fmt.Fscan.argliveinfo
runtime.(*mspan).writeHeapBitsSmall -> runtime.(*mspan).heapBits
runtime.(*mspan).writeHeapBitsSmall -> gclocals·dfs/88MXouNqNY2126ZUeg==
runtime.(*mspan).writeHeapBitsSmall -> reflect.Select.argliveinfo
runtime.heapSetType.func1 -> runtime.(*mheap).allocManual
runtime.(*mcache).refill -> runtime.emptymspan
runtime.(*mcache).refill -> runtime.(*mcentral).uncacheSpan
runtime.(*mcache).refill -> runtime.(*consistentHeapStats).acquire
runtime.(*mcache).refill -> runtime.(*consistentHeapStats).release
runtime.(*mcache).refill -> runtime.gcController
runtime.(*mcache).refill -> runtime.(*mcentral).cacheSpan
runtime.(*mcache).refill -> runtime.(*gcControllerState).update
runtime.(*mcache).refill -> go:string."span has no free space"
runtime.(*mcache).refill -> go:string."out of memory"
runtime.(*mcache).refill -> go:string."bad sweepgen in refill"
runtime.(*mcache).refill -> go:string."refill of span with free space remaining"
runtime.(*mcache).refill -> fmt.(*fmt).fmtBs.argliveinfo
runtime.(*mcache).allocLarge -> runtime.deductSweepCredit
runtime.(*mcache).allocLarge -> runtime.(*mheap).alloc
runtime.(*mcache).allocLarge -> runtime.(*spanSet).push
runtime.(*mcache).allocLarge -> runtime.(*mspan).initHeapBits
runtime.(*mcentral).cacheSpan -> runtime.class_to_allocnpages
runtime.(*mcentral).cacheSpan -> runtime.trace
runtime.(*mcentral).cacheSpan -> runtime.traceAcquireEnabled
runtime.(*mcentral).cacheSpan -> runtime.traceLocker.GCSweepStart
runtime.(*mcentral).cacheSpan -> runtime.(*spanSet).pop
runtime.(*mcentral).cacheSpan -> runtime.traceLocker.GCSweepDone
runtime.(*mcentral).cacheSpan -> go:string."span has no free objects"
runtime.(*mcentral).cacheSpan -> runtime.sweep
runtime.(*mcentral).cacheSpan -> runtime.(*sweepLocker).tryAcquire
runtime.(*mcentral).cacheSpan -> runtime.(*sweepLocked).sweep
runtime.(*mcentral).cacheSpan -> runtime.(*activeSweep).end
runtime.(*mcentral).cacheSpan -> runtime.(*mcentral).grow
runtime.(*mcentral).cacheSpan -> gclocals·D1/YcbyNumM1nqYyoY4wEQ==
runtime.(*mcentral).cacheSpan -> gclocals·z+0NfkkxkI5/8d+pvFAb1Q==
runtime.(*mcentral).uncacheSpan -> go:string."uncaching span but s.allocCount == 0"
runtime.sysAlloc -> runtime.mmap
runtime.gcTrigger.test -> runtime.forcegcperiod
runtime.gcTrigger.test -> runtime.work
runtime.gcTrigger.test -> runtime.(*gcControllerState).trigger
runtime.gcTrigger.test -> runtime.gcTrigger.test.arginfo1
runtime.gcStart -> runtime.sweepone
runtime.gcStart -> runtime.semacquire1
runtime.gcStart -> runtime.gcsema
runtime.gcStart -> runtime.worldsema
runtime.gcStart -> runtime.traceLocker.GCStart
runtime.gcStart -> runtime.allp
runtime.gcStart -> runtime.semrelease1
runtime.gcStart -> runtime.gcBgMarkStartWorkers
runtime.gcStart -> runtime.gcResetMarkState·f
runtime.gcStart -> runtime.gomaxprocs
runtime.gcStart -> runtime.gcStart.func1
runtime.gcStart -> runtime.gcStart.func2·f
runtime.gcStart -> runtime.clearpools
runtime.gcStart -> runtime.(*gcControllerState).startCycle
runtime.gcStart -> runtime.gcCPULimiter
runtime.gcStart -> runtime.(*gcCPULimiterState).startGCTransition
runtime.gcStart -> runtime.schedEnableUser
runtime.gcStart -> runtime.gcMarkRootPrepare
runtime.gcStart -> runtime.gcMarkTinyAllocs
runtime.gcStart -> runtime.gcStart.func3
runtime.gcStart -> runtime.gosched_m·f
runtime.gcStart -> go:string."runtime: p "
runtime.gcStart -> go:string." flushGen "
runtime.gcStart -> go:string." != sweepgen "
runtime.gcStart -> go:string."p mcache not flushed"
runtime.gcStart -> gclocals·gdABAyWgO7HhJU+BXf53lw==
runtime.gcStart -> runtime.gcStart.stkobj
runtime.gcStart.func3 -> runtime.startTheWorldWithSema
runtime.gcStart.func3 -> runtime.(*gcCPULimiterState).finishGCTransition
runtime.gcStart.func1 -> runtime.stopTheWorldWithSema
runtime.gcBgMarkStartWorkers -> runtime.gcBgMarkWorker·f
runtime.gcBgMarkStartWorkers -> runtime.newproc
runtime.gcBgMarkStartWorkers -> runtime.notetsleepg
runtime.gcBgMarkStartWorkers -> runtime.gcBgMarkWorkerCount
runtime.notetsleepg -> runtime.entersyscallblock
runtime.notetsleepg -> runtime.notetsleep_internal
runtime.notetsleepg -> runtime.exitsyscall
runtime.notetsleepg -> go:string."notetsleepg on g0"
runtime.notetsleep_internal -> runtime.cgo_yield
runtime.notetsleep_internal -> go:string."notetsleep - waitm out of sync"
runtime.notetsleep_internal -> runtime.asmcgocall
runtime.notetsleep_internal -> go:string."runtime: unable to acquire - semaphore out of sync"
runtime.notetsleep_internal -> go:string."runtime: unexpected waitm - semaphore out of sync"
runtime.notetsleep_internal -> gclocals·ON0GJsy59DJykMbMbaDfLg==
runtime.notetsleep_internal -> gclocals·o+PfnuBVWMA9paH+BG0A1w==
runtime.notetsleep_internal -> runtime.notetsleep_internal.stkobj
runtime.clearpools -> runtime.poolcleanup
runtime.clearpools -> runtime.boringCaches
runtime.clearpools -> runtime.sched
runtime.clearpools -> runtime.gcWriteBarrier1
runtime.(*gcCPULimiterState).startGCTransition -> runtime.(*gcCPULimiterState).updateLocked
runtime.(*gcCPULimiterState).startGCTransition -> go:string."transitioning GC to the same state as before?"
runtime.(*gcCPULimiterState).startGCTransition -> go:string."failed to acquire lock to start a GC transition"
runtime.(*gcCPULimiterState).startGCTransition -> fmt.(*ss).Token.arginfo1
runtime.(*gcCPULimiterState).finishGCTransition -> runtime.(*gcCPULimiterState).accumulate
runtime.(*gcCPULimiterState).finishGCTransition -> runtime.(*gcCPULimiterState).unlock
runtime.(*gcCPULimiterState).finishGCTransition -> go:string."finishGCTransition called without starting one?"
runtime.(*gcCPULimiterState).updateLocked -> $f64.3fd0000000000000
runtime.(*gcCPULimiterState).updateLocked -> runtime.(*limiterEvent).consume
runtime.(*gcCPULimiterState).updateLocked -> go:string."invalid limiter event type found"
runtime.(*gcCPULimiterState).updateLocked -> gclocals·Dgf1f3AVIaLB1FeVKvxDYQ==
runtime.(*gcCPULimiterState).updateLocked -> gclocals·CFG3to7kccxvuTqmYI0PLA==
runtime.(*gcCPULimiterState).unlock -> go:string."double unlock"
runtime.gcMarkRootPrepare -> runtime.modulesSlice
runtime.gcMarkRootPrepare -> runtime.allgs
runtime.gcAssistAlloc -> $f64.40f0000000000000
runtime.gcAssistAlloc -> runtime.traceLocker.GCMarkAssistStart
runtime.gcAssistAlloc -> runtime.gcAssistAlloc.func1
runtime.gcAssistAlloc -> runtime.gcMarkDone
runtime.gcAssistAlloc -> runtime.gcParkAssist
runtime.gcAssistAlloc -> runtime.traceLocker.GCMarkAssistDone
runtime.gcAssistAlloc -> gclocals·/9RxZvb+4Ck/lPTHs/4w0w==
runtime.gcAssistAlloc -> gclocals·3s/fHUzOhMxGUiYcmQ6Wbw==
runtime.gcMarkDone -> runtime.gcMarkDone.func4
runtime.gcMarkDone -> runtime.gcMarkDoneFlushed
runtime.gcMarkDone -> runtime.gcMarkDone.forEachP.func5
runtime.gcMarkDone -> runtime.gcMarkDone.func1·f
runtime.gcMarkDone -> go:string."gcing"
runtime.gcMarkDone -> runtime.gcMarkDone.func2
runtime.gcMarkDone -> runtime.gcMarkDone.func3
runtime.gcMarkDone -> runtime.gcComputeStartingStackSize
runtime.gcMarkDone -> runtime.gcWakeAllAssists
runtime.gcMarkDone -> runtime.(*gcControllerState).endCycle
runtime.gcMarkDone -> runtime.gcMarkTermination
runtime.gcMarkDone -> gclocals·6FgxSTf1VSf38jl+Tu75Ew==
runtime.gcMarkDone -> runtime.gcMarkDone.stkobj
runtime.gcMarkDone.func3 -> runtime.wbBufFlush1
runtime.gcMarkDone.func3 -> gclocals·k/vI9CsIAsSPBngFxBbT3g==
runtime.gcMarkDone.forEachP.func5 -> runtime.casGToWaiting
runtime.gcMarkDone.forEachP.func5 -> runtime.forEachPInternal
runtime.gcMarkDone.forEachP.func5 -> runtime.casgstatus
runtime.gcMarkDone.forEachP.func5 -> gclocals·juSYgsC/UIcgXLIL7+eb6Q==
runtime.gcMarkTermination -> runtime.gcMarkTermination.func1
runtime.gcMarkTermination -> runtime.gcMarkTermination.func2
runtime.gcMarkTermination -> runtime.traceLocker.GCDone
runtime.gcMarkTermination -> runtime.gcControllerCommit·f
runtime.gcMarkTermination -> time.now
runtime.gcMarkTermination -> runtime.(*cpuStats).accumulate
runtime.gcMarkTermination -> runtime.scavenge
runtime.gcMarkTermination -> runtime.injectglist
runtime.gcMarkTermination -> runtime.(*scavengeIndex).nextGen
runtime.gcMarkTermination -> runtime.mProfCycle
runtime.gcMarkTermination -> runtime.gcMarkTermination.func3
runtime.gcMarkTermination -> runtime.mProf_Flush
runtime.gcMarkTermination -> runtime.prepareFreeWorkbufs
runtime.gcMarkTermination -> runtime.freeStackSpans·f
runtime.gcMarkTermination -> runtime.gcMarkTermination.forEachP.func6
runtime.gcMarkTermination -> runtime.gcMarkTermination.func4·f
runtime.gcMarkTermination -> $f64.4059000000000000
runtime.gcMarkTermination -> runtime.runtimeInitTime
runtime.gcMarkTermination -> runtime.slicebytetostring
runtime.gcMarkTermination -> go:string."gc "
runtime.gcMarkTermination -> go:string." @"
runtime.gcMarkTermination -> go:string."s "
runtime.gcMarkTermination -> go:string."%: "
runtime.gcMarkTermination -> runtime.fmtNSAsMS
runtime.gcMarkTermination -> go:string."+"
runtime.gcMarkTermination -> go:string." ms clock, "
runtime.gcMarkTermination -> syscall..stmp_35
runtime.gcMarkTermination -> go:string." ms cpu, "
runtime.gcMarkTermination -> go:string."->"
runtime.gcMarkTermination -> go:string." MB, "
runtime.gcMarkTermination -> go:string." MB goal, "
runtime.gcMarkTermination -> go:string." MB stacks, "
runtime.gcMarkTermination -> go:string." MB globals, "
runtime.gcMarkTermination -> go:string." P"
runtime.gcMarkTermination -> go:string." (forced)"
runtime.gcMarkTermination -> runtime.debuglock
runtime.gcMarkTermination -> runtime.userArenaState
runtime.gcMarkTermination -> runtime.(*mspan).setUserArenaChunkToFault
runtime.gcMarkTermination -> runtime.(*gcControllerState).heapGoalInternal
runtime.gcMarkTermination -> runtime.gcMarkTermination.func5·f
runtime.gcMarkTermination -> go:string."non-concurrent sweep failed to drain all sweep queues"
runtime.gcMarkTermination -> go:string."failed to set sweep barrier"
runtime.gcMarkTermination -> go:string."gc done but gcphase != _GCoff"
runtime.gcMarkTermination -> gclocals·VRdgPw/B1qZRso/lfzPG6g==
runtime.gcMarkTermination -> gclocals·+uhD9gSIoKDIFbBRBSJ2RA==
runtime.gcMarkTermination -> runtime.gcMarkTermination.stkobj
runtime.gcMarkTermination -> runtime.gcMarkTermination.arginfo1
runtime.(*mspan).setUserArenaChunkToFault -> runtime.sysFault
runtime.(*mspan).setUserArenaChunkToFault -> runtime.(*mspan).setUserArenaChunkToFault.func1
runtime.(*mspan).setUserArenaChunkToFault -> go:string."span on userArena.faultList has invalid size"
runtime.(*mspan).setUserArenaChunkToFault -> go:string."invalid span in heapArena for user arena"
runtime.(*mspan).setUserArenaChunkToFault.func1 -> runtime.(*mSpanList).insert
runtime.gcMarkTermination.func2 -> runtime.startCheckmarks
runtime.gcMarkTermination.func2 -> runtime.gcResetMarkState
runtime.gcMarkTermination.func2 -> runtime.gcDrain
runtime.gcMarkTermination.func2 -> runtime.(*gcWork).dispose
runtime.gcMarkTermination.func2 -> runtime.endCheckmarks
runtime.gcMarkTermination.func2 -> runtime.gcSweep
runtime.gcMarkTermination.func2 -> gclocals·sQxO+jiYy+d9ldxoWSePwQ==
runtime.startCheckmarks -> runtime.useCheckmark
runtime.startCheckmarks -> go:string."out of memory allocating checkmarks bitmap"
runtime.endCheckmarks -> go:string."GC work not flushed"
runtime.gcMarkTermination.func1 -> runtime.gcMark
runtime.gcMark -> runtime.tracegc
runtime.gcMark -> runtime.gcMarkRootCheck
runtime.gcMark -> runtime.(*wbBuf).reset
runtime.gcMark -> runtime.(*gcControllerState).resetLive
runtime.gcMark -> go:string."runtime: P "
runtime.gcMark -> go:string." flushedWork "
runtime.gcMark -> go:string." wbuf1.n="
runtime.gcMark -> go:string." wbuf2.n="
runtime.gcMark -> go:string."P has cached GC work at end of mark termination"
runtime.gcMark -> go:string." wbuf2=<nil>"
runtime.gcMark -> go:string." wbuf1=<nil>"
runtime.gcMark -> go:string."runtime: full="
runtime.gcMark -> runtime.printhex
runtime.gcMark -> go:string." next="
runtime.gcMark -> go:string." jobs="
runtime.gcMark -> go:string." nDataRoots="
runtime.gcMark -> go:string." nBSSRoots="
runtime.gcMark -> go:string." nSpanRoots="
runtime.gcMark -> go:string." nStackRoots="
runtime.gcMark -> runtime..stmp_126
runtime.gcMark -> go:string."in gcMark expecting to see gcphase as _GCmarktermination"
runtime.gcMark -> gclocals·bIw6KlaoxkdZsd4DPeZETA==
runtime.gcSweep -> runtime.ready
runtime.gcSweep -> runtime.(*mcache).prepareForSweep
runtime.gcSweep -> runtime.freeSomeWbufs
runtime.gcSweep -> go:string."gcSweep being done but phase is not GCoff"
runtime.(*mcache).prepareForSweep -> runtime.(*mcache).releaseAll
runtime.(*mcache).prepareForSweep -> runtime.stackcache_clear
runtime.(*mcache).prepareForSweep -> go:string."bad flushGen "
runtime.(*mcache).prepareForSweep -> go:string." in prepareForSweep; sweepgen "
runtime.(*mcache).prepareForSweep -> go:string."bad flushGen"
runtime.gcResetMarkState -> runtime.gcResetMarkState.func1·f
runtime.gcResetMarkState -> runtime.forEachG
runtime.fmtNSAsMS -> runtime.panicSliceAcap
runtime.fmtNSAsMS -> fmt.getField.arginfo1
runtime.gcMarkRootCheck -> runtime.gcMarkRootCheck.func1
runtime.gcMarkRootCheck -> runtime.forEachGRace
runtime.gcMarkRootCheck -> go:string." of "
runtime.gcMarkRootCheck -> go:string." markroot jobs done\n"
runtime.gcMarkRootCheck -> go:string."left over markroot jobs"
runtime.gcMarkRootCheck -> gclocals·EaPwxsZ75yY1hHMVZLmk6g==
runtime.gcMarkRootCheck -> main.main.stkobj
runtime.gcMarkRootCheck.func1 -> go:string."gp "
runtime.gcMarkRootCheck.func1 -> go:string." goid "
runtime.gcMarkRootCheck.func1 -> go:string." status "
runtime.gcMarkRootCheck.func1 -> go:string." gcscandone "
runtime.gcMarkRootCheck.func1 -> go:string."scan missed a g"
runtime.gcAssistAlloc.func1 -> runtime.gcAssistAlloc1
runtime.gcAssistAlloc1 -> runtime.gcDrainN
runtime.gcAssistAlloc1 -> runtime.(*limiterEvent).stop
runtime.gcAssistAlloc1 -> runtime.(*gcCPULimiterState).update
runtime.gcAssistAlloc1 -> go:string."runtime: work.nwait= "
runtime.gcAssistAlloc1 -> go:string." work.nproc= "
runtime.gcAssistAlloc1 -> go:string."work.nwait > work.nproc"
runtime.gcAssistAlloc1 -> go:string."runtime: work.nwait = "
runtime.gcAssistAlloc1 -> go:string."nwait > work.nprocs"
runtime.(*gcCPULimiterState).update -> go:string."update during transition"
runtime.(*limiterEvent).stop -> go:string."limiterEvent.stop: invalid limiter event type found"
runtime.(*limiterEvent).stop -> go:string."runtime: want="
runtime.(*limiterEvent).stop -> go:string." got="
runtime.(*limiterEvent).stop -> go:string."limiterEvent.stop: found wrong event in p's limiter event slot"
runtime.gcParkAssist -> runtime.parkunlock_c·f
runtime.gcParkAssist -> runtime.gopark
runtime.gcParkAssist -> gclocals·Plqv2ff52JtlYaDd2Rwxbg==
runtime.gcDrain -> runtime.pollWork·f
runtime.gcDrain -> runtime.pollFractionalWorkerExit·f
runtime.gcDrain -> runtime.(*gcWork).balance
runtime.gcDrain -> runtime.(*gcWork).tryGet
runtime.gcDrain -> runtime.scanobject
runtime.gcDrain -> runtime.gcFlushBgCredit
runtime.gcDrain -> runtime.markroot
runtime.gcDrain -> go:string."gcDrain phase incorrect"
runtime.gcDrain -> gclocals·ZgxrIPwpfrBi6Ty1jMAqsw==
runtime.markroot -> runtime.allfin
runtime.markroot -> runtime.markrootSpans
runtime.markroot -> runtime.markroot.func1
runtime.markroot -> runtime.markrootFreeGStacks·f
runtime.markroot -> go:string."runtime: markroot index "
runtime.markroot -> go:string." not in stack roots range ["
runtime.markroot -> go:string.", "
runtime.markroot -> go:string.")\n"
runtime.markroot -> go:string."markroot: bad index"
runtime.markroot -> runtime.finptrmask
runtime.markroot -> runtime.scanblock
runtime.markroot -> runtime.markrootBlock
runtime.markroot -> gclocals·hzjE3pRPxdo3Z5Q7iXq5KA==
runtime.markroot -> gclocals·20IAxi6Ve9TOiwRgy9ovWg==
runtime.markroot -> runtime.markroot.stkobj
runtime.markroot -> runtime.markroot.arginfo1
runtime.markroot.func1 -> runtime.suspendG
runtime.markroot.func1 -> runtime.scanstack
runtime.markroot.func1 -> runtime.resumeG
runtime.markroot.func1 -> go:string."g already scanned"
runtime.markroot.func1 -> gclocals·nXdSMUDjLs4WFNDqN/QgEQ==
runtime.markrootBlock -> gclocals·mqHoWZvKAXuwHrMHlI6RAw==
runtime.markrootSpans -> runtime.oneptrmask
runtime.markrootSpans -> go:string."sweep "
runtime.markrootSpans -> runtime.printsp
runtime.markrootSpans -> go:string."gc: unswept span"
runtime.markrootSpans -> go:string."s.state = "
runtime.markrootSpans -> go:string."non in-use span found with specials bit set"
runtime.markrootSpans -> runtime.panicSliceBU
runtime.markrootSpans -> gclocals·fr4jaRQKcgXsBcUXSEHEyg==
runtime.scanstack -> runtime.shrinkstack
runtime.scanstack -> runtime.(*unwinder).initAt
runtime.scanstack -> go:string."runtime: gp="
runtime.scanstack -> go:string.", goid="
runtime.scanstack -> go:string.", gp->atomicstatus="
runtime.scanstack -> go:string."mark - bad status"
runtime.scanstack -> runtime.scanframeworker
runtime.scanstack -> runtime.(*unwinder).next
runtime.scanstack -> runtime.(*stackScanState).putPtr
runtime.scanstack -> runtime.binarySearchTree
runtime.scanstack -> runtime.(*stackScanState).getPtr
runtime.scanstack -> runtime.firstmoduledata
runtime.scanstack -> runtime.putempty
runtime.scanstack -> go:string."remaining pointer buffers"
runtime.scanstack -> runtime.materializeGCProg
runtime.scanstack -> runtime.scanConservative
runtime.scanstack -> runtime.(*mheap).freeManual
runtime.scanstack -> go:string."can't scan our own stack"
runtime.scanstack -> go:string."scanstack: goroutine not stopped"
runtime.scanstack -> go:string."runtime:scanstack: gp="
runtime.scanstack -> go:string."scanstack - bad status"
runtime.scanstack -> gclocals·LedZ811NlokUJhhZqkRTww==
runtime.scanstack -> gclocals·CCOOqlYTzAJVAZYTbRNlVw==
runtime.scanstack -> sync.(*Cond).Wait.stkobj
runtime.scanframeworker -> runtime.(*stkframe).getStackMap
runtime.scanframeworker -> runtime.(*stkframe).argBytes
runtime.scanframeworker -> runtime.(*stackScanState).addObject
runtime.scanframeworker -> gclocals·lirejv0VPxtz5Aci4uXbRA==
runtime.scanframeworker -> gclocals·6ZgdNJN406RwcV5CfDsshg==
runtime.gcDrainN -> go:string."gcDrainN phase incorrect"
runtime.scanblock -> runtime.findObject
runtime.scanblock -> runtime.greyobject
runtime.scanblock -> gclocals·Kz6l6SIKEDm5Y6WWpyGaCg==
runtime.findObject -> runtime.badPointer
runtime.badPointer -> go:string."runtime: pointer "
runtime.badPointer -> go:string." to unallocated span"
runtime.badPointer -> go:string." span.base()="
runtime.badPointer -> go:string." span.limit="
runtime.badPointer -> go:string." span.state="
runtime.badPointer -> go:string."found bad pointer in Go heap (incorrect use of unsafe or cgo?)"
runtime.badPointer -> go:string."runtime: found in object at *("
runtime.badPointer -> go:string."object"
runtime.badPointer -> runtime.gcDumpObject
runtime.badPointer -> go:string." to unused region of span"
runtime.scanobject -> runtime.(*mspan).typePointersOfUnchecked
runtime.scanobject -> runtime.typePointers.next
runtime.scanobject -> runtime.typePointers.fastForward
runtime.scanobject -> runtime.(*gcWork).put
runtime.scanobject -> go:string."scanobject of a noscan object"
runtime.scanobject -> go:string."scanobject n == 0"
runtime.scanobject -> gclocals·GS0gcC+mZet7zFLyt28bUA==
runtime.(*mspan).typePointersOfUnchecked -> runtime.(*mspan).heapBitsSmallForAddr
runtime.typePointers.next -> runtime.typePointers.next.arginfo1
runtime.typePointers.fastForward -> runtime.typePointers.fastForward.arginfo1
runtime.scanConservative -> runtime.spanOfHeap
runtime.scanConservative -> go:string."misaligned mask"
runtime.greyobject -> runtime.setCheckmark
runtime.greyobject -> go:string."runtime: marking free object "
runtime.greyobject -> go:string." found at *("
runtime.greyobject -> go:string."base"
runtime.greyobject -> go:string."obj"
runtime.greyobject -> go:string."marking free object"
runtime.greyobject -> go:string."greyobject: obj not pointer-aligned"
runtime.greyobject -> gclocals·yYO/bZGpRzWlVHY50H8OcA==
runtime.greyobject -> runtime.dumpmemprof_callback.arginfo1
runtime.greyobject -> runtime.greyobject.argliveinfo
runtime.setCheckmark -> go:string."runtime: checkmarks found unexpected unmarked object obj="
runtime.setCheckmark -> go:string."runtime: found obj at *("
runtime.setCheckmark -> go:string."checkmark found unmarked object"
runtime.setCheckmark -> runtime.setCheckmark.arginfo1
runtime.setCheckmark -> fmt.(*ss).scanNumber.argliveinfo
runtime.gcDumpObject -> go:string."="
runtime.gcDumpObject -> go:string." s.base()="
runtime.gcDumpObject -> go:string." s.limit="
runtime.gcDumpObject -> go:string." s.spanclass="
runtime.gcDumpObject -> go:string." s.elemsize="
runtime.gcDumpObject -> go:string." s.state="
runtime.gcDumpObject -> runtime.mSpanStateNames
runtime.gcDumpObject -> go:string."unknown("
runtime.gcDumpObject -> go:string." s=nil\n"
runtime.gcDumpObject -> go:string." ...\n"
runtime.gcDumpObject -> go:string." *("
runtime.gcDumpObject -> go:string.") = "
runtime.gcDumpObject -> go:string." <=="
runtime.gcDumpObject -> fmt.parsenum.arginfo1
runtime.gcmarknewobject -> go:string."gcmarknewobject called while doing checkmark"
runtime.gcMarkTinyAllocs -> gclocals·9BzPawcR5gdcmAdFP/oo1A==
runtime.(*gcControllerState).startCycle -> $f64.3fe0000000000000
runtime.(*gcControllerState).startCycle -> $f64.3ff0000000000000
runtime.(*gcControllerState).startCycle -> $f64.bfd3333333333333
runtime.(*gcControllerState).startCycle -> $f64.3fd3333333333333
runtime.(*gcControllerState).startCycle -> runtime.(*gcControllerState).setMaxIdleMarkWorkers
runtime.(*gcControllerState).startCycle -> runtime.(*gcControllerState).revise
runtime.(*gcControllerState).startCycle -> go:string."pacer: assist ratio="
runtime.(*gcControllerState).startCycle -> go:string." (scan "
runtime.(*gcControllerState).startCycle -> go:string." MB in "
runtime.(*gcControllerState).startCycle -> go:string." MB) workers="
runtime.(*gcControllerState).startCycle -> runtime.(*gcControllerState).startCycle.arginfo1
runtime.(*gcControllerState).revise -> $f64.3ff199999999999a
runtime.(*gcControllerState).endCycle -> runtime.memmove
runtime.(*gcControllerState).endCycle -> go:string."pacer: "
runtime.(*gcControllerState).endCycle -> go:string."% CPU ("
runtime.(*gcControllerState).endCycle -> go:string." exp.) for "
runtime.(*gcControllerState).endCycle -> go:string." B work ("
runtime.(*gcControllerState).endCycle -> go:string." B exp.) "
runtime.(*gcControllerState).endCycle -> go:string."in "
runtime.(*gcControllerState).endCycle -> go:string." B -> "
runtime.(*gcControllerState).endCycle -> go:string." B (∆goal "
runtime.(*gcControllerState).endCycle -> go:string.", cons/mark "
runtime.(*gcControllerState).endCycle -> runtime.(*mheap).sysAlloc.arginfo1
runtime.(*gcControllerState).resetLive -> runtime.traceLocker.HeapAlloc
runtime.(*gcControllerState).heapGoalInternal -> runtime.(*gcControllerState).memoryLimitHeapGoal
runtime.(*gcControllerState).trigger -> go:string."trigger="
runtime.(*gcControllerState).trigger -> go:string." heapGoal="
runtime.(*gcControllerState).trigger -> go:string."minTrigger="
runtime.(*gcControllerState).trigger -> go:string." maxTrigger="
runtime.(*gcControllerState).trigger -> go:string."produced a trigger greater than the heap goal"
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string."n="
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string." max="
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> go:string."negative idle mark workers"
runtime.(*gcControllerState).setMaxIdleMarkWorkers -> fmt.(*buffer).writeRune.arginfo1
runtime.(*scavengeIndex).nextGen -> runtime.minOffAddr
runtime.(*stackScanState).putPtr -> runtime.getempty
runtime.(*stackScanState).putPtr -> go:string."address not a stack address"
runtime.(*stackScanState).getPtr -> gclocals·wTWjeoDn9+lGHgupXRaYHg==
runtime.(*stackScanState).getPtr -> runtime.setenv_c.stkobj
runtime.(*stackScanState).addObject -> go:string."objects added out of order or overlapping"
runtime.binarySearchTree -> sort.Slice.argliveinfo
runtime.(*activeSweep).end -> go:string."pacer: sweep done at heap size "
runtime.(*activeSweep).end -> go:string."MB; allocated "
runtime.(*activeSweep).end -> go:string."MB during sweep; swept "
runtime.(*activeSweep).end -> go:string." pages at "
runtime.(*activeSweep).end -> go:string." pages/byte\n"
runtime.(*activeSweep).end -> go:string."mismatched begin/end of activeSweep"
runtime.(*activeSweep).end -> go:string."sweeper left outstanding across sweep generations"
runtime.(*activeSweep).end -> runtime.(*activeSweep).end.arginfo1
runtime.(*sweepLocker).tryAcquire -> go:string."use of invalid sweepLocker"
runtime.sweepone -> runtime.(*mheap).nextSpanForSweep
runtime.sweepone -> runtime.sweepone.func1·f
runtime.sweepone -> runtime.scavenger
runtime.sweepone -> go:string."runtime: bad span s.state="
runtime.sweepone -> go:string." s.sweepgen="
runtime.sweepone -> go:string." sweepgen="
runtime.sweepone -> go:string."non in-use span in unswept list"
runtime.(*sweepLocked).sweep -> runtime.traceLocker.GCSweepSpan
runtime.(*sweepLocked).sweep -> runtime.freeSpecial
runtime.(*sweepLocked).sweep -> runtime.(*mspan).reportZombies
runtime.(*sweepLocked).sweep -> runtime.x86HasPOPCNT
runtime.(*sweepLocked).sweep -> runtime/internal/sys.OnesCount64
runtime.(*sweepLocked).sweep -> runtime.newMarkBits
runtime.(*sweepLocked).sweep -> runtime.(*mspan).refreshPinnerBits
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.func1
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func3
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.func2
runtime.(*sweepLocked).sweep -> go:string."sweep: tried to preserve a user arena span"
runtime.(*sweepLocked).sweep -> go:string."swept cached span"
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: state="
runtime.(*sweepLocked).sweep -> go:string." mheap.sweepgen="
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: bad span state after sweep"
runtime.(*sweepLocked).sweep -> go:string."runtime: nelems="
runtime.(*sweepLocked).sweep -> go:string." nalloc="
runtime.(*sweepLocked).sweep -> go:string." previous allocCount="
runtime.(*sweepLocked).sweep -> go:string." nfreed="
runtime.(*sweepLocked).sweep -> go:string."sweep increased allocation count"
runtime.(*sweepLocked).sweep -> runtime.tracefree
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: bad span state"
runtime.(*sweepLocked).sweep -> go:string."mspan.sweep: m is not locked"
runtime.(*sweepLocked).sweep -> gclocals·oWUH65jJRHCNQkcTmSXGew==
runtime.(*sweepLocked).sweep -> gclocals·jMhT1EauLZJjo/FUmflJrw==
runtime.(*sweepLocked).sweep -> runtime.(*sweepLocked).sweep.stkobj
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.puintptr.ptr
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.(*mspan).base
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.pageTraceFree
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.lock
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.(*mheap).freeSpanLocked
runtime.(*sweepLocked).sweep.(*mheap).freeSpan.func4 -> runtime.unlock
runtime.(*sweepLocked).sweep.func1 -> runtime.(*mSpanList).remove
runtime.(*sweepLocked).sweep.func1 -> go:string."user arena span is on the wrong list"
runtime.(*mspan).reportZombies -> go:string."runtime: marked free object in span "
runtime.(*mspan).reportZombies -> runtime.printuintptr
runtime.(*mspan).reportZombies -> go:string.", elemsize="
runtime.(*mspan).reportZombies -> go:string." freeindex="
runtime.(*mspan).reportZombies -> go:string." (bad use of unsafe.Pointer? try -d=checkptr)\n"
runtime.(*mspan).reportZombies -> go:string." alloc"
runtime.(*mspan).reportZombies -> go:string." free "
runtime.(*mspan).reportZombies -> go:string." marked  "
runtime.(*mspan).reportZombies -> go:string." unmarked"
runtime.(*mspan).reportZombies -> go:string." zombie"
runtime.(*mspan).reportZombies -> runtime.hexdumpWords
runtime.(*mspan).reportZombies -> go:string."found pointer to free object"
runtime.(*mspan).reportZombies -> gclocals·ywzTtdCORaV6scHpzk5qeg==
runtime.(*mspan).reportZombies -> runtime.(*mspan).reportZombies.stkobj
runtime.deductSweepCredit -> gclocals·lf0jAOJ5icNqMXtP6rxGWQ==
runtime.(*gcWork).put -> runtime.putfull
runtime.(*gcWork).put -> runtime.(*gcWork).init
runtime.(*gcWork).put -> runtime.(*gcControllerState).enlistWorker
runtime.(*gcControllerState).enlistWorker -> runtime.preemptone
runtime.(*gcWork).init -> runtime.trygetfull
runtime.(*gcWork).balance -> runtime.handoff
runtime.getempty -> runtime.getempty.func1
runtime.getempty -> runtime.lfnodeValidate
runtime.getempty -> runtime.(*workbuf).checkempty
runtime.getempty -> gclocals·VfBBYR1OZkNEohKBh3RGug==
runtime.lfnodeValidate -> go:string."runtime: bad lfnode address "
runtime.lfnodeValidate -> go:string."bad lfnode address"
runtime.lfnodeValidate -> go:string."lfstack node allocated from the heap"
runtime.(*workbuf).checkempty -> go:string."workbuf is not empty"
runtime.putempty -> runtime.(*lfstack).push
runtime.(*lfstack).push -> go:string."runtime: lfstack.push invalid packing: node="
runtime.(*lfstack).push -> go:string." cnt="
runtime.(*lfstack).push -> go:string." packed="
runtime.(*lfstack).push -> go:string." -> node="
runtime.(*lfstack).push -> go:string."lfstack.push"
runtime.(*lfstack).push -> gclocals·XuwES5/hudXo+IvuobmkCQ==
runtime.putfull -> runtime.(*workbuf).checknonempty
runtime.(*workbuf).checknonempty -> go:string."workbuf is empty"
runtime.prepareFreeWorkbufs -> go:string."cannot free workbufs when work.full != 0"
runtime.freeSomeWbufs -> runtime.freeSomeWbufs.func1
runtime.freeSomeWbufs -> strconv.FormatBool.arginfo1
runtime.(*mheap).alloc -> runtime.(*mheap).alloc.func1
runtime.(*mheap).alloc -> runtime.(*mheap).alloc.stkobj
runtime.(*mheap).alloc.func1 -> runtime.(*mheap).reclaim
runtime.(*mheap).alloc.func1 -> runtime.(*mheap).allocSpan
runtime.(*mheap).reclaim -> runtime.(*mheap).reclaimChunk
runtime.(*mheap).reclaim -> gclocals·DsEZEqsV1VFgO2VgUUolkQ==
runtime.(*mheap).reclaim -> gclocals·8PlOE4EVpgceGm15U9+TVA==
runtime.(*mheap).reclaimChunk -> gclocals·Meqy9zqToy3GClDgfrwToA==
runtime.(*mheap).reclaimChunk -> gclocals·YclEqXZVep8OLl/P3CzRhA==
runtime.(*mheap).reclaimChunk -> runtime.(*mheap).reclaimChunk.arginfo1
runtime.(*mheap).reclaimChunk -> runtime.(*mheap).reclaimChunk.argliveinfo
runtime.(*mheap).allocManual -> go:string."manual span allocation called with non-manually-managed type"
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).allocToCache
runtime.(*mheap).allocSpan -> runtime.(*pageCache).alloc
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).alloc
runtime.(*mheap).allocSpan -> runtime.(*mheap).grow
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocMSpanLocked
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocSpan.func1·f
runtime.(*mheap).allocSpan -> runtime.(*pageAlloc).scavenge
runtime.(*mheap).allocSpan -> runtime.(*mheap).initSpan
runtime.(*mheap).allocSpan -> runtime.madvise
runtime.(*mheap).allocSpan -> go:string."grew heap, but no adequate free space found"
runtime.(*mheap).allocSpan -> runtime.(*mheap).allocSpan.arginfo1
runtime.(*pageAlloc).scavenge -> runtime.(*scavengeIndex).find
runtime.(*pageAlloc).scavenge -> runtime.(*pageAlloc).scavenge.func1
runtime.(*pageAlloc).scavenge -> gclocals·cRnfy3ll8DXPG7zGjyjjXw==
runtime.(*pageAlloc).scavenge -> runtime.(*pageAlloc).scavenge.stkobj
runtime.(*pageAlloc).scavenge.func1 -> runtime.(*pageAlloc).scavengeOne
runtime.(*pageAlloc).scavengeOne -> runtime.physPageSize
runtime.(*pageAlloc).scavengeOne -> runtime.(*pallocData).findScavengeCandidate
runtime.(*pageAlloc).scavengeOne -> runtime.(*pallocData).allocRange
runtime.(*pageAlloc).scavengeOne -> runtime.(*pageAlloc).update
runtime.(*pageAlloc).scavengeOne -> runtime.(*pageBits).clearRange
runtime.(*pageAlloc).scavengeOne -> runtime.(*pageBits).setRange
runtime.(*pageAlloc).scavengeOne -> runtime.(*scavengeIndex).setEmpty
runtime.(*pallocData).findScavengeCandidate -> runtime.fillAligned
runtime.(*pallocData).findScavengeCandidate -> runtime.physHugePageSize
runtime.(*pallocData).findScavengeCandidate -> go:string."runtime: min = "
runtime.(*pallocData).findScavengeCandidate -> go:string."min too large"
runtime.(*pallocData).findScavengeCandidate -> go:string."min must be a non-zero power of 2"
runtime.(*pallocData).findScavengeCandidate -> runtime.(*pallocData).findScavengeCandidate.argliveinfo
runtime.fillAligned -> go:string."bad m value"
runtime.(*mheap).allocMSpanLocked -> runtime.(*fixalloc).alloc
runtime.(*fixalloc).alloc -> go:string."runtime: use of FixAlloc_Alloc before FixAlloc_Init\n"
runtime.(*fixalloc).alloc -> go:string."runtime: internal error"
runtime.(*mheap).initSpan -> runtime.(*mspan).init
runtime.(*mheap).initSpan -> runtime.(*mheap).allocNeedsZero
runtime.(*mheap).initSpan -> runtime.class_to_divmagic
runtime.(*mheap).initSpan -> runtime.(*mheap).setSpans
runtime.(*mheap).initSpan -> runtime.(*mheap).initSpan.arginfo1
runtime.(*mheap).allocNeedsZero -> go:string."potentially overlapping in-use allocations detected"
runtime.(*mheap).grow -> runtime.(*mheap).sysAlloc
runtime.(*mheap).grow -> runtime.sysMap
runtime.(*mheap).grow -> runtime.(*pageAlloc).grow
runtime.(*mheap).grow -> go:string."runtime: out of memory: cannot allocate "
runtime.(*mheap).grow -> go:string."-byte block ("
runtime.(*mheap).grow -> go:string." in use)\n"
runtime.(*mheap).sysAlloc -> runtime.(*linearAlloc).alloc
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating allArenas"
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating heap arena metadata"
runtime.(*mheap).sysAlloc -> go:string."arena already initialized"
runtime.(*mheap).sysAlloc -> go:string."out of memory allocating heap arena map"
runtime.(*mheap).sysAlloc -> runtime.sysReserve
runtime.(*mheap).sysAlloc -> runtime.munmap
runtime.(*mheap).sysAlloc -> runtime.sysReserveAligned
runtime.(*mheap).sysAlloc -> go:string."region exceeds uintptr range"
runtime.(*mheap).sysAlloc -> go:string."base outside usable address space"
runtime.(*mheap).sysAlloc -> go:string."end outside usable address space"
runtime.(*mheap).sysAlloc -> go:string."misrounded allocation in sysAlloc"
runtime.(*mheap).sysAlloc -> go:string."runtime: memory allocated by OS ["
runtime.(*mheap).sysAlloc -> go:string.") not in usable address space: "
runtime.(*mheap).sysAlloc -> go:string."memory reservation exceeds address space limit"
runtime.(*mheap).sysAlloc -> gclocals·R87QilPGM3fZsG3F973zVQ==
runtime.(*mheap).sysAlloc -> gclocals·8+ahKvN7WOr4XHG/QNxtdw==
runtime.(*mheap).sysAlloc -> strconv.roundShortest.argliveinfo
runtime.(*linearAlloc).alloc -> gclocals·YHpwtXfdZGvGg0cxKddLDA==
runtime.sysMap -> runtime.sysMapOS
runtime.sysMap -> gclocals·QMy8w8cIiurtMrEMlsjK+Q==
runtime.sysMapOS -> go:string."runtime: mmap("
runtime.sysMapOS -> go:string.") returned "
runtime.sysMapOS -> go:string."runtime: cannot map pages in arena address space"
runtime.sysMapOS -> go:string."runtime: out of memory"
runtime.sysMapOS -> gclocals·bb+LSCCik3x40Cn8eFqL9w==
runtime.sysMapOS -> gclocals·wzwZd8fw2WzsZRiaoAKqRA==
runtime.(*mheap).freeSpanLocked -> runtime.(*pageAlloc).free
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid stack free"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid span state"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - span "
runtime.(*mheap).freeSpanLocked -> go:string." ptr "
runtime.(*mheap).freeSpanLocked -> go:string." allocCount "
runtime.(*mheap).freeSpanLocked -> go:string." sweepgen "
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid free"
runtime.(*mheap).freeSpanLocked -> go:string."mheap.freeSpanLocked - invalid free of user arena chunk"
runtime.(*mSpanList).remove -> go:string."runtime: failed mSpanList.remove span.npages="
runtime.(*mSpanList).remove -> go:string." span="
runtime.(*mSpanList).remove -> go:string." prev="
runtime.(*mSpanList).remove -> go:string." span.list="
runtime.(*mSpanList).remove -> go:string." list="
runtime.(*mSpanList).remove -> go:string."mSpanList.remove"
runtime.(*mSpanList).insert -> go:string."runtime: failed mSpanList.insert "
runtime.(*mSpanList).insert -> go:string."mSpanList.insert"
runtime.freeSpecial -> runtime.mProf_Free
runtime.freeSpecial -> runtime.queuefinalizer
runtime.freeSpecial -> go:string."bad special kind"
runtime.queuefinalizer -> runtime.finlock
runtime.queuefinalizer -> runtime.finq
runtime.queuefinalizer -> runtime.finc
runtime.queuefinalizer -> runtime.gcWriteBarrier8
runtime.queuefinalizer -> runtime.fingStatus
runtime.queuefinalizer -> runtime.finalizer1
runtime.queuefinalizer -> go:string."queuefinalizer during GC"
runtime.queuefinalizer -> gclocals·QbuORTC759gvi2Ssb6xpCQ==
runtime.newMarkBits -> runtime.gcBitsArenas
runtime.newMarkBits -> runtime.newArenaMayUnlock
runtime.newMarkBits -> go:string."markBits overflow"
runtime.(*pageAlloc).grow -> runtime.(*pageAlloc).sysGrow
runtime.(*pageAlloc).grow -> runtime.(*scavengeIndex).grow
runtime.(*pageAlloc).grow -> runtime.makeAddrRange
runtime.(*pageAlloc).grow -> runtime.(*addrRanges).add
runtime.(*pageAlloc).grow -> go:string."pageAlloc: out of memory"
runtime.(*scavengeIndex).grow -> runtime.(*scavengeIndex).sysGrow
runtime.(*scavengeIndex).grow -> gclocals·cNGUyZq94N9QFR70tEjj5A==
runtime.(*pageAlloc).update -> runtime.(*pallocBits).summarize
runtime.(*pageAlloc).update -> runtime.levelShift
runtime.(*pageAlloc).update -> runtime.levelBits
runtime.(*pageAlloc).update -> runtime.levelLogPages
runtime.(*pageAlloc).update -> runtime.mergeSummaries
runtime.(*pageAlloc).update -> runtime.panicSliceB
runtime.(*pageAlloc).update -> runtime.panicSliceAcapU
runtime.(*pageAlloc).update -> gclocals·Tc/LeluABNzhfUMhkZPKmg==
runtime.(*pageAlloc).update -> gclocals·dWfovk9haRLV9HOdqHCp5w==
runtime.(*pageAlloc).update -> runtime.(*pageAlloc).update.arginfo1
runtime.(*pageAlloc).update -> runtime.(*pageAlloc).update.argliveinfo
runtime.(*pageAlloc).alloc -> runtime.(*pallocBits).find
runtime.(*pageAlloc).alloc -> runtime.(*pageAlloc).find
runtime.(*pageAlloc).alloc -> runtime.maxOffAddr
runtime.(*pageAlloc).alloc -> runtime.(*pageAlloc).allocRange
runtime.(*pageAlloc).alloc -> go:string."runtime: max = "
runtime.(*pageAlloc).alloc -> go:string.", npages = "
runtime.(*pageAlloc).alloc -> go:string."runtime: searchIdx = "
runtime.(*pageAlloc).alloc -> go:string.", p.searchAddr = "
runtime.(*pageAlloc).alloc -> go:string."bad summary data"
runtime.(*pageAlloc).allocRange -> runtime.(*pageBits).popcntRange
runtime.(*pageAlloc).allocRange -> runtime.(*scavengeIndex).alloc
runtime.(*pageAlloc).allocRange -> gclocals·0Xx9cqNn7i98TMy5xdHpTg==
runtime.(*scavengeIndex).alloc -> runtime.(*scavChunkData).alloc
runtime.(*scavChunkData).alloc -> go:string."runtime: inUse="
runtime.(*scavChunkData).alloc -> go:string." npages="
runtime.(*scavChunkData).alloc -> go:string."too many pages allocated in chunk?"
runtime.(*scavChunkData).alloc -> runtime.mapaccess1_fast32.arginfo1
runtime.(*pageAlloc).find -> runtime.(*pageAlloc).find.func1
runtime.(*pageAlloc).find -> runtime.(*pageAlloc).findMappedAddr
runtime.(*pageAlloc).find -> go:string."runtime: summary["
runtime.(*pageAlloc).find -> go:string."]["
runtime.(*pageAlloc).find -> go:string."] = ("
runtime.(*pageAlloc).find -> go:string."runtime: npages = "
runtime.(*pageAlloc).find -> go:string."] = "
runtime.(*pageAlloc).find -> go:string."runtime: level = "
runtime.(*pageAlloc).find -> go:string.", j0 = "
runtime.(*pageAlloc).find -> go:string."runtime: p.searchAddr = "
runtime.(*pageAlloc).find -> go:string.", i = "
runtime.(*pageAlloc).find -> go:string."runtime: levelShift[level] = "
runtime.(*pageAlloc).find -> go:string.", levelBits[level] = "
runtime.(*pageAlloc).find -> gclocals·SXYRnj4PMMrm4I3Ahd1obw==
runtime.(*pageAlloc).find -> gclocals·FVF61mTB08tE/3lH0rPdHA==
runtime.(*pageAlloc).findMappedAddr -> runtime.(*addrRanges).findAddrGreaterEqual
runtime.(*pageAlloc).findMappedAddr -> runtime.offAddrToLevelIndex.arginfo1
runtime.(*pageAlloc).find.func1 -> go:string."runtime: addr = "
runtime.(*pageAlloc).find.func1 -> go:string.", size = "
runtime.(*pageAlloc).find.func1 -> go:string."runtime: base = "
runtime.(*pageAlloc).find.func1 -> go:string.", bound = "
runtime.(*pageAlloc).find.func1 -> go:string."range partially overlaps"
runtime.(*pageAlloc).find.func1 -> internal/reflectlite.name.readVarint.arginfo1
runtime.(*pageAlloc).free -> runtime.(*scavengeIndex).free
runtime.(*scavengeIndex).free -> runtime.(*scavChunkData).free
runtime.(*scavChunkData).free -> go:string."allocated pages below zero?"
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func2
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func3
runtime.(*pageAlloc).sysGrow -> runtime.(*pageAlloc).sysGrow.func1·f
runtime.(*pageAlloc).sysGrow -> runtime.(*addrRanges).findSucc
runtime.(*pageAlloc).sysGrow -> runtime.addrRange.subtract
runtime.(*pageAlloc).sysGrow -> go:string.", limit = "
runtime.(*pageAlloc).sysGrow -> go:string."sysGrow bounds not aligned to pallocChunkBytes"
runtime.(*pageAlloc).sysGrow -> gclocals·3uxSrvnADLfyxQQMjtaOyA==
runtime.(*pageAlloc).sysGrow.func3 -> runtime.(*pageAlloc).sysGrow.func3.arginfo1
runtime.(*pageCache).alloc -> runtime.(*pageCache).allocN
runtime.(*pageAlloc).allocToCache -> gclocals·zs5ZgaphdoenM8+qMgYpxw==
runtime.(*pallocBits).find -> runtime.(*pallocBits).findSmallN
runtime.(*pallocBits).find -> runtime.(*pallocBits).findLargeN
runtime.mProf_Flush -> runtime.profMemActiveLock
runtime.mProf_Flush -> runtime.profMemFutureLock
runtime.mProf_Flush -> runtime.mProf_FlushLocked
runtime.mProf_FlushLocked -> runtime.mbuckets
runtime.mProf_FlushLocked -> runtime.(*bucket).mp
runtime.(*bucket).mp -> go:string."bad use of bucket.mp"
runtime.mProf_Malloc -> runtime.callers
runtime.mProf_Malloc -> runtime.stkbucket
runtime.mProf_Malloc -> runtime.mProf_Malloc.func1
runtime.mProf_Malloc -> runtime.panicSliceAlen
runtime.mProf_Malloc -> gclocals·RsxhRHA9BNTAZWuXCLrHUg==
runtime.stkbucket -> runtime.buckhash
runtime.stkbucket -> runtime.profInsertLock
runtime.stkbucket -> runtime.(*bucket).stk
runtime.stkbucket -> runtime.newBucket
runtime.stkbucket -> runtime.xbuckets
runtime.stkbucket -> runtime.bbuckets
runtime.stkbucket -> gclocals·OQcVLeG8nYNq7FQTnM4UAA==
runtime.stkbucket -> gclocals·26sz/awC7/Gp1WQw1bVsmw==
runtime.stkbucket -> runtime.stkbucket.arginfo1
runtime.stkbucket -> runtime.stkbucket.argliveinfo
runtime.newBucket -> go:string."invalid profile bucket type"
runtime.(*bucket).stk -> go:string."bad profile stack count"
runtime.mProf_Malloc.func1 -> runtime.setprofilebucket
runtime.setprofilebucket -> runtime.addspecial
runtime.setprofilebucket -> go:string."setprofilebucket: profile already set"
runtime.addspecial -> runtime.(*mspan).ensureSwept
runtime.addspecial -> go:string."addspecial on invalid pointer"
runtime.addspecial -> gclocals·Tumw6UTxFRAq+KySimItaw==
runtime.addspecial -> gclocals·GsZQVFCfXg4uNaJCKxe2Ng==
runtime.(*mspan).ensureSwept -> go:string."mspan.ensureSwept: m is not locked"
runtime.(*mLockProfile).recordUnlock -> runtime.(*mLockProfile).captureStack
runtime.(*mLockProfile).recordUnlock -> runtime.(*mLockProfile).store
runtime.(*mLockProfile).recordUnlock -> gclocals·3t8WlE+CEPpgnWbvvNfnSA==
runtime.(*mLockProfile).captureStack -> runtime.(*mLockProfile).captureStack.func1
runtime.(*mLockProfile).captureStack -> runtime._LostContendedRuntimeLock
runtime.(*mLockProfile).captureStack -> gclocals·j8vwo/9Lpy9SVY/L498xRw==
runtime.(*mLockProfile).captureStack -> runtime.(*mLockProfile).captureStack.stkobj
runtime.(*mLockProfile).captureStack.func1 -> runtime.tracebackPCs
runtime.(*mLockProfile).store -> runtime.saveBlockEventStack
runtime.saveBlockEventStack -> runtime.(*bucket).bp
runtime.saveBlockEventStack -> runtime.profBlockLock
runtime.saveBlockEventStack -> gclocals·2rO4LZpmpr1MJj9igFBNjA==
runtime.saveBlockEventStack -> runtime.saveBlockEventStack.arginfo1
runtime.saveBlockEventStack -> reflect.methodReceiver.argliveinfo
runtime.(*bucket).bp -> go:string."bad use of bucket.bp"
runtime.tracealloc -> runtime.tracelock
runtime.tracealloc -> go:string."tracealloc("
runtime.tracealloc -> runtime.goroutineheader
runtime.tracealloc -> runtime.traceback1
runtime.tracealloc -> runtime.tracealloc.func1
runtime.tracealloc -> gclocals·AcWUdNcH0z0Ou9uxr0qJZw==
runtime.tracealloc -> gclocals·4tBwSpHxcI9u3KdWJ3WFFw==
runtime.tracealloc -> runtime.tracealloc.stkobj
runtime.tracefree -> go:string."tracefree("
runtime.tracefree -> runtime.tracefree.func1
runtime.tracefree -> gclocals·pO+Ir39K1AIh1J2HWiHRgQ==
runtime.tracegc -> go:string."tracegc()\n"
runtime.tracegc -> runtime.tracebackothers
runtime.tracegc -> go:string."end tracegc\n"
runtime.makeAddrRange -> go:string."addr range base and limit are not in the same memory segment"
runtime.addrRange.subtract -> go:string."bad prune"
runtime.addrRange.subtract -> runtime.addrRange.subtract.arginfo1
runtime.(*addrRanges).add -> go:string."runtime: range = {"
runtime.(*addrRanges).add -> go:string."}\n"
runtime.(*addrRanges).add -> go:string."attempted to add zero-sized address range"
runtime.(*spanSet).push -> runtime.(*atomicHeadTailIndex).incTail
runtime.(*spanSet).push -> internal/cpu.CacheLineSize
runtime.(*spanSet).push -> runtime.spanSetBlockPool
runtime.(*spanSet).push -> runtime.(*spanSetBlockAlloc).alloc
runtime.(*spanSet).push -> gclocals·SLvAPFZ8AkbNhIX9KX7YiQ==
runtime.(*spanSet).push -> gclocals·k+SiwGqpCepLJxkbMgNwhQ==
runtime.(*atomicHeadTailIndex).incTail -> go:string."runtime: head = "
runtime.(*atomicHeadTailIndex).incTail -> go:string.", tail = "
runtime.(*atomicHeadTailIndex).incTail -> go:string."headTailIndex overflow"
runtime.(*sysMemStat).add -> go:string."runtime: val="
runtime.(*sysMemStat).add -> go:string." n="
runtime.(*sysMemStat).add -> go:string."sysMemStat overflow"
runtime.(*consistentHeapStats).acquire -> go:string."runtime: seq="
runtime.(*consistentHeapStats).acquire -> go:string."bad sequence number"
runtime.wbBufFlush -> runtime.wbBufFlush.func1·f
runtime.wbBufFlush1 -> runtime.shade
runtime.wbBufFlush1 -> runtime.(*gcWork).putBatch
runtime.wbBufFlush1 -> runtime.panicSliceAlenU
runtime.(*gcWork).putBatch -> fmt.(*fmt).pad.arginfo1
runtime.semawakeup -> runtime.pthread_cond_signal
runtime.semawakeup -> go:string."semawakeup on Darwin signal stack"
runtime.deferreturn -> gclocals·P7bMlbTrVXKye0ADLQNLpA==
runtime.deferreturn -> runtime.deferreturn.stkobj
runtime.(*_panic).start -> runtime.gcWriteBarrier6
runtime.(*_panic).start -> runtime.(*_panic).nextFrame
runtime.(*_panic).start -> gclocals·wBS4fiKwwXBG0Q3AcyXF/Q==
runtime.(*_panic).nextDefer -> runtime.deferconvert
runtime.(*_panic).nextDefer -> runtime.freedefer
runtime.(*_panic).nextDefer -> runtime.recovery·f
runtime.(*_panic).nextDefer -> go:string."recovery failed"
runtime.(*_panic).nextDefer -> go:string."bad panic stack"
runtime.(*_panic).nextDefer -> gclocals·sFJ8dFKr24TXkTgDKPtggg==
runtime.deferconvert -> runtime/internal/atomic.casPointer
runtime.deferconvert -> gclocals·KoALNj2AjeKwjQts5/oihA==
runtime.freedefer -> runtime.freedeferfn
runtime.freedefer -> type:runtime._defer
runtime.freedefer -> runtime.wbZero
runtime.freedefer -> type:*runtime._defer
runtime.freedefer -> runtime.growslice
runtime.freedefer -> gclocals·SVSplcl1PypF9kJBFSGnrw==
runtime.wbZero -> runtime.bulkBarrierPreWrite
runtime.bulkBarrierPreWrite -> runtime.(*mspan).typePointersOf
runtime.bulkBarrierPreWrite -> runtime.bulkBarrierBitmap
runtime.bulkBarrierPreWrite -> go:string."bulkBarrierPreWrite: unaligned arguments"
runtime.bulkBarrierPreWrite -> gclocals·MHpJa7viAur6ttnj2mBTdA==
runtime.bulkBarrierPreWrite -> gclocals·7aG+C0vX4uoGRZnmH90PWw==
runtime.bulkBarrierBitmap -> gclocals·Q/wGlK8YQUDaNOijjAVx7Q==
runtime.bulkBarrierBitmap -> gclocals·t4gzOUwoWgW6+GIrjTfRAg==
runtime.freedeferfn -> go:string."freedefer with d.fn != nil"
runtime.(*_panic).nextFrame -> runtime.(*_panic).nextFrame.func1
runtime.(*_panic).nextFrame -> gclocals·EXTrhv4b3ahawRWAszmcVw==
runtime.(*_panic).nextFrame.func1 -> runtime.(*_panic).initOpenCodedDefers
runtime.(*_panic).initOpenCodedDefers -> runtime.(*moduledata).textAddr
runtime.(*_panic).initOpenCodedDefers -> runtime.panicshift
runtime.(*_panic).initOpenCodedDefers -> runtime..stmp_135
runtime.(*_panic).initOpenCodedDefers -> go:string."missing deferreturn"
runtime.(*_panic).initOpenCodedDefers -> fmt.(*ss).convertFloat.arginfo1
runtime.panicshift -> go:string."negative shift amount"
runtime.panicshift -> runtime.panicCheck1
runtime.panicshift -> runtime.shiftError
runtime.panicCheck1 -> runtime.findfunc
runtime.panicCheck1 -> runtime.(*moduledata).funcName
runtime.panicCheck1 -> fmt.(*fmt).padString.arginfo1
runtime.fatalpanic -> runtime.fatalpanic.func1
runtime.fatalpanic -> runtime.fatalpanic.func2·f
runtime.fatalpanic -> runtime.fatalpanic.stkobj
runtime.fatalpanic.func1 -> runtime.printpanics
runtime.fatalpanic.func1 -> gclocals·8cC3q7ETfLVC+gt5Tw4C8g==
runtime.printpanics -> runtime.gcbits.0900000000000000
runtime.printpanics -> go:string." [recovered]"
runtime.dopanic_m -> runtime.sigtable
runtime.dopanic_m -> go:string."[signal "
runtime.dopanic_m -> go:string." code="
runtime.dopanic_m -> go:string." addr="
runtime.dopanic_m -> go:string." pc="
runtime.dopanic_m -> go:string."]\n"
runtime.dopanic_m -> runtime.traceback_cache
runtime.dopanic_m -> go:string."\nruntime stack:\n"
runtime.dopanic_m -> runtime.didothers
runtime.dopanic_m -> runtime.deadlock
runtime.suspendG -> runtime.castogscanstatus
runtime.suspendG -> runtime.casfrom_Gscanstatus
runtime.suspendG -> runtime.preemptM
runtime.suspendG -> runtime.casGFromPreempted
runtime.suspendG -> go:string."runtime:   gp: gp="
runtime.suspendG -> go:string."runtime: getg:  g="
runtime.suspendG -> go:string.",  g->atomicstatus="
runtime.suspendG -> go:string."invalid g status"
runtime.suspendG -> go:string."suspendG from non-preemptible goroutine"
runtime.suspendG -> gclocals·26tm24YiQpYrbX0K6CC8qg==
runtime.resumeG -> go:string."unexpected g status"
runtime.resumeG -> gclocals·MZn1ahbT84zU5OkLNIFByA==
runtime.resumeG -> runtime.resumeG.arginfo1
runtime.printsp -> os..stmp_9
runtime.printnl -> runtime.gcbits.0a00000000000000
runtime.printbool -> go:string."true"
runtime.printbool -> go:string."false"
runtime.printfloat -> go:string."-Inf"
runtime.printfloat -> go:string."+Inf"
runtime.printfloat -> $f64.8000000000000000
runtime.printfloat -> go:string."NaN"
runtime.printfloat -> $f64.4024000000000000
runtime.printfloat -> $f64.4014000000000000
runtime.printfloat -> runtime.gwrite
runtime.gwrite -> runtime.recordForPanic
runtime.gwrite -> runtime.write
runtime.gwrite -> fmt.Print.arginfo1
runtime.recordForPanic -> runtime.printBacklogIndex
runtime.recordForPanic -> runtime.printBacklog
runtime.printcomplex -> go:string."i)"
runtime.printint -> go:string."-"
runtime.printhex -> go:string."0123456789abcdef"
runtime.printhex -> runtime.minhexdigits
runtime.printstring -> runtime.printstring.stkobj
runtime.hexdumpWords -> go:string.": "
runtime.hexdumpWords -> go:string."<"
runtime.hexdumpWords -> go:string."> "
runtime.hexdumpWords -> gclocals·sj+B3vQUV7APRutK5sO4vA==
runtime.gopark -> runtime.park_m·f
runtime.gopark -> go:string."gopark: bad g status"
runtime.gopark -> strconv.formatDecimal.arginfo1
runtime.forEachG -> runtime.allglock
runtime.forEachGRace -> runtime.allglen
runtime.forEachGRace -> runtime.allgptr
runtime.ready -> runtime.traceLocker.GoUnpark
runtime.ready -> runtime.runqput
runtime.ready -> runtime.wakep
runtime.ready -> go:string."bad g->status in ready"
runtime.ready -> gclocals·V05kZQL6DjE8NgA6Ku0wvw==
runtime.ready -> gclocals·nxDmvyHscaz+zbbDe2n7ng==
runtime.freezetheworld -> runtime.freezing
runtime.freezetheworld -> runtime.preemptall
runtime.casfrom_Gscanstatus -> go:string."runtime: casfrom_Gscanstatus failed gp="
runtime.casfrom_Gscanstatus -> go:string.", oldval="
runtime.casfrom_Gscanstatus -> go:string.", newval="
runtime.casfrom_Gscanstatus -> go:string."casfrom_Gscanstatus: gp->status is not in scan state"
runtime.casfrom_Gscanstatus -> go:string."runtime: casfrom_Gscanstatus bad oldval gp="
runtime.casfrom_Gscanstatus -> go:string."casfrom_Gscanstatus:top gp->status is not in scan state"
runtime.casfrom_Gscanstatus -> gclocals·o3Kun4xYxg5C876ga0QjuQ==
runtime.casfrom_Gscanstatus -> gclocals·wo6LIq2LDYvKcS2rgmm9cw==
runtime.casfrom_Gscanstatus -> sync.(*poolDequeue).pack.arginfo1
runtime.castogscanstatus -> go:string."runtime: castogscanstatus oldval="
runtime.castogscanstatus -> go:string." newval="
runtime.castogscanstatus -> go:string."castogscanstatus"
runtime.casgstatus -> runtime.casgstatus.func1
runtime.casgstatus -> runtime.casgstatusAlwaysTrack
runtime.casgstatus -> runtime.(*timeHistogram).record
runtime.casgstatus -> go:string."casgstatus: waiting for Gwaiting but is Grunnable"
runtime.casgstatus.func1 -> go:string."runtime: casgstatus: oldval="
runtime.casgstatus.func1 -> go:string."casgstatus: bad incoming values"
runtime.casGFromPreempted -> go:string."bad g transition"
runtime.stopTheWorldWithSema -> runtime.traceLocker.STWStart
runtime.stopTheWorldWithSema -> runtime.traceLocker.ProcSteal
runtime.stopTheWorldWithSema -> runtime.pidleget
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: not stopped (stopwait != 0)"
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: not stopped (status != _Pgcstop)"
runtime.stopTheWorldWithSema -> runtime.notetsleep
runtime.stopTheWorldWithSema -> go:string."stopTheWorld: holding locks"
runtime.stopTheWorldWithSema -> gclocals·xDfA2elYKsihk7SON3fLwA==
runtime.notetsleep -> go:string."notetsleep not on g0"
runtime.startTheWorldWithSema -> runtime.netpollInited
runtime.startTheWorldWithSema -> runtime.netpoll
runtime.startTheWorldWithSema -> runtime.netpollWaiters
runtime.startTheWorldWithSema -> runtime.newprocs
runtime.startTheWorldWithSema -> runtime.procresize
runtime.startTheWorldWithSema -> runtime.notewakeup
runtime.startTheWorldWithSema -> runtime.newm
runtime.startTheWorldWithSema -> runtime.traceLocker.STWDone
runtime.startTheWorldWithSema -> go:string."startTheWorld: inconsistent mp->nextp"
runtime.startTheWorldWithSema -> gclocals·DQ/j7WsmpHaQFeFUZBpD6A==
runtime.startTheWorldWithSema -> runtime.startTheWorldWithSema.arginfo1
runtime.notewakeup -> go:string."notewakeup - double wakeup"
runtime.netpoll -> runtime.kq
runtime.netpoll -> runtime.kevent
runtime.netpoll -> runtime.netpollBreakRd
runtime.netpoll -> runtime.read
runtime.netpoll -> runtime.netpollWakeSig
runtime.netpoll -> runtime.(*pollDesc).setEventErr
runtime.netpoll -> runtime.netpollready
runtime.netpoll -> go:string."runtime: netpoll: break fd ready for "
runtime.netpoll -> go:string."runtime: netpoll: break fd ready for something unexpected"
runtime.netpoll -> go:string."runtime: kevent on fd "
runtime.netpoll -> go:string." failed with "
runtime.netpoll -> go:string."runtime: netpoll failed"
runtime.netpoll -> gclocals·uA//g+4WkTw7+2B/0P1Ovg==
runtime.netpoll -> runtime.netpoll.stkobj
runtime.forEachPInternal -> runtime.handoffp
runtime.forEachPInternal -> go:string."forEachP: P did not run fn"
runtime.forEachPInternal -> go:string."forEachP: not done"
runtime.forEachPInternal -> go:string."forEachP: sched.safePointWait != 0"
runtime.forEachPInternal -> gclocals·sq7YCt28HiQeyn/a/GChRw==
runtime.forEachPInternal -> gclocals·CmGAAUorubRbLKSWcDl3LA==
runtime.newm -> runtime.allocm
runtime.newm -> runtime.initSigmask
runtime.newm -> runtime.newmHandoff
runtime.newm -> runtime.newm1
runtime.newm -> go:string."on a locked thread with no template thread"
runtime.newm -> gclocals·XQmNTo7A3JgGZKKHmaAdRA==
runtime.newm -> gclocals·ESr+dlj+ZUXO8X1Jig2pHQ==
runtime.allocm -> runtime.allocmLock
runtime.allocm -> runtime.(*rwmutex).rlock
runtime.allocm -> runtime.acquirep
runtime.allocm -> type:runtime.m
runtime.allocm -> runtime.mcommoninit
runtime.allocm -> runtime.malg
runtime.allocm -> runtime.releasep
runtime.allocm -> runtime.(*rwmutex).runlock
runtime.allocm -> runtime.traceThreadDestroy
runtime.allocm -> runtime.allocm.func1
runtime.allocm -> gclocals·fFU7F4GXAurXI/8qEz6+Xg==
runtime.allocm -> gclocals·whfWZcTVDs61Ow6IV2QLxg==
runtime.allocm -> runtime.allocm.stkobj
runtime.mcommoninit -> runtime.mReserveID
runtime.mcommoninit -> runtime.mrandinit
runtime.mcommoninit -> runtime.allm
runtime.mcommoninit -> runtime.iscgo
runtime.mcommoninit -> type:runtime.cgoCallers
runtime.mReserveID -> runtime.checkmcount
runtime.mReserveID -> go:string."runtime: thread ID overflow"
runtime.checkmcount -> runtime.extraMInUse
runtime.checkmcount -> runtime.extraMLength
runtime.checkmcount -> go:string."runtime: program exceeds "
runtime.checkmcount -> go:string."-thread limit\n"
runtime.checkmcount -> go:string."thread exhaustion"
runtime.allocm.func1 -> runtime.stackfree
runtime.newm1 -> _cgo_thread_start
runtime.newm1 -> runtime.mstart
runtime.newm1 -> runtime.execLock
runtime.newm1 -> runtime.newosproc
runtime.newm1 -> go:string."_cgo_thread_start missing"
runtime.newm1 -> gclocals·QIar5BTRQNkEj7+oSgoIIg==
runtime.newm1 -> runtime.cgoCheckPtrWrite.stkobj
runtime.newosproc -> runtime.pthread_attr_init
runtime.newosproc -> go:string."runtime: failed to create new OS thread\n"
runtime.newosproc -> runtime.pthread_attr_getstacksize
runtime.newosproc -> runtime.pthread_attr_setdetachstate
runtime.newosproc -> runtime.sigset_all
runtime.newosproc -> runtime.sigprocmask
runtime.newosproc -> runtime.newosproc.func1
runtime.newosproc -> runtime.retryOnEAGAIN
runtime.newosproc.func1 -> runtime.mstart_stub
runtime.newosproc.func1 -> runtime.pthread_create
runtime.handoffp -> runtime.startm
runtime.handoffp -> runtime.pidleput
runtime.handoffp -> runtime.wakeNetPoller
runtime.startm -> runtime.mspinning·f
runtime.startm -> go:string."startm: p has runnable gs"
runtime.startm -> go:string."startm: m has p"
runtime.startm -> go:string."startm: m is spinning"
runtime.startm -> go:string."startm: P required for spinning=true"
runtime.startm -> gclocals·HEg+FDnKwiYICL8XBafhmw==
runtime.startm -> gclocals·dyqlTevkiJxXUXj+YwAGwA==
runtime.startm -> runtime.(*pinState).set.arginfo1
runtime.wakep -> runtime.pidlegetSpinning
runtime.wakep -> go:string."wakep: negative nmspinning"
runtime.wakep -> gclocals·2sk7fod/r4Un2Ul5+9OEqg==
runtime.wakeNetPoller -> runtime.netpollBreak
runtime.netpollBreak -> runtime.netpollBreakWr
runtime.netpollBreak -> go:string."runtime: netpollBreak write failed with "
runtime.netpollBreak -> go:string."runtime: netpollBreak write failed"
runtime.injectglist -> runtime.injectglist.func1·f
runtime.injectglist -> runtime.runqputbatch
runtime.injectglist -> gclocals·Th+s6nWAjs5SwKSrs0h2tg==
runtime.injectglist -> gclocals·aLdMJ8j/4RnbB+qteQfa/g==
runtime.entersyscallblock -> runtime.save
runtime.entersyscallblock -> runtime.entersyscallblock.func1
runtime.entersyscallblock -> runtime.entersyscallblock.func2
runtime.entersyscallblock -> runtime.entersyscallblock_handoff·f
runtime.entersyscallblock -> gclocals·UinhH5qS/cyML0st+leC3Q==
runtime.entersyscallblock -> runtime.entersyscallblock.stkobj
runtime.save -> runtime.badctxt
runtime.save -> go:string."save on system g not allowed"
runtime.badctxt -> go:string."ctxt != 0"
runtime.entersyscallblock.func2 -> go:string."entersyscallblock inconsistent "
runtime.entersyscallblock.func2 -> go:string." ["
runtime.entersyscallblock.func2 -> runtime.gcbits.2c00000000000000
runtime.entersyscallblock.func2 -> go:string."entersyscallblock"
runtime.malg -> type:runtime.g
runtime.malg -> runtime.malg.func1
runtime.malg -> gclocals·Zzj2FaoDzNrZlobEaq+Nzw==
runtime.malg.func1 -> runtime.stackalloc
runtime.newproc -> runtime.newproc.func1
runtime.newproc -> runtime.newproc.stkobj
runtime.newproc.func1 -> runtime.newproc1
runtime.newproc.func1 -> runtime.mainStarted
runtime.newproc1 -> go:string."go of nil func value"
runtime.newproc1 -> runtime.fatal
runtime.newproc1 -> runtime.gfget
runtime.newproc1 -> runtime.allgadd
runtime.newproc1 -> runtime.goexit
runtime.newproc1 -> runtime.gostartcallfn
runtime.newproc1 -> runtime.saveAncestors
runtime.newproc1 -> runtime.isSystemGoroutine
runtime.newproc1 -> runtime.goroutineProfile
runtime.newproc1 -> runtime.traceLocker.GoCreate
runtime.newproc1 -> go:string."newproc1: new g is not Gdead"
runtime.newproc1 -> go:string."newproc1: newg missing stack"
runtime.newproc1 -> gclocals·K1Wa0Ii10sghhg2Tzck95g==
runtime.newproc1 -> gclocals·e/VsBaBqoQ+8tSPKAR5gpg==
runtime.fatal -> runtime.fatal.func1
runtime.allgadd -> type:*runtime.g
runtime.allgadd -> go:string."allgadd: bad status Gidle"
runtime.saveAncestors -> type:runtime.ancestorInfo
runtime.saveAncestors -> runtime.makeslice
runtime.saveAncestors -> runtime.typedslicecopy
runtime.saveAncestors -> runtime.gcallers
runtime.saveAncestors -> runtime.wbMove
runtime.saveAncestors -> type:[]runtime.ancestorInfo
runtime.saveAncestors -> gclocals·d85mNdGXvkEF+KsuAoM2Ng==
runtime.typedslicecopy -> runtime.typedslicecopy.argliveinfo
runtime.gfget -> runtime.startingStackSize
runtime.gfget -> runtime.gfget.func1
runtime.gfget -> runtime.gfget.func2
runtime.gfget -> gclocals·EaSrzstw4eNlskfTrAV10A==
runtime.procresize -> runtime.traceLocker.Gomaxprocs
runtime.procresize -> runtime.allpLock
runtime.procresize -> type:*runtime.p
runtime.procresize -> runtime.idlepMask
runtime.procresize -> runtime.timerpMask
runtime.procresize -> runtime.makeslicecopy
runtime.procresize -> type:runtime.p
runtime.procresize -> runtime.(*p).init
runtime.procresize -> runtime.traceLocker.GoStop
runtime.procresize -> runtime.traceLocker.ProcStop
runtime.procresize -> runtime.traceLocker.GoStart
runtime.procresize -> runtime.(*p).destroy
runtime.procresize -> runtime.stealOrder
runtime.procresize -> runtime.(*gcCPULimiterState).resetCapacity
runtime.procresize -> go:string."procresize: invalid arg"
runtime.procresize -> gclocals·Xu4NijPRinf///4s/1zhiQ==
runtime.procresize -> gclocals·OmsU8/LVv6/VxuwoZmLIXg==
runtime.(*gcCPULimiterState).resetCapacity -> go:string."failed to acquire lock to reset capacity"
runtime.(*p).init -> runtime.allocmcache
runtime.(*p).init -> go:string."missing mcache?"
runtime.allocmcache -> runtime.allocmcache.func1
runtime.(*p).destroy -> runtime.moveTimers
runtime.(*p).destroy -> runtime.memclrHasPointers
runtime.(*p).destroy -> runtime.(*p).destroy.func1
runtime.(*p).destroy -> runtime.(*p).destroy.freemcache.func2
runtime.(*p).destroy -> runtime.gfpurge
runtime.(*p).destroy -> gclocals·oZXz5ZgjtIQYR7IxjsoPdw==
runtime.(*p).destroy.freemcache.func2 -> runtime.(*fixalloc).free
runtime.(*p).destroy.func1 -> runtime.(*pageCache).flush
runtime.acquirep -> runtime.wirep
runtime.acquirep -> runtime.traceLocker.ProcStart
runtime.wirep -> runtime.wirep.func1·f
runtime.wirep -> runtime.wirep.func2
runtime.wirep.func2 -> go:string."wirep: p->m="
runtime.wirep.func2 -> go:string.") p->status="
runtime.wirep.func2 -> go:string."wirep: invalid p state"
runtime.releasep -> runtime.releasepNoTrace
runtime.releasepNoTrace -> go:string."releasep: m="
runtime.releasepNoTrace -> go:string." m->p="
runtime.releasepNoTrace -> go:string." p->m="
runtime.releasepNoTrace -> go:string." p->status="
runtime.releasepNoTrace -> go:string."releasep: invalid p state"
runtime.releasepNoTrace -> go:string."releasep: invalid arg"
runtime.schedtrace -> runtime.starttime
runtime.schedtrace -> go:string."SCHED "
runtime.schedtrace -> go:string."ms: gomaxprocs="
runtime.schedtrace -> go:string." idleprocs="
runtime.schedtrace -> go:string." threads="
runtime.schedtrace -> go:string." spinningthreads="
runtime.schedtrace -> go:string." needspinning="
runtime.schedtrace -> go:string." idlethreads="
runtime.schedtrace -> go:string." runqueue="
runtime.schedtrace -> go:string." gcwaiting="
runtime.schedtrace -> go:string." nmidlelocked="
runtime.schedtrace -> go:string." stopwait="
runtime.schedtrace -> go:string." sysmonwait="
runtime.schedtrace -> go:string."  P"
runtime.schedtrace -> go:string.": status="
runtime.schedtrace -> go:string." schedtick="
runtime.schedtrace -> go:string." syscalltick="
runtime.schedtrace -> go:string." m="
runtime.schedtrace -> go:string." runqsize="
runtime.schedtrace -> go:string." gfreecnt="
runtime.schedtrace -> go:string." timerslen="
runtime.schedtrace -> go:string."["
runtime.schedtrace -> go:string."  M"
runtime.schedtrace -> go:string.": p="
runtime.schedtrace -> go:string." curg="
runtime.schedtrace -> go:string." mallocing="
runtime.schedtrace -> go:string." throwing="
runtime.schedtrace -> go:string." preemptoff="
runtime.schedtrace -> go:string." locks="
runtime.schedtrace -> go:string." dying="
runtime.schedtrace -> go:string." spinning="
runtime.schedtrace -> go:string." blocked="
runtime.schedtrace -> go:string." lockedg="
runtime.schedtrace -> runtime.schedtrace.func1·f
runtime.schedtrace -> gclocals·KMo9CgFW/QE4XuR2lrIdXQ==
runtime.pidleput -> runtime.updateTimerPMask
runtime.pidleput -> go:string."must be able to track idle limiter event"
runtime.pidleput -> go:string."pidleput: P has non-empty run queue"
runtime.runqput -> runtime.runqputslow
runtime.runqputslow -> go:string."runqputslow: queue is not full"
runtime.runqputslow -> gclocals·QiD9DzPOHMceHi/jRx2KVw==
runtime.runqputslow -> runtime.runqputslow.arginfo1
runtime.mrandinit -> runtime.bootstrapRand
runtime.mrandinit -> runtime.bootstrapRandReseed
runtime.mrandinit -> internal/chacha8rand.block
runtime.mrandinit -> runtime.rand
runtime.bootstrapRand -> runtime.globalRand
runtime.bootstrapRand -> go:string."randinit missed"
runtime.bootstrapRand -> internal/chacha8rand.(*State).Refill
runtime.bootstrapRandReseed -> internal/chacha8rand.(*State).Reseed
runtime.retryOnEAGAIN -> runtime.usleep_no_g
runtime.(*godebugInc).IncNonDefault -> runtime.godebugNewIncNonDefault
runtime.(*godebugInc).IncNonDefault -> type:func()
runtime.(*godebugInc).IncNonDefault -> gclocals·Od6IYKVwEagxAjesR7vuiA==
runtime.(*rwmutex).rlock -> runtime.(*rwmutex).rlock.func1
runtime.(*rwmutex).rlock -> gclocals·AzW08EQV0LVfnDEAZer1Nw==
runtime.(*rwmutex).rlock.func1 -> runtime.notesleep
runtime.(*rwmutex).rlock.func1 -> gclocals·9ZqeuZegeWmbonLi7TPPLg==
runtime.notesleep -> go:string."notesleep - waitm out of sync"
runtime.notesleep -> go:string."notesleep not on g0"
runtime.notesleep -> gclocals·PLsaI/y2btsTjCgVjJ9ipw==
runtime.(*rwmutex).runlock -> go:string."runlock of unlocked rwmutex"
runtime.semacquire1 -> runtime.acquireSudog
runtime.semacquire1 -> runtime.semtable
runtime.semacquire1 -> runtime.blockprofilerate
runtime.semacquire1 -> runtime.(*semaRoot).queue
runtime.semacquire1 -> runtime.blockevent
runtime.semacquire1 -> runtime.releaseSudog
runtime.semacquire1 -> go:string."semacquire not on the G stack"
runtime.semacquire1 -> gclocals·9ua+7HN8WO65akhINUP2QQ==
runtime.semacquire1 -> runtime.semacquire1.arginfo1
runtime.blockevent -> runtime.blocksampled
runtime.blockevent -> runtime.saveblockevent
runtime.saveblockevent -> fmt.(*ss).scanOne.argliveinfo
runtime.acquireSudog -> go:string."acquireSudog: found s.elem != nil in cache"
runtime.acquireSudog -> type:*runtime.sudog
runtime.acquireSudog -> type:runtime.sudog
runtime.acquireSudog -> gclocals·35bp/sFrHnJ9ulRANvTjmA==
runtime.releaseSudog -> go:string."runtime: releaseSudog with non-nil gp.param"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil c"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil waitlink"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil prev"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil next"
runtime.releaseSudog -> go:string."runtime: sudog with non-false isSelect"
runtime.releaseSudog -> go:string."runtime: sudog with non-nil elem"
runtime.semrelease1 -> runtime.(*semaRoot).dequeue
runtime.semrelease1 -> sync.event
runtime.semrelease1 -> runtime.readyWithTime
runtime.semrelease1 -> runtime.goyield_m·f
runtime.semrelease1 -> go:string."corrupted semaphore ticket"
runtime.semrelease1 -> gclocals·We1Is8spiQl0y09naytfeA==
runtime.semrelease1 -> gclocals·uebvEQACGW2qnxiXhuX0lg==
runtime.readyWithTime -> runtime.readyWithTime.goready.func1
runtime.(*semaRoot).queue -> runtime.(*semaRoot).rotateLeft
runtime.(*semaRoot).queue -> runtime.(*semaRoot).rotateRight
runtime.(*semaRoot).queue -> runtime..stmp_147
runtime.(*semaRoot).queue -> gclocals·JNsYcqno00MdaZVFMLCVuA==
runtime.(*semaRoot).queue -> gclocals·b0WJAbYnhc5MFtZfpURKcA==
runtime.(*semaRoot).dequeue -> gclocals·NcVqcHrtYQqWV05KWf2NLg==
runtime.(*semaRoot).rotateLeft -> go:string."semaRoot rotateLeft"
runtime.(*semaRoot).rotateRight -> go:string."semaRoot rotateRight"
runtime.preemptM -> runtime.pendingPreemptSignals
runtime.preemptM -> runtime.pthread_kill
runtime.dieFromSignal -> runtime.unblocksig
runtime.dieFromSignal -> runtime.handlingSig
runtime.dieFromSignal -> runtime.raise
runtime.dieFromSignal -> runtime.setsig
runtime.setsig -> runtime.sighandler
runtime.setsig -> runtime.cgoSigtramp
runtime.setsig -> runtime.sigtramp
runtime.setsig -> runtime.sigaction
runtime.setsig -> math/bits.RotateLeft32.arginfo1
runtime.sighandler -> runtime.testSigtrap
runtime.sighandler -> runtime.testSigusr1
runtime.sighandler -> runtime.doSigPreempt
runtime.sighandler -> runtime.isAbortPC
runtime.sighandler -> runtime.sigsend
runtime.sighandler -> runtime.sig
runtime.sighandler -> runtime.crashing
runtime.sighandler -> runtime.fatalsignal
runtime.sighandler -> runtime.tracebacktrap
runtime.sighandler -> runtime.dumpregs
runtime.sighandler -> go:string."\n-----\n\n"
runtime.sighandler -> runtime.raiseproc
runtime.sighandler -> runtime.(*sigctxt).preparePanic
runtime.sighandler -> runtime.sigprof
runtime.sighandler -> gclocals·zqlmKRL5ToWaDFM4MXGOsg==
runtime.sighandler -> gclocals·AHxkpLoa5Yg6PUYcpzyB4w==
runtime.sighandler -> runtime.sigtrampgo.stkobj
runtime.sighandler -> runtime.sighandler.arginfo1
runtime.sighandler -> fmt.(*fmt).fmtFloat.argliveinfo
runtime.sigprof -> runtime.prof
runtime.sigprof -> runtime._ExternalCode
runtime.sigprof -> runtime._GC
runtime.sigprof -> runtime._System
runtime.sigprof -> runtime.cpuprof
runtime.sigprof -> runtime.(*cpuProfile).add
runtime.sigprof -> runtime.traceCPUSample
runtime.sigprof -> gclocals·asZCz6u+Zjj91l2RTAAAKw==
runtime.sigprof -> runtime.sigprof.argliveinfo
runtime.(*cpuProfile).add -> runtime.(*cpuProfile).addExtra
runtime.(*cpuProfile).add -> runtime.(*profBuf).write
runtime.(*cpuProfile).add -> gclocals·fWLdQmOFX5Z+dYDCTrASBg==
runtime.(*cpuProfile).add -> runtime.(*cpuProfile).add.arginfo1
runtime.(*cpuProfile).addExtra -> runtime._LostExternalCode
runtime.(*cpuProfile).addExtra -> runtime._LostSIGPROFDuringAtomic64
runtime.(*profBuf).write -> runtime.(*profBuf).canWriteTwoRecords
runtime.(*profBuf).write -> runtime.(*profBuf).canWriteRecord
runtime.(*profBuf).write -> runtime.(*profBuf).wakeupExtra
runtime.(*profBuf).write -> go:string."misuse of profBuf.write"
runtime.(*profBuf).write -> gclocals·HowUC1rACIQo3LTc16A2bA==
runtime.(*profBuf).write -> runtime.(*profBuf).write.arginfo1
runtime.(*profBuf).write -> runtime.(*profBuf).write.argliveinfo
runtime.dumpregs -> go:string."rax    "
runtime.dumpregs -> go:string."rbx    "
runtime.dumpregs -> go:string."rcx    "
runtime.dumpregs -> go:string."rdx    "
runtime.dumpregs -> go:string."rdi    "
runtime.dumpregs -> go:string."rsi    "
runtime.dumpregs -> go:string."rbp    "
runtime.dumpregs -> go:string."rsp    "
runtime.dumpregs -> go:string."r8     "
runtime.dumpregs -> go:string."r9     "
runtime.dumpregs -> go:string."r10    "
runtime.dumpregs -> go:string."r11    "
runtime.dumpregs -> go:string."r12    "
runtime.dumpregs -> go:string."r13    "
runtime.dumpregs -> go:string."r14    "
runtime.dumpregs -> go:string."r15    "
runtime.dumpregs -> go:string."rip    "
runtime.dumpregs -> go:string."rflags "
runtime.dumpregs -> go:string."cs     "
runtime.dumpregs -> go:string."fs     "
runtime.dumpregs -> go:string."gs     "
runtime.(*sigctxt).preparePanic -> runtime.shouldPushSigpanic
runtime.(*sigctxt).preparePanic -> runtime.sigpanic0
runtime.(*sigctxt).preparePanic -> fmt.(*ss).scanInt.arginfo1
runtime.doSigPreempt -> runtime.isAsyncSafePoint
runtime.doSigPreempt -> runtime.asyncPreempt
runtime.isAsyncSafePoint -> runtime.asyncPreemptStack
runtime.isAsyncSafePoint -> runtime.pcdatavalue2
runtime.isAsyncSafePoint -> runtime.newInlineUnwinder
runtime.isAsyncSafePoint -> go:string."runtime/internal/"
runtime.isAsyncSafePoint -> go:string."bad restart PC"
runtime.fatalsignal -> go:string."Signal "
runtime.fatalsignal -> go:string."PC="
runtime.fatalsignal -> go:string." sigcode="
runtime.fatalsignal -> go:string."signal arrived during cgo execution\n"
runtime.fatalsignal -> go:string."instruction bytes:"
runtime.fatalsignal -> gclocals·Pq1S1Ye5eYIlobdfI6f62A==
runtime.fatalsignal -> gclocals·2yYNMKF9V38QVhwc9Nvuqw==
runtime.sigsend -> runtime.sigNoteWrite
runtime.sigsend -> go:string."sigsend: inconsistent state"
runtime.makeslicecopy -> runtime.bulkBarrierPreWriteSrcOnly
runtime.makeslicecopy -> type:runtime.errorString <UsedInIface>
runtime.makeslicecopy -> runtime..stmp_149
runtime.makeslicecopy -> gclocals·ZoA9CeNoPCQC1dNiyRBoQw==
runtime.makeslicecopy -> gclocals·mUkuXpRcOAPE4wM9f4U59w==
runtime.makeslicecopy -> sort.rotate_func.argliveinfo
runtime.bulkBarrierPreWriteSrcOnly -> gclocals·E2Oh345k9Q1B+svkfMubog==
runtime.bulkBarrierPreWriteSrcOnly -> gclocals·4nVopPAMYEza9h2wjiR3SQ==
runtime.makeslice -> runtime..stmp_150
runtime.growslice -> runtime..stmp_156
runtime.growslice -> gclocals·x0e4vJQ+iNudJezgY+68nw==
runtime.growslice -> gclocals·/fP+OwaUL92DyfUCmSXx5A==
runtime.stackcache_clear -> runtime.stackpool
runtime.stackcache_clear -> runtime.stackpoolfree
runtime.stackpoolfree -> go:string."freeing stack not in a stack span"
runtime.stackalloc -> go:string."out of memory (stackalloc)"
runtime.stackalloc -> runtime.stackLarge
runtime.stackalloc -> runtime.stackpoolalloc
runtime.stackalloc -> runtime.stackcacherefill
runtime.stackalloc -> go:string."stack size not a power of 2"
runtime.stackalloc -> go:string."stackalloc not on scheduler stack"
runtime.stackpoolalloc -> go:string."span has no free stacks"
runtime.stackpoolalloc -> go:string."bad manualFreeList"
runtime.stackpoolalloc -> go:string."bad allocCount"
runtime.stackfree -> go:string."bad span state"
runtime.stackfree -> runtime.stackcacherelease
runtime.stackfree -> go:string."stack not a power of 2"
runtime.gostartcallfn -> runtime.nilfunc
runtime.shrinkstack -> runtime.copystack
runtime.shrinkstack -> go:string."shrinking stack in libcall"
runtime.shrinkstack -> go:string."shrinkstack at bad time"
runtime.shrinkstack -> go:string."bad status in shrinkstack"
runtime.shrinkstack -> go:string."missing stack in shrinkstack"
runtime.copystack -> runtime.stackPoisonCopy
runtime.copystack -> runtime.adjustctxt
runtime.copystack -> runtime.adjustdefers
runtime.copystack -> runtime.adjustframe
runtime.copystack -> go:string."racy sudog adjustment due to parking on channel"
runtime.copystack -> runtime.syncadjustsudogs
runtime.copystack -> go:string."nil stackbase"
runtime.copystack -> go:string."stack growth not allowed in system call"
runtime.adjustframe -> runtime.adjustpointers
runtime.adjustframe -> gclocals·ObPjcMslu98jFXwAfdYgvA==
runtime.adjustframe -> gclocals·ARpGhnJQ7aEia/Su2mQG7g==
runtime.adjustframe -> io.NopCloser.stkobj
runtime.adjustpointers -> go:string."runtime: bad pointer in frame "
runtime.adjustpointers -> go:string." at "
runtime.adjustpointers -> go:string."invalid pointer found on stack"
runtime.adjustpointers -> gclocals·9EVKLAhwamfOfu3Afcap+Q==
runtime.adjustpointers -> gclocals·o7ffi0tXs0SCrmoCBi7VPA==
runtime.adjustpointers -> reflect.arrayAt.arginfo1
runtime.syncadjustsudogs -> gclocals·oQfeCBBjjns7RmEq2+gD9w==
runtime.syncadjustsudogs -> gclocals·9gc6MeB1oh3mlml/1PtZvg==
runtime.gcComputeStartingStackSize -> runtime.maxstacksize
runtime.(*stkframe).argBytes -> runtime.(*stkframe).argMapInternal
runtime.(*stkframe).argMapInternal -> go:string."reflect.methodValueCall"
runtime.(*stkframe).argMapInternal -> go:string."reflect.makeFuncStub"
runtime.(*stkframe).argMapInternal -> go:string."runtime: confused by "
runtime.(*stkframe).argMapInternal -> go:string."reflect mismatch"
runtime.(*stkframe).argMapInternal -> go:string.": no frame (sp="
runtime.(*stkframe).argMapInternal -> go:string." fp="
runtime.(*stkframe).argMapInternal -> go:string.") at entry+"
runtime.(*stkframe).argMapInternal -> gclocals·sxadaCarlslkZj8nUpv5BA==
runtime.(*stkframe).argMapInternal -> gclocals·v3msp5omBota385OaqV/yA==
runtime.(*stkframe).getStackMap -> runtime.pcdatavalue
runtime.(*stkframe).getStackMap -> runtime.methodValueCallFrameObjs
runtime.(*stkframe).getStackMap -> go:string."runtime: pcdata is "
runtime.(*stkframe).getStackMap -> go:string." and "
runtime.(*stkframe).getStackMap -> go:string." args stack map entries for "
runtime.(*stkframe).getStackMap -> go:string." (targetpc="
runtime.(*stkframe).getStackMap -> go:string."bad symbol table"
runtime.(*stkframe).getStackMap -> go:string."runtime: frame "
runtime.(*stkframe).getStackMap -> go:string." untyped args "
runtime.(*stkframe).getStackMap -> go:string."missing stackmap"
runtime.(*stkframe).getStackMap -> go:string." locals stack map entries for "
runtime.(*stkframe).getStackMap -> go:string." untyped locals "
runtime.(*stkframe).getStackMap -> gclocals·1bbEvutSJOCvs9tRunKGbQ==
runtime.(*stkframe).getStackMap -> gclocals·2lgo6xY1cYpaxTugx9J46w==
runtime.slicebytetostring -> runtime.staticuint64s
runtime.slicebytetostring -> runtime.panicunsafestringlen
runtime.slicebytetostring -> runtime.panicunsafestringnilptr
runtime.(*moduledata).textAddr -> go:string."runtime: textAddr "
runtime.(*moduledata).textAddr -> go:string." out of range "
runtime.(*moduledata).textAddr -> go:string." - "
runtime.(*moduledata).textAddr -> go:string."runtime: text offset out of range"
runtime.(*moduledata).funcName -> runtime.findnull
runtime.(*moduledata).funcName -> syscall.cgocaller.stkobj
runtime.findnull -> internal/bytealg.IndexByteString
runtime.pcdatavalue -> runtime.pcvalue
runtime.pcdatavalue -> runtime.pcdatavalue.arginfo1
runtime.pcvalue -> go:string."runtime: no module data for "
runtime.pcvalue -> go:string."no module data"
runtime.pcvalue -> runtime.step
runtime.pcvalue -> go:string."runtime: invalid pc-encoded table f="
runtime.pcvalue -> go:string." targetpc="
runtime.pcvalue -> go:string." tab="
runtime.pcvalue -> runtime.printslice
runtime.pcvalue -> go:string."\tvalue="
runtime.pcvalue -> go:string." until pc="
runtime.pcvalue -> go:string."invalid runtime symbol table"
runtime.pcvalue -> gclocals·eVNoeLfTKS1q6fwBVmL5cA==
runtime.pcvalue -> runtime.pcvalue.arginfo1
runtime.pcvalue -> runtime.pcvalue.argliveinfo
runtime.printslice -> go:string."]"
runtime.printslice -> runtime.bytesHash.stkobj
runtime.step -> gclocals·K/k0bod1MAmVF3/kRdmjOw==
runtime.step -> runtime.step.arginfo1
runtime.newInlineUnwinder -> runtime.pcdatavalue1
runtime.newInlineUnwinder -> gclocals·wdmTuppZUxZYftR7OCq88Q==
runtime.newInlineUnwinder -> runtime.forEachP.stkobj
runtime.newInlineUnwinder -> fmt.State.Flag.arginfo1
runtime.pthread_attr_init -> runtime.pthread_attr_init_trampoline
runtime.pthread_attr_init -> runtime.libcCall
runtime.pthread_attr_init -> reflect.funcName.stkobj
runtime.pthread_attr_getstacksize -> runtime.pthread_attr_getstacksize_trampoline
runtime.pthread_attr_setdetachstate -> runtime.pthread_attr_setdetachstate_trampoline
runtime.pthread_create -> runtime.pthread_create_trampoline
runtime.raise -> runtime.raise_trampoline
runtime.pthread_kill -> runtime.pthread_kill_trampoline
runtime.mmap -> runtime.mmap_trampoline
runtime.mmap -> gclocals·BRKckR2p+2bw/2huAlWFVQ==
runtime.mmap -> runtime.mmap.stkobj
runtime.mmap -> runtime.mmap.arginfo1
runtime.munmap -> runtime.munmap_trampoline
runtime.madvise -> runtime.madvise_trampoline
runtime.read -> runtime.read_trampoline
runtime.read -> runtime.read.arginfo0
runtime.usleep -> runtime.usleep_trampoline
runtime.usleep_no_g -> runtime.asmcgocall_no_g
runtime.nanotime1 -> runtime.nanotime_trampoline
runtime.sigaction -> runtime.sigaction_trampoline
runtime.sigaction -> gclocals·jGrZsD7lYjdYP8VEa+BSQQ==
runtime.sigaction -> strconv.mult64bitPow10.arginfo1
runtime.sigprocmask -> runtime.sigprocmask_trampoline
runtime.raiseproc -> runtime.raiseproc_trampoline
runtime.kevent -> runtime.kevent_trampoline
runtime.kevent -> gclocals·ascC3ufk2RvZeceVrDASWA==
runtime.kevent -> runtime.kevent.arginfo0
runtime.pthread_mutex_init -> runtime.pthread_mutex_init_trampoline
runtime.pthread_mutex_lock -> runtime.pthread_mutex_lock_trampoline
runtime.pthread_mutex_unlock -> runtime.pthread_mutex_unlock_trampoline
runtime.pthread_cond_init -> runtime.pthread_cond_init_trampoline
runtime.pthread_cond_wait -> runtime.pthread_cond_wait_trampoline
runtime.pthread_cond_timedwait_relative_np -> runtime.pthread_cond_timedwait_relative_np_trampoline
runtime.pthread_cond_signal -> runtime.pthread_cond_signal_trampoline
runtime.libcCall -> gclocals·jZtJ1ccH9bAYoe1wqsw9Mw==
runtime.moveTimers -> runtime.doaddtimer
runtime.moveTimers -> runtime.badTimer
runtime.moveTimers -> runtime.moveTimers.jump13
runtime.doaddtimer -> runtime.netpollGenericInit
runtime.doaddtimer -> type:*runtime.timer
runtime.doaddtimer -> runtime.siftupTimer
runtime.doaddtimer -> go:string."doaddtimer: P already set in timer"
runtime.netpollGenericInit -> runtime.netpollInitLock
runtime.netpollGenericInit -> runtime.netpollinit
runtime.netpollinit -> runtime.kqueue
runtime.netpollinit -> runtime.fcntl
runtime.netpollinit -> runtime.nonblockingPipe
runtime.netpollinit -> go:string."runtime: kevent failed with "
runtime.netpollinit -> go:string."runtime: kevent failed"
runtime.netpollinit -> go:string."runtime: pipe failed with "
runtime.netpollinit -> go:string."runtime: pipe failed"
runtime.netpollinit -> go:string."runtime: kqueue failed with "
runtime.netpollinit -> go:string."runtime: netpollinit failed"
runtime.netpollinit -> gclocals·e2OAQw7RTI8D9/LnocWHCg==
runtime.nonblockingPipe -> runtime.pipe
runtime.nonblockingPipe -> runtime.setNonblock
runtime.pipe -> runtime.pipe_trampoline
runtime.fcntl -> runtime.fcntl_trampoline
runtime.fcntl -> math/bits.Add32.arginfo1
runtime.kqueue -> runtime.kqueue_trampoline
runtime.badTimer -> go:string."timer data corruption"
runtime.write -> runtime.overrideWrite
runtime.write -> runtime.write1
runtime.write1 -> runtime.write_trampoline
runtime.traceCPUSample -> gclocals·vEgytmQ7Fx2/mWWFkHZK7g==
runtime.traceCPUSample -> runtime.traceCPUSample.arginfo1
runtime.traceLocker.Gomaxprocs -> runtime.traceLocker.eventWriter
runtime.traceLocker.Gomaxprocs -> runtime.traceStack
runtime.traceLocker.Gomaxprocs -> runtime.traceEventWriter.commit
runtime.traceLocker.Gomaxprocs -> fmt.FormatString.arginfo1
runtime.traceLocker.eventWriter -> runtime.traceWriter.writeProcStatus
runtime.traceLocker.eventWriter -> runtime.traceWriter.writeGoStatus
runtime.traceLocker.eventWriter -> fmt.newScanState.arginfo1
runtime.traceEventWriter.commit -> runtime.traceWriter.event
runtime.traceEventWriter.commit -> gclocals·WbOP71sd80jWWggvKD8/4A==
runtime.traceEventWriter.commit -> runtime.traceEventWriter.commit.arginfo1
runtime.traceWriter.event -> runtime.traceWriter.ensure
runtime.traceWriter.event -> gclocals·k475OUvhnUnL4EhV3bZnTQ==
runtime.traceWriter.event -> runtime.traceWriter.event.arginfo1
runtime.traceWriter.event -> reflect.Value.Call.argliveinfo
runtime.traceWriter.ensure -> runtime.traceWriter.refill
runtime.traceWriter.ensure -> runtime.traceWriter.ensure.arginfo1
runtime.traceWriter.refill -> runtime.traceWriter.refill.func1
runtime.traceWriter.refill -> runtime.traceWriter.flush.stkobj
runtime.traceWriter.refill -> runtime.errorAddressString.RuntimeError.arginfo1
runtime.traceWriter.refill.func1 -> runtime.traceBufFlush
runtime.traceWriter.refill.func1 -> go:string."trace: out of memory"
runtime.traceBufFlush -> runtime.(*traceBuf).varintAt
runtime.(*traceBuf).varintAt -> go:string."v could not fit in traceBytesPerNumber"
runtime.traceLocker.ProcStop -> gclocals·KZrB1y+lqctuygdernvR/g==
runtime.traceLocker.STWStart -> runtime.stwReasonStrings
runtime.traceLocker.STWStart -> runtime.(*traceStringTable).put
runtime.traceLocker.STWStart -> gclocals·SVDO1fant1cX8pWTIX3vAw==
runtime.traceLocker.STWStart -> strconv.index.arginfo1
runtime.traceLocker.GCSweepStart -> go:string."double traceGCSweepStart"
runtime.traceLocker.GCSweepSpan -> gclocals·PkKdqEyQT0QJW1fsRfeJKg==
runtime.traceLocker.GCSweepDone -> go:string."missing traceGCSweepStart"
runtime.traceLocker.GoCreate -> runtime.traceLocker.startPC
runtime.traceLocker.GoCreate -> gclocals·Cr3/M9g7TVFR6Q8aOwxq/w==
runtime.traceLocker.GoCreate -> sort.insertionSort_func.argliveinfo
runtime.traceLocker.startPC -> runtime.startPCForTrace
runtime.traceLocker.startPC -> runtime.(*traceStackTable).put
runtime.traceLocker.GoStop -> gclocals·tuoT4+9Wx7kzJcLjAMp1xA==
runtime.traceLocker.GoUnpark -> gclocals·OVWEOJ2hiXJz4ZW1vcn6tg==
runtime.traceLocker.ProcSteal -> gclocals·bBhGshdVnp54a1lncqXuMQ==
runtime.traceLocker.ProcSteal -> runtime.funcline1.arginfo1
runtime.traceThreadDestroy -> runtime.traceThreadDestroy.func1
runtime.traceThreadDestroy -> go:string."runtime: seq1="
runtime.traceThreadDestroy -> go:string."bad use of trace.seqlock"
runtime.traceStack -> runtime.getfp
runtime.traceStack -> gclocals·dHp8Husql0+svUGjZaZFhw==
runtime.(*traceStackTable).put -> runtime.(*traceMap).put
runtime.(*traceMap).put -> runtime.memhash
runtime.(*traceMap).put -> runtime.(*traceMap).find
runtime.(*traceMap).put -> runtime.(*traceMap).put.func1
runtime.(*traceMap).put -> runtime.(*traceMap).put.stkobj
runtime.(*traceMap).put.func1 -> runtime.(*traceMap).newTraceMapNode
runtime.(*traceMap).put.func1 -> gclocals·QyAtbWYoT/pbv6J0HiMxVw==
runtime.(*traceMap).newTraceMapNode -> runtime.(*traceRegionAlloc).alloc
runtime.(*traceMap).newTraceMapNode -> runtime.(*traceMap).newTraceMapNode.argliveinfo
runtime.(*traceRegionAlloc).alloc -> go:string."traceRegion: out of memory"
runtime.(*traceRegionAlloc).alloc -> go:string."traceRegion: alloc too large"
runtime.traceWriter.writeGoStatus -> go:string."runtime: goid="
runtime.traceWriter.writeGoStatus -> go:string."attempted to trace a bad status for a goroutine"
runtime.traceWriter.writeGoStatus -> runtime.traceWriter.writeGoStatus.arginfo1
runtime.traceWriter.writeGoStatus -> runtime.traceWriter.writeGoStatus.argliveinfo
runtime.traceWriter.writeProcStatus -> go:string."runtime: pid="
runtime.traceWriter.writeProcStatus -> go:string."attempted to trace a bad status for a proc"
runtime.traceWriter.writeProcStatus -> runtime.traceWriter.writeProcStatus.arginfo1
runtime.traceWriter.writeProcStatus -> runtime.traceWriter.writeProcStatus.argliveinfo
runtime.(*traceStringTable).put -> runtime.(*traceStringTable).put.func1
runtime.(*traceStringTable).put -> runtime.(*traceStringTable).put.stkobj
runtime.(*traceStringTable).put -> reflect.add.arginfo1
runtime.(*traceStringTable).put -> reflect.mapassign_faststr.argliveinfo
runtime.(*traceStringTable).put.func1 -> runtime.(*traceStringTable).writeString
runtime.(*traceStringTable).writeString -> runtime.(*traceStringTable).writeString.argliveinfo
runtime.(*unwinder).initAt -> runtime.duffcopy
runtime.(*unwinder).initAt -> runtime.(*unwinder).resolveInternal
runtime.(*unwinder).initAt -> go:string."runtime: g "
runtime.(*unwinder).initAt -> go:string." gp="
runtime.(*unwinder).initAt -> go:string.": unknown pc "
runtime.(*unwinder).initAt -> runtime.tracebackHexdump
runtime.(*unwinder).initAt -> go:string."unknown pc"
runtime.(*unwinder).initAt -> go:string."cannot trace user goroutine on its own stack"
runtime.(*unwinder).initAt -> gclocals·Q745mLw8CzvAMoTWVbRHJg==
runtime.(*unwinder).initAt -> runtime.selectgo.arginfo1
runtime.(*unwinder).initAt -> fmt.(*pp).printValue.argliveinfo
runtime.(*unwinder).resolveInternal -> runtime.(*unwinder).finishInternal
runtime.(*unwinder).resolveInternal -> go:string."traceback: unexpected SPWRITE function "
runtime.(*unwinder).resolveInternal -> go:string."traceback"
runtime.(*unwinder).resolveInternal -> runtime.(*unwinder).resolveInternal.argliveinfo
runtime.(*unwinder).next -> go:string.": unexpected return pc for "
runtime.(*unwinder).next -> go:string." called from "
runtime.(*unwinder).next -> go:string."unknown caller pc"
runtime.(*unwinder).next -> go:string."runtime: traceback stuck. pc="
runtime.(*unwinder).next -> go:string." sp="
runtime.(*unwinder).next -> go:string."traceback stuck"
runtime.(*unwinder).next -> gclocals·ZOtjrHpLPSywUj5LsoWzXw==
runtime.(*unwinder).finishInternal -> go:string."runtime: g"
runtime.(*unwinder).finishInternal -> go:string.": frame.sp="
runtime.(*unwinder).finishInternal -> go:string." top="
runtime.(*unwinder).finishInternal -> go:string."\tstack=["
runtime.(*unwinder).finishInternal -> go:string."traceback did not unwind completely"
runtime.tracebackPCs -> runtime.(*unwinder).cgoCallers
runtime.tracebackPCs -> runtime.(*unwinder).symPC
runtime.tracebackPCs -> runtime.(*inlineUnwinder).next
runtime.tracebackPCs -> gclocals·aqkXS/ODcKJVRe+HEh3DlQ==
runtime.tracebackPCs -> gclocals·weztxl41G4QdXmAByYVRiA==
runtime.tracebackPCs -> runtime.tracebackPCs.argliveinfo
runtime.(*inlineUnwinder).next -> runtime.(*inlineUnwinder).next.arginfo1
runtime.(*unwinder).cgoCallers -> runtime.cgoTraceback
runtime.(*unwinder).cgoCallers -> runtime.cgoContextPCs
runtime.traceback1 -> runtime.printCgoTraceback
runtime.traceback1 -> runtime.traceback1.func1
runtime.traceback1 -> runtime.printcreatedby
runtime.traceback1 -> runtime.printAncestorTraceback
runtime.traceback1 -> gclocals·Ba8uy9PSPmbZX2QW1FJ73g==
runtime.traceback1 -> gclocals·gaUDsJffFjrnPr8bSHWIPw==
runtime.traceback1 -> runtime.traceback1.stkobj
runtime.traceback1 -> reflect.(*abiSeq).assignIntN.arginfo1
runtime.printcreatedby -> runtime.showframe
runtime.printcreatedby -> runtime.printcreatedby1
runtime.printcreatedby1 -> go:string."created by "
runtime.printcreatedby1 -> runtime.printFuncName
runtime.printcreatedby1 -> go:string." in goroutine "
runtime.printcreatedby1 -> runtime.funcline1
runtime.printcreatedby1 -> go:string.":"
runtime.printcreatedby1 -> go:string." +"
runtime.funcline1 -> runtime.gcbits.3f00000000000000
runtime.funcline1 -> runtime.funcfile
runtime.printFuncName -> go:string."panic"
runtime.printFuncName -> runtime.funcNamePiecesForPrint
runtime.printFuncName -> gclocals·FrUZ3KOpNWLWMINDNZ6Y4w==
runtime.funcNamePiecesForPrint -> go:string."[...]"
runtime.traceback1.func1 -> runtime.traceback2
runtime.traceback1.func1 -> go:string."..."
runtime.traceback1.func1 -> go:string." frames elided...\n"
runtime.traceback2 -> runtime.traceback2.func1
runtime.traceback2 -> runtime.printArgs
runtime.traceback2 -> runtime.cgoSymbolizer
runtime.traceback2 -> go:string."non-Go function at pc="
runtime.traceback2 -> runtime.printOneCgoTraceback
runtime.traceback2 -> runtime.callCgoSymbolizer
runtime.traceback2 -> gclocals·U6FBQZghdIyCNilir7jp2Q==
runtime.traceback2 -> gclocals·hULEvMsftiq1P5GquRKibA==
runtime.traceback2 -> runtime.traceback2.stkobj
runtime.traceback2 -> strconv.FormatFloat.arginfo1
runtime.printArgs -> runtime.printArgs.func1
runtime.printArgs -> runtime.printArgs.func2
runtime.printArgs -> go:string."_"
runtime.printArgs -> go:string."{"
runtime.printArgs -> go:string."}"
runtime.printArgs -> gclocals·XR3pl990RuQudxPnqsn0mQ==
runtime.printArgs -> gclocals·ItW38P+2uMO2Mw5Sx6af+A==
runtime.printArgs -> runtime.printArgs.stkobj
runtime.printArgs.func2 -> runtime.printArgs.func2.arginfo1
runtime.printArgs.func1 -> runtime.makeSpanClass.arginfo1
runtime.printAncestorTraceback -> go:string."[originating from goroutine "
runtime.printAncestorTraceback -> go:string."]:\n"
runtime.printAncestorTraceback -> runtime.showfuncinfo
runtime.printAncestorTraceback -> runtime.printAncestorTracebackFuncInfo
runtime.printAncestorTraceback -> go:string."...additional frames elided...\n"
runtime.printAncestorTraceback -> runtime.printAncestorTraceback.arginfo1
runtime.printAncestorTracebackFuncInfo -> go:string."(...)\n"
runtime.printAncestorTracebackFuncInfo -> gclocals·R3JnmNczqwDi91YeSSzuEg==
runtime.printAncestorTracebackFuncInfo -> io/fs.ReadFile.stkobj
runtime.callers -> runtime.callers.func1
runtime.callers -> gclocals·SoG6d3SEFU105ym5LEtOUA==
runtime.callers -> runtime.callers.stkobj
runtime.showframe -> runtime.showframe.arginfo1
runtime.showfuncinfo -> runtime.showfuncinfo.arginfo1
runtime.showfuncinfo -> runtime.writeUserArenaHeapBits.pad.argliveinfo
runtime.goroutineheader -> runtime.gStatusStrings
runtime.goroutineheader -> go:string."???"
runtime.goroutineheader -> go:string."unknown wait reason"
runtime.goroutineheader -> runtime.waitReasonStrings
runtime.goroutineheader -> go:string."goroutine "
runtime.goroutineheader -> go:string." mp="
runtime.goroutineheader -> go:string." m=nil"
runtime.goroutineheader -> go:string." (scan)"
runtime.goroutineheader -> go:string." minutes"
runtime.goroutineheader -> go:string.", locked to thread"
runtime.goroutineheader -> gclocals·k1WmXHXjhdN9EEzP4xvAhQ==
runtime.tracebackothers -> runtime.tracebackothers.func1
runtime.tracebackothers -> gclocals·FzOviaiNvskOOLPK/yRhOA==
runtime.tracebackothers.func1 -> go:string."\tgoroutine running on other thread; stack unavailable\n"
runtime.tracebackHexdump -> go:string."stack: frame={sp:"
runtime.tracebackHexdump -> go:string.", fp:"
runtime.tracebackHexdump -> go:string."} stack=["
runtime.tracebackHexdump -> runtime.tracebackHexdump.func1
runtime.printCgoTraceback -> runtime.printCgoTraceback.func1·f
runtime.printCgoTraceback -> gclocals·D5ZMXVuQMb80y0tMU+yRLQ==
runtime.printCgoTraceback -> runtime.printCgoTraceback.stkobj
runtime.printOneCgoTraceback -> go:string."non-Go function\n"
runtime.printOneCgoTraceback -> go:string."pc="
runtime.printOneCgoTraceback -> gclocals·bJ9n6rIzqGpU1z9xCWqf2w==
runtime.printOneCgoTraceback -> gclocals·eUyidXc17r06VJ5e5+pVSg==
runtime.printOneCgoTraceback -> runtime.printOneCgoTraceback.stkobj
runtime.callCgoSymbolizer -> runtime.asmcgocall·f
runtime.callCgoSymbolizer -> runtime.cgocall·f
runtime.cgoContextPCs -> runtime/pprof.proc_regionfilename.stkobj
runtime.rtype.string -> os.File.close.arginfo1
runtime.resolveNameOff -> runtime.reflectOffs
runtime.resolveNameOff -> type:map[int32]unsafe.Pointer
runtime.resolveNameOff -> runtime.mapaccess2_fast32
runtime.resolveNameOff -> go:string."runtime: nameOff "
runtime.resolveNameOff -> go:string." base "
runtime.resolveNameOff -> go:string." not in ranges:\n"
runtime.resolveNameOff -> go:string."\ttypes "
runtime.resolveNameOff -> go:string." etypes "
runtime.resolveNameOff -> go:string."runtime: name offset base pointer out of range"
runtime.resolveNameOff -> go:string."runtime: name offset out of range"
runtime.mapaccess2_fast32 -> go:string."concurrent map read and map write"
runtime.mapaccess2_fast32 -> runtime.mapaccess1_fast32.argliveinfo
runtime.resolveTypeOff -> type:map[internal/abi.TypeOff]*internal/abi.Type
runtime.resolveTypeOff -> runtime.mapaccess1_fast32
runtime.resolveTypeOff -> go:string."runtime: typeOff "
runtime.resolveTypeOff -> go:string."runtime: type offset base pointer out of range"
runtime.resolveTypeOff -> go:string."runtime: type offset out of range"
runtime.rtype.textOff -> go:string."runtime: textOff "
runtime.rtype.textOff -> go:string."runtime: text offset base pointer out of range"
runtime.rtype.textOff -> internal/reflectlite.rtype.nameOff.arginfo1
runtime.panicunsafestringlen -> runtime..stmp_177
runtime.panicunsafestringnilptr -> runtime..stmp_178
runtime.panicunsafeslicelen -> runtime.panicunsafeslicelen1
runtime.panicunsafeslicelen1 -> go:string."unsafe.Slice: len out of range"
runtime.panicunsafeslicelen1 -> runtime..stmp_190
runtime.preprintpanics.func1 -> runtime.gorecover
runtime.preprintpanics.func1 -> go:string."panic while printing panic value"
runtime.preprintpanics.func1 -> runtime.concatstring3
runtime.preprintpanics.func1 -> go:string.": type "
runtime.concatstring3 -> runtime.concatstrings
runtime.concatstring3 -> gclocals·iV5eOcg9C3V98k9xZsw9lA==
runtime.concatstring3 -> runtime.concatstring3.stkobj
runtime.concatstring3 -> sync.(*Map).CompareAndSwap.arginfo1
runtime.concatstrings -> runtime.rawstringtmp
runtime.concatstrings -> go:string."string concatenation too long"
runtime.concatstrings -> gclocals·FLuj5vxpzjAkyiXpJQcesg==
type:string <UsedInIface> -> runtime.strequal·f
type:string <UsedInIface> -> runtime.gcbits.0100000000000000
type:string <UsedInIface> -> type:.namedata.*string-
type:string <UsedInIface> -> type:*string <UsedInIface>
type:*string <UsedInIface> -> runtime.memequal64·f
type:runtime.errorString <UsedInIface> -> type:.namedata.*runtime.errorString-
type:runtime.errorString <UsedInIface> -> type:*runtime.errorString <UsedInIface>
type:runtime.errorString <UsedInIface> -> type:.importpath.runtime.
type:runtime.errorString <UsedInIface> -> type:.namedata.Error.
type:runtime.errorString <UsedInIface> -> type:.namedata.RuntimeError.
type:runtime.errorString <UsedInIface> -> type:func() <UsedInIface>
type:int8 -> runtime.memequal8·f
type:int8 -> reflect..stmp_1
type:int8 -> type:.namedata.*int8-
type:int8 -> type:*int8
type:uint8 -> type:.namedata.*uint8-
type:uint8 -> type:*uint8
type:int16 -> runtime.memequal16·f
type:int16 -> type:.namedata.*int16-
type:int16 -> type:*int16
type:uint16 -> type:.namedata.*uint16-
type:uint16 -> type:*uint16
type:int32 -> runtime.memequal32·f
type:int32 -> type:.namedata.*int32-
type:int32 -> type:*int32
type:uint32 -> type:.namedata.*uint32-
type:uint32 -> type:*uint32
type:int64 -> type:.namedata.*int64-
type:int64 -> type:*int64
type:uint64 -> type:.namedata.*uint64-
type:uint64 -> type:*uint64
type:int -> type:.namedata.*int-
type:int -> type:*int
type:uint -> type:.namedata.*uint-
type:uint -> type:*uint
type:uintptr -> type:.namedata.*uintptr-
type:uintptr -> type:*uintptr <UsedInIface>
type:*uintptr <UsedInIface> -> type:uintptr <UsedInIface>
type:complex64 -> runtime.c64equal·f
type:complex64 -> type:.namedata.*complex64-
type:complex64 -> type:*complex64
type:complex128 -> runtime.c128equal·f
type:complex128 -> type:.namedata.*complex128-
type:complex128 -> type:*complex128
type:float32 -> runtime.f32equal·f
type:float32 -> type:.namedata.*float32-
type:float32 -> type:*float32
type:float64 -> runtime.f64equal·f
type:float64 -> type:.namedata.*float64-
type:float64 -> type:*float64
type:bool -> type:.namedata.*bool-
type:bool -> type:*bool
type:*runtime.PanicNilError <UsedInIface> -> type:.namedata.*runtime.PanicNilError.
type:*runtime.PanicNilError <UsedInIface> -> type:runtime.PanicNilError <UsedInIface>
type:runtime.PanicNilError <UsedInIface> -> type:.eqfunc.runtime.PanicNilError
type:runtime.PanicNilError <UsedInIface> -> type:.namedata._-
type:runtime.PanicNilError <UsedInIface> -> type:[0]*runtime.PanicNilError <UsedInIface>
type:*runtime._defer -> type:.namedata.*runtime._defer-
type:runtime._defer -> runtime.gcbits.3800000000000000
type:runtime._defer -> type:.namedata.heap-
type:runtime._defer -> type:.namedata.rangefunc-
type:runtime._defer -> type:.namedata.sp-
type:runtime._defer -> type:.namedata.pc-
type:runtime._defer -> type:.namedata.fn-
type:runtime._defer -> type:.namedata.link-
type:runtime._defer -> type:.namedata.head-
type:runtime._defer -> type:*runtime/internal/atomic.Pointer[runtime._defer]
type:runtime.ancestorInfo -> type:.namedata.*runtime.ancestorInfo-
type:runtime.ancestorInfo -> type:*runtime.ancestorInfo
type:runtime.ancestorInfo -> type:.namedata.pcs-
type:runtime.ancestorInfo -> type:[]uintptr
type:runtime.ancestorInfo -> type:.namedata.goid-
type:runtime.ancestorInfo -> type:.namedata.gopc-
type:runtime.cgoCallers -> type:.eqfunc256
type:runtime.cgoCallers -> type:.namedata.*runtime.cgoCallers-
type:runtime.cgoCallers -> type:*runtime.cgoCallers
type:runtime.sudog -> type:.eqfunc88
type:runtime.sudog -> runtime.gcbits.8f07000000000000
type:runtime.sudog -> type:.namedata.*runtime.sudog-
type:runtime.sudog -> type:.namedata.g-
type:runtime.sudog -> type:.namedata.next-
type:runtime.sudog -> type:.namedata.prev-
type:runtime.sudog -> type:.namedata.elem-
type:runtime.sudog -> type:unsafe.Pointer <UsedInIface>
type:runtime.sudog -> type:.namedata.acquiretime-
type:runtime.sudog -> type:.namedata.releasetime-
type:runtime.sudog -> type:.namedata.ticket-
type:runtime.sudog -> type:.namedata.isSelect-
type:runtime.sudog -> type:.namedata.success-
type:runtime.sudog -> type:.namedata.waiters-
type:runtime.sudog -> type:.namedata.parent-
type:runtime.sudog -> type:.namedata.waitlink-
type:runtime.sudog -> type:.namedata.waittail-
type:runtime.sudog -> type:.namedata.c-
type:runtime.sudog -> type:*runtime.hchan
type:unsafe.Pointer <UsedInIface> -> type:.namedata.*unsafe.Pointer.
type:unsafe.Pointer <UsedInIface> -> type:*unsafe.Pointer <UsedInIface>
type:unsafe.Pointer <UsedInIface> -> type:.importpath.unsafe.
type:*runtime.hchan -> type:.namedata.*runtime.hchan-
type:*runtime.hchan -> type:runtime.hchan
type:*runtime.hchan -> type:.namedata.raceaddr-
type:*runtime.hchan -> type:.namedata.sortkey-
type:runtime.hchan -> type:.eqfunc.runtime.hchan
type:runtime.hchan -> runtime.gcbits.9407000000000000
type:runtime.hchan -> type:.namedata.qcount-
type:runtime.hchan -> type:.namedata.dataqsiz-
type:runtime.hchan -> type:.namedata.buf-
type:runtime.hchan -> type:.namedata.elemsize-
type:runtime.hchan -> type:.namedata.closed-
type:runtime.hchan -> type:.namedata.elemtype-
type:runtime.hchan -> type:*internal/abi.Type
type:runtime.hchan -> type:.namedata.sendx-
type:runtime.hchan -> type:.namedata.recvx-
type:runtime.hchan -> type:.namedata.recvq-
type:runtime.hchan -> type:runtime.waitq
type:runtime.hchan -> type:.namedata.sendq-
type:runtime.hchan -> type:.namedata.lock-
type:runtime.hchan -> type:runtime.mutex
type:runtime.mutex -> type:.namedata.*runtime.mutex-
type:runtime.mutex -> type:*runtime.mutex
type:runtime.mutex -> type:.namedata.lockRankStruct-.embedded
type:runtime.mutex -> type:runtime.lockRankStruct
type:runtime.mutex -> type:.namedata.key-
type:runtime.lockRankStruct -> runtime.memequal0·f
type:runtime.lockRankStruct -> type:.namedata.*runtime.lockRankStruct-
type:runtime.lockRankStruct -> type:*runtime.lockRankStruct
type:runtime.waitq -> runtime.memequal128·f
type:runtime.waitq -> runtime.gcbits.0300000000000000
type:runtime.waitq -> type:.namedata.*runtime.waitq-
type:runtime.waitq -> type:*runtime.waitq
type:runtime.waitq -> type:.namedata.first-
type:runtime.waitq -> type:.namedata.last-
type:*runtime.waitq -> type:.namedata.dequeue-
type:*runtime.waitq -> type:.namedata.dequeueSudoG-
type:*runtime.waitq -> type:.namedata.enqueue-
type:*runtime.timer -> type:.namedata.*runtime.timer-
type:*runtime.timer -> type:runtime.timer
type:runtime.timer -> type:.namedata.pp-
type:runtime.timer -> type:runtime.puintptr
type:runtime.timer -> type:.namedata.when-
type:runtime.timer -> type:.namedata.period-
type:runtime.timer -> type:.namedata.f-
type:runtime.timer -> type:func(interface {}, uintptr)
type:runtime.timer -> type:.namedata.arg-
type:runtime.timer -> type:interface {}
type:runtime.timer -> type:.namedata.seq-
type:runtime.timer -> type:.namedata.nextwhen-
type:runtime.timer -> type:.namedata.status-
type:runtime.timer -> type:runtime/internal/atomic.Uint32
type:runtime.p -> runtime.gcbits.0020ffffffff000000000000000000000000000000000000000000000000000000000000000040feffffffffffffffffffffffffffffff0100000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000
type:runtime.p -> type:.namedata.*runtime.p-
type:runtime.p -> type:.namedata.id-
type:runtime.p -> type:.namedata.schedtick-
type:runtime.p -> type:.namedata.syscalltick-
type:runtime.p -> type:.namedata.sysmontick-
type:runtime.p -> type:runtime.sysmontick
type:runtime.p -> type:.namedata.m-
type:runtime.p -> type:runtime.muintptr
type:runtime.p -> type:.namedata.mcache-
type:runtime.p -> type:*runtime.mcache
type:runtime.p -> type:.namedata.pcache-
type:runtime.p -> type:runtime.pageCache
type:runtime.p -> type:.namedata.raceprocctx-
type:runtime.p -> type:.namedata.deferpool-
type:runtime.p -> type:[]*runtime._defer
type:runtime.p -> type:.namedata.deferpoolbuf-
type:runtime.p -> type:[32]*runtime._defer
type:runtime.p -> type:.namedata.goidcache-
type:runtime.p -> type:.namedata.goidcacheend-
type:runtime.p -> type:.namedata.runqhead-
type:runtime.p -> type:.namedata.runqtail-
type:runtime.p -> type:.namedata.runq-
type:runtime.p -> type:[256]runtime.guintptr
type:runtime.p -> type:.namedata.runnext-
type:runtime.p -> type:runtime.guintptr
type:runtime.p -> type:.namedata.gFree-
type:runtime.p -> type:struct { runtime.gList; runtime.n int32 }
type:runtime.p -> type:.namedata.sudogcache-
type:runtime.p -> type:[]*runtime.sudog
type:runtime.p -> type:.namedata.sudogbuf-
type:runtime.p -> type:[128]*runtime.sudog
type:runtime.p -> type:.namedata.mspancache-
type:runtime.p -> type:struct { runtime.len int; runtime.buf [128]*runtime.mspan }
type:runtime.p -> type:.namedata.pinnerCache-
type:runtime.p -> type:*runtime.pinner
type:runtime.p -> type:.namedata.trace-
type:runtime.p -> type:runtime.pTraceState
type:runtime.p -> type:.namedata.palloc-
type:runtime.p -> type:runtime.persistentAlloc
type:runtime.p -> type:.namedata.timer0When-
type:runtime.p -> type:runtime/internal/atomic.Int64
type:runtime.p -> type:.namedata.timerModifiedEarliest-
type:runtime.p -> type:.namedata.gcAssistTime-
type:runtime.p -> type:.namedata.gcFractionalMarkTime-
type:runtime.p -> type:.namedata.limiterEvent-
type:runtime.p -> type:runtime.limiterEvent
type:runtime.p -> type:.namedata.gcMarkWorkerMode-
type:runtime.p -> type:runtime.gcMarkWorkerMode
type:runtime.p -> type:.namedata.gcMarkWorkerStartTime-
type:runtime.p -> type:.namedata.gcw-
type:runtime.p -> type:runtime.gcWork
type:runtime.p -> type:.namedata.wbBuf-
type:runtime.p -> type:runtime.wbBuf
type:runtime.p -> type:.namedata.runSafePointFn-
type:runtime.p -> type:.namedata.statsSeq-
type:runtime.p -> type:.namedata.timersLock-
type:runtime.p -> type:.namedata.timers-
type:runtime.p -> type:[]*runtime.timer
type:runtime.p -> type:.namedata.numTimers-
type:runtime.p -> type:.namedata.deletedTimers-
type:runtime.p -> type:.namedata.timerRaceCtx-
type:runtime.p -> type:.namedata.maxStackScanDelta-
type:runtime.p -> type:.namedata.scannedStackSize-
type:runtime.p -> type:.namedata.scannedStacks-
type:runtime.p -> type:.namedata.preempt-
type:runtime.p -> type:.namedata.pageTraceBuf-
type:runtime.p -> type:runtime.pageTraceBuf
type:runtime.sysmontick -> type:.eqfunc.runtime.sysmontick
type:runtime.sysmontick -> type:.namedata.*runtime.sysmontick-
type:runtime.sysmontick -> type:*runtime.sysmontick
type:runtime.sysmontick -> type:.namedata.schedwhen-
type:runtime.sysmontick -> type:.namedata.syscallwhen-
type:runtime.muintptr -> type:.namedata.*runtime.muintptr-
type:runtime.muintptr -> type:*runtime.muintptr
type:runtime.muintptr -> type:.namedata.ptr-
type:*runtime.muintptr -> type:.namedata.set-
type:*runtime.mcache -> type:.namedata.*runtime.mcache-
type:*runtime.mcache -> type:runtime.mcache
type:*runtime.mcache -> type:.namedata.allocLarge-
type:*runtime.mcache -> type:.namedata.nextFree-
type:*runtime.mcache -> type:.namedata.prepareForSweep-
type:*runtime.mcache -> type:.namedata.refill-
type:*runtime.mcache -> type:.namedata.releaseAll-
type:runtime.mcache -> type:.eqfunc.runtime.mcache
type:runtime.mcache -> type:runtime/internal/sys.NotInHeap
type:runtime.mcache -> type:.namedata.nextSample-
type:runtime.mcache -> type:.namedata.scanAlloc-
type:runtime.mcache -> type:.namedata.tiny-
type:runtime.mcache -> type:.namedata.tinyoffset-
type:runtime.mcache -> type:.namedata.tinyAllocs-
type:runtime.mcache -> type:.namedata.alloc-
type:runtime.mcache -> type:[136]*runtime.mspan
type:runtime.mcache -> type:.namedata.stackcache-
type:runtime.mcache -> type:[4]runtime.stackfreelist
type:runtime.mcache -> type:.namedata.flushGen-
type:runtime.pageCache -> type:.eqfunc24
type:runtime.pageCache -> type:.namedata.*runtime.pageCache-
type:runtime.pageCache -> type:*runtime.pageCache
type:runtime.pageCache -> type:.namedata.base-
type:runtime.pageCache -> type:.namedata.cache-
type:runtime.pageCache -> type:.namedata.scav-
type:*runtime.pageCache -> type:.namedata.allocN-
type:*runtime.pageCache -> type:.namedata.empty-
type:*runtime.pageCache -> type:.namedata.flush-
type:*runtime.pinner -> type:.namedata.*runtime.pinner-
type:*runtime.pinner -> type:runtime.pinner
type:*runtime.pinner -> type:.namedata.unpin-
type:runtime.pinner -> runtime.gcbits.f900000000000000
type:runtime.pinner -> type:.namedata.refs-
type:runtime.pinner -> type:[]unsafe.Pointer
type:runtime.pinner -> type:.namedata.refStore-
type:runtime.pinner -> type:[5]unsafe.Pointer
type:runtime.pTraceState -> type:.eqfunc.runtime.pTraceState
type:runtime.pTraceState -> type:.namedata.*runtime.pTraceState-
type:runtime.pTraceState -> type:*runtime.pTraceState
type:runtime.pTraceState -> type:.namedata.traceSchedResourceState-.embedded
type:runtime.pTraceState -> type:runtime.traceSchedResourceState
type:runtime.pTraceState -> type:.namedata.mSyscallID-
type:runtime.pTraceState -> type:.namedata.maySweep-
type:runtime.pTraceState -> type:.namedata.inSweep-
type:runtime.pTraceState -> type:.namedata.swept-
type:runtime.pTraceState -> type:.namedata.reclaimed-
type:*runtime.pTraceState -> type:.namedata.acquireStatus-
type:*runtime.pTraceState -> type:.namedata.nextSeq-
type:*runtime.pTraceState -> type:.namedata.readyNextGen-
type:*runtime.pTraceState -> type:.namedata.setStatusTraced-
type:*runtime.pTraceState -> type:.namedata.statusWasTraced-
type:runtime.traceSchedResourceState -> type:.eqfunc.runtime.traceSchedResourceState
type:runtime.traceSchedResourceState -> type:.namedata.*runtime.traceSchedResourceState-
type:runtime.traceSchedResourceState -> type:*runtime.traceSchedResourceState
type:runtime.traceSchedResourceState -> type:.namedata.statusTraced-
type:runtime.traceSchedResourceState -> type:[3]runtime/internal/atomic.Uint32
type:runtime.traceSchedResourceState -> type:[2]uint64
type:runtime.persistentAlloc -> type:.namedata.*runtime.persistentAlloc-
type:runtime.persistentAlloc -> type:*runtime.persistentAlloc
type:runtime.persistentAlloc -> type:*runtime.notInHeap
type:runtime.persistentAlloc -> type:.namedata.off-
type:*runtime.notInHeap -> type:.namedata.*runtime.notInHeap-
type:*runtime.notInHeap -> type:runtime.notInHeap
type:*runtime.notInHeap -> type:.namedata.add-
type:runtime.notInHeap -> type:.eqfunc.runtime.notInHeap
type:runtime.limiterEvent -> type:.eqfunc.runtime.limiterEvent
type:runtime.limiterEvent -> type:.namedata.*runtime.limiterEvent-
type:runtime.limiterEvent -> type:*runtime.limiterEvent
type:runtime.limiterEvent -> type:.namedata.stamp-
type:runtime.limiterEvent -> type:runtime/internal/atomic.Uint64
type:*runtime.limiterEvent -> type:.namedata.consume-
type:*runtime.limiterEvent -> type:.namedata.start-
type:*runtime.limiterEvent -> type:.namedata.stop-
type:runtime.gcMarkWorkerMode -> type:.namedata.*runtime.gcMarkWorkerMode-
type:runtime.gcMarkWorkerMode -> type:*runtime.gcMarkWorkerMode
type:runtime.gcWork -> type:.eqfunc.runtime.gcWork
type:runtime.gcWork -> type:.namedata.*runtime.gcWork-
type:runtime.gcWork -> type:*runtime.gcWork
type:runtime.gcWork -> type:.namedata.wbuf1-
type:runtime.gcWork -> type:*runtime.workbuf
type:runtime.gcWork -> type:.namedata.wbuf2-
type:runtime.gcWork -> type:.namedata.bytesMarked-
type:runtime.gcWork -> type:.namedata.heapScanWork-
type:runtime.gcWork -> type:.namedata.flushedWork-
type:*runtime.gcWork -> type:.namedata.balance-
type:*runtime.gcWork -> type:.namedata.dispose-
type:*runtime.gcWork -> type:.namedata.init-
type:*runtime.gcWork -> type:.namedata.put-
type:*runtime.gcWork -> type:.namedata.putBatch-
type:*runtime.gcWork -> type:.namedata.putFast-
type:*runtime.gcWork -> type:.namedata.tryGet-
type:*runtime.gcWork -> type:.namedata.tryGetFast-
type:*runtime.workbuf -> type:.namedata.*runtime.workbuf-
type:*runtime.workbuf -> type:runtime.workbuf
type:*runtime.workbuf -> type:.namedata.checkempty-
type:*runtime.workbuf -> type:.namedata.checknonempty-
type:runtime.workbuf -> type:.eqfunc.runtime.workbuf
type:runtime.workbuf -> type:.namedata.workbufhdr-.embedded
type:runtime.workbuf -> type:runtime.workbufhdr
type:runtime.workbuf -> type:.namedata.obj-
type:runtime.workbuf -> type:[253]uintptr
type:runtime.workbufhdr -> type:.namedata.*runtime.workbufhdr-
type:runtime.workbufhdr -> type:*runtime.workbufhdr
type:runtime.workbufhdr -> type:.namedata.node-
type:runtime.workbufhdr -> type:runtime.lfnode
type:runtime.workbufhdr -> type:.namedata.nobj-
type:runtime.lfnode -> type:.namedata.*runtime.lfnode-
type:runtime.lfnode -> type:*runtime.lfnode
type:runtime.lfnode -> type:.namedata.pushcnt-
type:runtime.wbBuf -> type:.eqfunc4112
type:runtime.wbBuf -> type:.namedata.*runtime.wbBuf-
type:runtime.wbBuf -> type:*runtime.wbBuf
type:runtime.wbBuf -> type:.namedata.end-
type:runtime.wbBuf -> type:[512]uintptr
type:*runtime.wbBuf -> type:.namedata.discard-
type:*runtime.wbBuf -> type:.namedata.get1-
type:*runtime.wbBuf -> type:.namedata.get2-
type:*runtime.wbBuf -> type:.namedata.reset-
type:runtime.pageTraceBuf -> type:.namedata.*runtime.pageTraceBuf-
type:runtime.pageTraceBuf -> type:*runtime.pageTraceBuf
type:*runtime.p -> type:.namedata.destroy-
type:runtime.puintptr -> type:.namedata.*runtime.puintptr-
type:runtime.puintptr -> type:*runtime.puintptr
type:runtime.m -> runtime.gcbits.11048081800200000000000000001811
type:runtime.m -> type:.namedata.*runtime.m-
type:runtime.m -> type:*runtime.m
type:runtime.m -> type:.namedata.g0-
type:runtime.m -> type:.namedata.morebuf-
type:runtime.m -> type:runtime.gobuf
type:runtime.m -> type:.namedata.divmod-
type:runtime.m -> type:.namedata.procid-
type:runtime.m -> type:.namedata.gsignal-
type:runtime.m -> type:.namedata.goSigStack-
type:runtime.m -> type:runtime.gsignalStack
type:runtime.m -> type:.namedata.sigmask-
type:runtime.m -> type:runtime.sigset
type:runtime.m -> type:.namedata.tls-
type:runtime.m -> type:[6]uintptr
type:runtime.m -> type:.namedata.mstartfn-
type:runtime.m -> type:.namedata.curg-
type:runtime.m -> type:.namedata.caughtsig-
type:runtime.m -> type:.namedata.p-
type:runtime.m -> type:.namedata.nextp-
type:runtime.m -> type:.namedata.oldp-
type:runtime.m -> type:.namedata.mallocing-
type:runtime.m -> type:.namedata.throwing-
type:runtime.m -> type:runtime.throwType
type:runtime.m -> type:.namedata.preemptoff-
type:runtime.m -> type:.namedata.locks-
type:runtime.m -> type:.namedata.dying-
type:runtime.m -> type:.namedata.profilehz-
type:runtime.m -> type:.namedata.spinning-
type:runtime.m -> type:.namedata.blocked-
type:runtime.m -> type:.namedata.newSigstack-
type:runtime.m -> type:.namedata.printlock-
type:runtime.m -> type:.namedata.incgo-
type:runtime.m -> type:.namedata.isextra-
type:runtime.m -> type:.namedata.isExtraInC-
type:runtime.m -> type:.namedata.isExtraInSig-
type:runtime.m -> type:.namedata.freeWait-
type:runtime.m -> type:.namedata.needextram-
type:runtime.m -> type:.namedata.traceback-
type:runtime.m -> type:.namedata.ncgocall-
type:runtime.m -> type:.namedata.ncgo-
type:runtime.m -> type:.namedata.cgoCallersUse-
type:runtime.m -> type:.namedata.cgoCallers-
type:runtime.m -> type:.namedata.park-
type:runtime.m -> type:runtime.note
type:runtime.m -> type:.namedata.alllink-
type:runtime.m -> type:.namedata.schedlink-
type:runtime.m -> type:.namedata.lockedg-
type:runtime.m -> type:.namedata.createstack-
type:runtime.m -> type:[32]uintptr
type:runtime.m -> type:.namedata.lockedExt-
type:runtime.m -> type:.namedata.lockedInt-
type:runtime.m -> type:.namedata.nextwaitm-
type:runtime.m -> type:.namedata.mLockProfile-
type:runtime.m -> type:runtime.mLockProfile
type:runtime.m -> type:.namedata.waitunlockf-
type:runtime.m -> type:func(*runtime.g, unsafe.Pointer) bool
type:runtime.m -> type:.namedata.waitlock-
type:runtime.m -> type:.namedata.waitTraceBlockReason-
type:runtime.m -> type:runtime.traceBlockReason
type:runtime.m -> type:.namedata.waitTraceSkip-
type:runtime.m -> type:.namedata.freelink-
type:runtime.m -> type:runtime.mTraceState
type:runtime.m -> type:.namedata.libcall-
type:runtime.m -> type:runtime.libcall
type:runtime.m -> type:.namedata.libcallpc-
type:runtime.m -> type:.namedata.libcallsp-
type:runtime.m -> type:.namedata.libcallg-
type:runtime.m -> type:.namedata.syscall-
type:runtime.m -> type:.namedata.vdsoSP-
type:runtime.m -> type:.namedata.vdsoPC-
type:runtime.m -> type:.namedata.preemptGen-
type:runtime.m -> type:.namedata.signalPending-
type:runtime.m -> type:.namedata.pcvalueCache-
type:runtime.m -> type:runtime.pcvalueCache
type:runtime.m -> type:.namedata.dlogPerM-.embedded
type:runtime.m -> type:runtime.dlogPerM
type:runtime.m -> type:.namedata.mOS-.embedded
type:runtime.m -> type:runtime.mOS
type:runtime.m -> type:.namedata.chacha8-
type:runtime.m -> type:internal/chacha8rand.State
type:runtime.m -> type:.namedata.cheaprand-
type:runtime.m -> type:.namedata.locksHeldLen-
type:runtime.m -> type:.namedata.locksHeld-
type:runtime.m -> type:[10]runtime.heldLockInfo
type:runtime.gobuf -> type:.eqfunc56
type:runtime.gobuf -> runtime.gcbits.0800000000000000
type:runtime.gobuf -> type:.namedata.*runtime.gobuf-
type:runtime.gobuf -> type:*runtime.gobuf
type:runtime.gobuf -> type:.namedata.ctxt-
type:runtime.gobuf -> type:.namedata.ret-
type:runtime.gobuf -> type:.namedata.lr-
type:runtime.gobuf -> type:.namedata.bp-
type:runtime.gsignalStack -> type:.eqfunc40
type:runtime.gsignalStack -> type:.namedata.*runtime.gsignalStack-
type:runtime.gsignalStack -> type:*runtime.gsignalStack
type:runtime.gsignalStack -> type:.namedata.stack-
type:runtime.gsignalStack -> type:runtime.stack
type:runtime.gsignalStack -> type:.namedata.stackguard0-
type:runtime.gsignalStack -> type:.namedata.stackguard1-
type:runtime.gsignalStack -> type:.namedata.stktopsp-
type:runtime.stack -> type:.namedata.*runtime.stack-
type:runtime.stack -> type:*runtime.stack
type:runtime.stack -> type:.namedata.lo-
type:runtime.stack -> type:.namedata.hi-
type:runtime.sigset -> type:.namedata.*runtime.sigset-
type:runtime.sigset -> type:*runtime.sigset <UsedInIface>
type:*runtime.sigset <UsedInIface> -> type:runtime.sigset <UsedInIface>
type:runtime.throwType -> type:.namedata.*runtime.throwType-
type:runtime.throwType -> type:*runtime.throwType
type:runtime.note -> type:.namedata.*runtime.note-
type:runtime.note -> type:*runtime.note
type:runtime.mLockProfile -> type:.eqfunc.runtime.mLockProfile
type:runtime.mLockProfile -> type:.namedata.*runtime.mLockProfile-
type:runtime.mLockProfile -> type:*runtime.mLockProfile
type:runtime.mLockProfile -> type:.namedata.waitTime-
type:runtime.mLockProfile -> type:.namedata.pending-
type:runtime.mLockProfile -> type:.namedata.cycles-
type:runtime.mLockProfile -> type:.namedata.cyclesLost-
type:runtime.mLockProfile -> type:.namedata.disabled-
type:*runtime.mLockProfile -> type:.namedata.captureStack-
type:*runtime.mLockProfile -> type:.namedata.recordLock-
type:*runtime.mLockProfile -> type:.namedata.recordUnlock-
type:*runtime.mLockProfile -> type:.namedata.store-
type:runtime.traceBlockReason -> type:.namedata.*runtime.traceBlockReason-
type:runtime.traceBlockReason -> type:*runtime.traceBlockReason
type:runtime.mTraceState -> type:.eqfunc32
type:runtime.mTraceState -> type:.namedata.*runtime.mTraceState-
type:runtime.mTraceState -> type:*runtime.mTraceState
type:runtime.mTraceState -> type:.namedata.seqlock-
type:runtime.mTraceState -> type:runtime/internal/atomic.Uintptr
type:runtime.mTraceState -> type:[2]*runtime.traceBuf
type:runtime.libcall -> type:.eqfunc48
type:runtime.libcall -> type:.namedata.*runtime.libcall-
type:runtime.libcall -> type:*runtime.libcall
type:runtime.libcall -> type:.namedata.n-
type:runtime.libcall -> type:.namedata.args-
type:runtime.libcall -> type:.namedata.r1-
type:runtime.libcall -> type:.namedata.r2-
type:runtime.libcall -> type:.namedata.err-
type:runtime.pcvalueCache -> type:.eqfunc392
type:runtime.pcvalueCache -> type:.namedata.*runtime.pcvalueCache-
type:runtime.pcvalueCache -> type:*runtime.pcvalueCache
type:runtime.pcvalueCache -> type:.namedata.entries-
type:runtime.pcvalueCache -> type:[2][8]runtime.pcvalueCacheEnt
type:runtime.pcvalueCache -> type:.namedata.inUse-
type:runtime.dlogPerM -> type:.namedata.*runtime.dlogPerM-
type:runtime.dlogPerM -> type:*runtime.dlogPerM
type:runtime.mOS -> type:.eqfunc.runtime.mOS
type:runtime.mOS -> type:.namedata.*runtime.mOS-
type:runtime.mOS -> type:*runtime.mOS
type:runtime.mOS -> type:.namedata.initialized-
type:runtime.mOS -> type:.namedata.mutex-
type:runtime.mOS -> type:runtime.pthreadmutex
type:runtime.mOS -> type:.namedata.cond-
type:runtime.mOS -> type:runtime.pthreadcond
type:runtime.mOS -> type:.namedata.count-
type:runtime.pthreadmutex -> type:.eqfunc64
type:runtime.pthreadmutex -> type:.namedata.*runtime.pthreadmutex-
type:runtime.pthreadmutex -> type:*runtime.pthreadmutex <UsedInIface>
type:runtime.pthreadmutex -> type:.namedata.X__sig.
type:runtime.pthreadmutex -> type:.namedata.X__opaque.
type:runtime.pthreadmutex -> type:[56]int8
type:*runtime.pthreadmutex <UsedInIface> -> type:runtime.pthreadmutex <UsedInIface>
type:runtime.pthreadmutex <UsedInIface> -> type:int64 <UsedInIface>
type:runtime.pthreadmutex <UsedInIface> -> type:[56]int8 <UsedInIface>
type:int64 <UsedInIface> -> type:*int64 <UsedInIface>
type:runtime.pthreadcond -> type:.namedata.*runtime.pthreadcond-
type:runtime.pthreadcond -> type:*runtime.pthreadcond <UsedInIface>
type:runtime.pthreadcond -> type:[40]int8
type:*runtime.pthreadcond <UsedInIface> -> type:runtime.pthreadcond <UsedInIface>
type:runtime.pthreadcond <UsedInIface> -> type:[40]int8 <UsedInIface>
type:*runtime.m -> type:.namedata.becomeSpinning-
type:*runtime.m -> type:.namedata.hasCgoOnStack-
type:runtime.g -> runtime.gcbits.7004021090590000
type:runtime.g -> type:.namedata.*runtime.g-
type:runtime.g -> type:.namedata._panic-
type:runtime.g -> type:*runtime._panic
type:runtime.g -> type:.namedata._defer-
type:runtime.g -> type:.namedata.sched-
type:runtime.g -> type:.namedata.syscallsp-
type:runtime.g -> type:.namedata.syscallpc-
type:runtime.g -> type:.namedata.param-
type:runtime.g -> type:.namedata.atomicstatus-
type:runtime.g -> type:.namedata.stackLock-
type:runtime.g -> type:.namedata.waitsince-
type:runtime.g -> type:.namedata.waitreason-
type:runtime.g -> type:runtime.waitReason
type:runtime.g -> type:.namedata.preemptStop-
type:runtime.g -> type:.namedata.preemptShrink-
type:runtime.g -> type:.namedata.asyncSafePoint-
type:runtime.g -> type:.namedata.paniconfault-
type:runtime.g -> type:.namedata.gcscandone-
type:runtime.g -> type:.namedata.throwsplit-
type:runtime.g -> type:.namedata.activeStackChans-
type:runtime.g -> type:.namedata.parkingOnChan-
type:runtime.g -> type:runtime/internal/atomic.Bool
type:runtime.g -> type:.namedata.inMarkAssist-
type:runtime.g -> type:.namedata.coroexit-
type:runtime.g -> type:.namedata.raceignore-
type:runtime.g -> type:.namedata.nocgocallback-
type:runtime.g -> type:.namedata.tracking-
type:runtime.g -> type:.namedata.trackingSeq-
type:runtime.g -> type:.namedata.trackingStamp-
type:runtime.g -> type:.namedata.runnableTime-
type:runtime.g -> type:.namedata.lockedm-
type:runtime.g -> type:.namedata.sig-
type:runtime.g -> type:.namedata.writebuf-
type:runtime.g -> type:[]uint8
type:runtime.g -> type:.namedata.sigcode0-
type:runtime.g -> type:.namedata.sigcode1-
type:runtime.g -> type:.namedata.sigpc-
type:runtime.g -> type:.namedata.parentGoid-
type:runtime.g -> type:.namedata.ancestors-
type:runtime.g -> type:*[]runtime.ancestorInfo
type:runtime.g -> type:.namedata.startpc-
type:runtime.g -> type:.namedata.racectx-
type:runtime.g -> type:.namedata.waiting-
type:runtime.g -> type:.namedata.cgoCtxt-
type:runtime.g -> type:.namedata.labels-
type:runtime.g -> type:.namedata.timer-
type:runtime.g -> type:.namedata.selectDone-
type:runtime.g -> type:.namedata.coroarg-
type:runtime.g -> type:*runtime.coro
type:runtime.g -> type:.namedata.goroutineProfiled-
type:runtime.g -> type:runtime.goroutineProfileStateHolder
type:runtime.g -> type:runtime.gTraceState
type:runtime.g -> type:.namedata.gcAssistBytes-
type:*runtime.coro -> type:.namedata.*runtime.coro-
type:*runtime.coro -> type:runtime.coro
type:*runtime._panic -> type:.namedata.*runtime._panic-
type:*runtime._panic -> type:runtime._panic
type:*runtime._panic -> type:.namedata.initOpenCodedDefers-
type:*runtime._panic -> type:.namedata.nextDefer-
type:*runtime._panic -> type:.namedata.nextFrame-
type:runtime._panic -> type:.eqfunc.runtime._panic
type:runtime._panic -> runtime.gcbits.6d0d000000000000
type:runtime._panic -> type:.namedata.argp-
type:runtime._panic -> type:.namedata.startPC-
type:runtime._panic -> type:.namedata.startSP-
type:runtime._panic -> type:.namedata.fp-
type:runtime._panic -> type:.namedata.retpc-
type:runtime._panic -> type:.namedata.deferBitsPtr-
type:runtime._panic -> type:.namedata.slotsPtr-
type:runtime._panic -> type:.namedata.recovered-
type:runtime._panic -> type:.namedata.goexit-
type:runtime._panic -> type:.namedata.deferreturn-
type:runtime.waitReason -> type:.namedata.*runtime.waitReason-
type:runtime.waitReason -> type:*runtime.waitReason
type:runtime.waitReason -> type:.namedata.String.
type:runtime.waitReason -> type:.namedata.isMutexWait-
type:runtime.goroutineProfileStateHolder -> type:.namedata.*runtime.goroutineProfileStateHolder-
type:runtime.goroutineProfileStateHolder -> type:*runtime.goroutineProfileStateHolder
type:runtime.goroutineProfileStateHolder -> type:.importpath.runtime/internal/atomic.
type:runtime.goroutineProfileStateHolder -> type:.namedata.noCopy-
type:runtime.goroutineProfileStateHolder -> type:runtime/internal/atomic.noCopy
type:runtime.goroutineProfileStateHolder -> type:.namedata.value-
type:*runtime.goroutineProfileStateHolder -> type:.namedata.CompareAndSwap.
type:*runtime.goroutineProfileStateHolder -> type:.namedata.Load.
type:*runtime.goroutineProfileStateHolder -> type:.namedata.Store.
type:runtime.gTraceState -> type:.eqfunc.runtime.gTraceState
type:runtime.gTraceState -> type:.namedata.*runtime.gTraceState-
type:runtime.gTraceState -> type:*runtime.gTraceState
type:*runtime.g -> type:.namedata.guintptr-
type:runtime.guintptr -> type:.namedata.*runtime.guintptr-
type:runtime.guintptr -> type:*runtime.guintptr
type:*runtime.guintptr -> type:.namedata.cas-
type:runtime.coro -> runtime.gcbits.0200000000000000
type:runtime.coro -> type:.namedata.gp-
type:runtime.coro -> type:func(*runtime.coro)
type:runtime.TypeAssertionError -> type:.eqfunc.runtime.TypeAssertionError
type:runtime.TypeAssertionError -> runtime.gcbits.0f00000000000000
type:runtime.TypeAssertionError -> type:.namedata.*runtime.TypeAssertionError.
type:runtime.TypeAssertionError -> type:.namedata._interface-
type:runtime.TypeAssertionError -> type:.namedata.concrete-
type:runtime.TypeAssertionError -> type:.namedata.asserted-
type:runtime.TypeAssertionError -> type:.namedata.missingMethod-
type:*runtime.TypeAssertionError <UsedInIface> -> type:runtime.TypeAssertionError <UsedInIface>
type:runtime.TypeAssertionError <UsedInIface> -> type:*internal/abi.Type <UsedInIface>
 -> go:info.struct { runtime.lock runtime.mutex; runtime.reuse []runtime.liveUserArenaChunk; runtime.fault []runtime.liveUserArenaChunk }
 -> go:info.bool
runtime.cgo_yield -> _cgo_yield
 -> go:info.*unsafe.Pointer
 -> go:info.runtime.cpuProfile
 -> go:info.[33]float64
 -> go:info.runtime.mutex
runtime.itabTable -> runtime.itabTableInit
 -> go:info.*runtime.itabTableType
 -> go:info.runtime.itabTableType
 -> go:info.*internal/abi.Type
 -> go:info.[256]uint64
 -> go:info.uintptr
 -> go:info.struct { runtime.mutex; runtime.persistentAlloc }
 -> go:info.*runtime.notInHeap
 -> go:info.[1024]uint8
 -> go:info.runtime.mspan
 -> go:info.runtime/internal/atomic.Uint32
 -> go:info.*runtime.finblock
 -> go:info.[64]uint8
 -> go:info.[5]uint8
 -> go:info.uint32
 -> go:info.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.alignme uint64 }
 -> go:info.runtime.workType
 -> go:info.func()
 -> go:info.[]unsafe.Pointer
 -> go:info.runtime.gcCPULimiterState
 -> go:info.[1]uint8
 -> go:info.runtime.gcControllerState
 -> go:info.struct { runtime.gcPercentGoal runtime/internal/atomic.Uint64; runtime.memoryLimitGoal runtime/internal/atomic.Uint64; runtime.assistTime runtime/internal/atomic.Int64; runtime.backgroundTime runtime/internal/atomic.Int64 }
 -> go:info.runtime.scavengerState
 -> go:info.runtime.sweepdata
 -> go:info.runtime.mheap
runtime.mSpanStateNames -> runtime..stmp_61
 -> go:info.[]string
 -> go:info.struct { runtime.lock runtime.mutex; runtime.free *runtime.gcBitsArena; runtime.next *runtime.gcBitsArena; runtime.current *runtime.gcBitsArena; runtime.previous *runtime.gcBitsArena }
 -> go:info.[5]uint
 -> go:info.[3]runtime.mutex
 -> go:info.runtime/internal/atomic.UnsafePointer
 -> go:info.runtime.mProfCycleHolder
 -> go:info.uint64
 -> go:info.int
 -> go:info.struct { runtime.sema uint32; runtime.active bool; runtime.offset runtime/internal/atomic.Int64; runtime.records []runtime.StackRecord; runtime.labels []unsafe.Pointer }
 -> go:info.runtime.offAddr
 -> go:info.runtime.spanSetBlockAlloc
 -> go:info.runtime.mstats
 -> go:info.int32
 -> go:info.runtime.sigset
runtime.shiftError -> go:itab.runtime.errorString,error
runtime.shiftError -> runtime..stmp_63
 -> go:info.error
runtime.divideError -> runtime..stmp_64
runtime.panicnil -> runtime..stmp_69
 -> go:info.*runtime.godebugInc
 -> go:info.[512]uint8
 -> go:info.*runtime.mcache
 -> go:info.int64
 -> go:info.[]*runtime.g
 -> go:info.**runtime.g
 -> go:info.runtime/internal/atomic.Bool
runtime.stwReasonStrings -> go:string."unknown"
runtime.stwReasonStrings -> go:string."GC mark termination"
runtime.stwReasonStrings -> go:string."GC sweep termination"
runtime.stwReasonStrings -> go:string."write heap dump"
runtime.stwReasonStrings -> go:string."goroutine profile"
runtime.stwReasonStrings -> go:string."goroutine profile cleanup"
runtime.stwReasonStrings -> go:string."all goroutines stack trace"
runtime.stwReasonStrings -> go:string."read mem stats"
runtime.stwReasonStrings -> go:string."AllThreadsSyscall"
runtime.stwReasonStrings -> go:string."GOMAXPROCS"
runtime.stwReasonStrings -> go:string."start trace"
runtime.stwReasonStrings -> go:string."stop trace"
runtime.stwReasonStrings -> go:string."CountPagesInUse (test)"
runtime.stwReasonStrings -> go:string."ReadMetricsSlow (test)"
runtime.stwReasonStrings -> go:string."ReadMemStatsSlow (test)"
runtime.stwReasonStrings -> go:string."PageCachePagesLeaked (test)"
runtime.stwReasonStrings -> go:string."ResetDebugLog (test)"
 -> go:info.[17]string
 -> go:info.runtime.rwmutex
 -> go:info.struct { runtime.lock runtime.mutex; runtime.newm runtime.muintptr; runtime.waiting bool; runtime.wake runtime.note; runtime.haveTemplateThread uint32 }
 -> go:info.runtime/internal/atomic.Int32
 -> go:info.struct { runtime.signalLock runtime/internal/atomic.Uint32; runtime.hz runtime/internal/atomic.Int32 }
 -> go:info.runtime.randomOrder
 -> go:info.runtime.tracestat
 -> go:info.struct { runtime.lock runtime.mutex; runtime.seed [32]uint8; runtime.state internal/chacha8rand.State; runtime.init bool }
 -> go:info.runtime/internal/atomic.Pointer[func(string) func()]
 -> go:info.struct { runtime.cgocheck int32; runtime.clobberfree int32; runtime.disablethp int32; runtime.dontfreezetheworld int32; runtime.efence int32; runtime.gccheckmark int32; runtime.gcpacertrace int32; runtime.gcshrinkstackoff int32; runtime.gcstoptheworld int32; runtime.gctrace int32; runtime.invalidptr int32; runtime.madvdontneed int32; runtime.runtimeContentionStacks runtime/internal/atomic.Int32; runtime.scavtrace int32; runtime.scheddetail int32; runtime.schedtrace int32; runtime.tracebackancestors int32; runtime.asyncpreemptoff int32; runtime.harddecommit int32; runtime.adaptivestackstart int32; runtime.tracefpunwindoff int32; runtime.traceadvanceperiod int32; runtime.malloc bool; runtime.allocfreetrace int32; runtime.inittrace int32; runtime.sbrk int32; runtime.panicnil runtime/internal/atomic.Int32 }
runtime.waitReasonStrings -> go:string."GC assist marking"
runtime.waitReasonStrings -> go:string."IO wait"
runtime.waitReasonStrings -> go:string."chan receive (nil chan)"
runtime.waitReasonStrings -> go:string."chan send (nil chan)"
runtime.waitReasonStrings -> go:string."dumping heap"
runtime.waitReasonStrings -> go:string."garbage collection"
runtime.waitReasonStrings -> go:string."garbage collection scan"
runtime.waitReasonStrings -> go:string."panicwait"
runtime.waitReasonStrings -> go:string."select"
runtime.waitReasonStrings -> go:string."select (no cases)"
runtime.waitReasonStrings -> go:string."GC assist wait"
runtime.waitReasonStrings -> go:string."GC sweep wait"
runtime.waitReasonStrings -> go:string."GC scavenge wait"
runtime.waitReasonStrings -> go:string."chan receive"
runtime.waitReasonStrings -> go:string."chan send"
runtime.waitReasonStrings -> go:string."finalizer wait"
runtime.waitReasonStrings -> go:string."force gc (idle)"
runtime.waitReasonStrings -> go:string."semacquire"
runtime.waitReasonStrings -> go:string."sleep"
runtime.waitReasonStrings -> go:string."sync.Cond.Wait"
runtime.waitReasonStrings -> go:string."sync.Mutex.Lock"
runtime.waitReasonStrings -> go:string."sync.RWMutex.RLock"
runtime.waitReasonStrings -> go:string."sync.RWMutex.Lock"
runtime.waitReasonStrings -> go:string."trace reader (blocked)"
runtime.waitReasonStrings -> go:string."wait for GC cycle"
runtime.waitReasonStrings -> go:string."GC worker (idle)"
runtime.waitReasonStrings -> go:string."GC worker (active)"
runtime.waitReasonStrings -> go:string."preempted"
runtime.waitReasonStrings -> go:string."debug call"
runtime.waitReasonStrings -> go:string."stopping the world"
runtime.waitReasonStrings -> go:string."flushing proc caches"
runtime.waitReasonStrings -> go:string."trace goroutine status"
runtime.waitReasonStrings -> go:string."trace proc status"
runtime.waitReasonStrings -> go:string."page trace flush"
runtime.waitReasonStrings -> go:string."coroutine"
 -> go:info.[37]string
 -> go:info.*runtime.m
 -> go:info.runtime.schedt
 -> go:info.[]*runtime.p
 -> go:info.runtime.pMask
 -> go:info.runtime.semTable
runtime.sigtable -> go:string."SIGNONE: no trap"
runtime.sigtable -> go:string."SIGHUP: terminal line hangup"
runtime.sigtable -> go:string."SIGINT: interrupt"
runtime.sigtable -> go:string."SIGQUIT: quit"
runtime.sigtable -> go:string."SIGILL: illegal instruction"
runtime.sigtable -> go:string."SIGTRAP: trace trap"
runtime.sigtable -> go:string."SIGABRT: abort"
runtime.sigtable -> go:string."SIGEMT: emulate instruction executed"
runtime.sigtable -> go:string."SIGFPE: floating-point exception"
runtime.sigtable -> go:string."SIGKILL: kill"
runtime.sigtable -> go:string."SIGBUS: bus error"
runtime.sigtable -> go:string."SIGSEGV: segmentation violation"
runtime.sigtable -> go:string."SIGSYS: bad system call"
runtime.sigtable -> go:string."SIGPIPE: write to broken pipe"
runtime.sigtable -> go:string."SIGALRM: alarm clock"
runtime.sigtable -> go:string."SIGTERM: termination"
runtime.sigtable -> go:string."SIGURG: urgent condition on socket"
runtime.sigtable -> go:string."SIGSTOP: stop"
runtime.sigtable -> go:string."SIGTSTP: keyboard stop"
runtime.sigtable -> go:string."SIGCONT: continue after stop"
runtime.sigtable -> go:string."SIGCHLD: child status has changed"
runtime.sigtable -> go:string."SIGTTIN: background read from tty"
runtime.sigtable -> go:string."SIGTTOU: background write to tty"
runtime.sigtable -> go:string."SIGIO: i/o now possible"
runtime.sigtable -> go:string."SIGXCPU: cpu limit exceeded"
runtime.sigtable -> go:string."SIGXFSZ: file size limit exceeded"
runtime.sigtable -> go:string."SIGVTALRM: virtual alarm clock"
runtime.sigtable -> go:string."SIGPROF: profiling alarm clock"
runtime.sigtable -> go:string."SIGWINCH: window size change"
runtime.sigtable -> go:string."SIGINFO: status request from keyboard"
runtime.sigtable -> go:string."SIGUSR1: user-defined signal 1"
runtime.sigtable -> go:string."SIGUSR2: user-defined signal 2"
 -> go:info.[32]runtime.sigTabT
 -> go:info.[32]uint32
 -> go:info.func(*runtime.siginfo, *runtime.sigctxt, *runtime.g) bool
 -> go:info.func(*runtime.g) bool
 -> go:info.struct { runtime.note runtime.note; runtime.mask [1]uint32; runtime.wanted [1]uint32; runtime.ignored [1]uint32; runtime.recv [1]uint32; runtime.state runtime/internal/atomic.Uint32; runtime.delivering runtime/internal/atomic.Uint32; runtime.inuse bool }
 -> go:info.[68]uint16
 -> go:info.[68]uint8
 -> go:info.[68]uint32
 -> go:info.[129]uint8
 -> go:info.[249]uint8
 -> go:info.[4]struct { runtime.item runtime.stackpoolItem; runtime._ [40]uint8 }
 -> go:info.struct { runtime.lock runtime.mutex; runtime.free [35]runtime.mSpanList }
 -> go:info.[1]runtime.stackObjectRecord
 -> go:info.runtime.moduledata
 -> go:info.*[]*runtime.moduledata
 -> go:info.func(uintptr, unsafe.Pointer, int32) int32
 -> go:info.struct { runtime.lock runtime.mutex; runtime.reading *runtime.traceBuf; runtime.empty *runtime.traceBuf; runtime.full [2]runtime.traceBufQueue; runtime.workAvailable runtime/internal/atomic.Bool; runtime.readerGen runtime/internal/atomic.Uintptr; runtime.flushedGen runtime/internal/atomic.Uintptr; runtime.headerWritten bool; runtime.doneSema [2]uint32; runtime.stackTab [2]runtime.traceStackTable; runtime.stringTab [2]runtime.traceStringTable; runtime.cpuLogRead [2]*runtime.profBuf; runtime.signalLock runtime/internal/atomic.Uint32; runtime.cpuLogWrite [2]runtime/internal/atomic.Pointer[runtime.profBuf]; runtime.cpuSleep *runtime.wakeableSleep; runtime.cpuLogDone <-chan struct {}; runtime.cpuBuf [2]*runtime.traceBuf; runtime.reader runtime/internal/atomic.Pointer[runtime.g]; runtime.markWorkerLabels [2][4]runtime.traceArg; runtime.goStopReasons [2][3]runtime.traceArg; runtime.goBlockReasons [2][15]runtime.traceArg; runtime.gen runtime/internal/atomic.Uintptr; runtime.lastNonZeroGen uintptr; runtime.shutdown runtime/internal/atomic.Bool; runtime.exitingSyscall runtime/internal/atomic.Int32; runtime.seqGC uint64 }
runtime.gStatusStrings -> go:string."idle"
runtime.gStatusStrings -> go:string."runnable"
runtime.gStatusStrings -> go:string."running"
runtime.gStatusStrings -> go:string."syscall"
runtime.gStatusStrings -> go:string."waiting"
runtime.gStatusStrings -> go:string."dead"
runtime.gStatusStrings -> go:string."copystack"
 -> go:info.[10]string
 -> go:info.unsafe.Pointer
 -> go:info.struct { runtime.lock runtime.mutex; runtime.next int32; runtime.m map[int32]unsafe.Pointer; runtime.minv map[unsafe.Pointer]int32 }
runtime..stmp_61 -> go:string."mSpanDead"
runtime..stmp_61 -> go:string."mSpanInUse"
runtime..stmp_61 -> go:string."mSpanManual"
runtime..stmp_69 -> go:string."panicnil"
runtime..interfaceSwitch.0 -> runtime.emptyInterfaceSwitchCache
runtime..interfaceSwitch.0 -> type:error
runtime..interfaceSwitch.0 -> type:runtime.stringer
type:error -> runtime.interequal·f
type:error -> type:.namedata.*error-
type:error -> type:*error
type:error -> type:func() string <UsedInIface>
type:runtime.stringer -> type:.namedata.*runtime.stringer-
type:runtime.stringer -> type:*runtime.stringer
 -> go:info.internal/abi.InterfaceSwitchCache
 -> go:info.*runtime.mspan
 -> go:info.*runtime.heapStatsDelta
 -> go:info.runtime.makeSpanClass$abstract
 -> go:info.runtime.bool2int$abstract
 -> go:info.runtime.(*mspan).base$abstract
 -> go:info.runtime/internal/atomic.(*Uint64).Add$abstract
 -> go:info.runtime.lock$abstract
 -> go:info.runtime.lockWithRank$abstract
 -> go:info.runtime.unlock$abstract
 -> go:info.runtime.unlockWithRank$abstract
 -> go:info.*uintptr
 -> go:info.*[2]uintptr
 -> go:info.runtime.(*wbBuf).get2$abstract
 -> go:info.runtime.puintptr.ptr$abstract
 -> go:info.*runtime.cpuProfile
 -> go:info.[]uintptr
 -> go:info.[1]uint64
 -> go:info.runtime.osyield$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).CompareAndSwap$abstract
 -> go:info.runtime/internal/atomic.(*Int32).Load$abstract
 -> go:info.runtime.nanotime$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Store$abstract
 -> go:info.[2]uintptr
 -> go:info.interface {}
 -> go:info.uint
 -> go:info.float32
 -> go:info.float64
 -> go:info.complex64
 -> go:info.complex128
 -> go:info.string
 -> go:info.*runtime.timeHistogram
 -> go:info.*internal/abi.InterfaceType
 -> go:info.*runtime.itab
 -> go:info.runtime.rtype.nameOff$abstract
 -> go:info.**runtime.itab
 -> go:info.runtime.itabHashFunc$abstract
 -> go:info.runtime.add$abstract
 -> go:info.runtime.atomicstorep$abstract
 -> go:info.*internal/abi.UncommonType
 -> go:info.[]internal/abi.Method
 -> go:info.runtime.rtype
 -> go:info.internal/abi.(*Type).Uncommon$abstract
 -> go:info.internal/abi.(*Type).Kind$abstract
 -> go:info.runtime.rtype.typeOff$abstract
 -> go:info.internal/abi.Name.IsExported$abstract
 -> go:info.*internal/abi.InterfaceSwitch
 -> go:info.*internal/abi.InterfaceSwitchCache
 -> go:info.[]*internal/abi.InterfaceType
 -> go:info.internal/abi.UseInterfaceSwitchCache$abstract
 -> go:info.runtime.cheaprand$abstract
 -> go:info.runtime/internal/atomic.casPointer$abstract
 -> go:info.[]internal/abi.InterfaceSwitchCacheEntry
 -> go:info.runtime.buildInterfaceSwitchCache.func1$abstract
 -> go:info.func(*runtime.itab)
 -> go:info.*runtime.lfstack
 -> go:info.*runtime.lfnode
 -> go:info.runtime.lfstackPack$abstract
 -> go:info.runtime.taggedPointerPack$abstract
 -> go:info.runtime.lfstackUnpack$abstract
 -> go:info.runtime.taggedPointer.pointer$abstract
 -> go:info.*runtime.mutex
 -> go:info.*runtime.g
 -> go:info.*runtime.lockTimer
 -> go:info.*runtime.note
 -> go:info.*runtime.mheap
 -> go:info.**runtime.arenaHint
 -> go:info.*runtime.arenaHint
 -> go:info.runtime.arenaIdx
 -> go:info.*[4194304]*runtime.heapArena
 -> go:info.*runtime.heapArena
 -> go:info.[]runtime.arenaIdx
 -> go:info.runtime.alignUp$abstract
 -> go:info.runtime.(*fixalloc).free$abstract
 -> go:info.runtime.arenaIndex$abstract
 -> go:info.runtime.sysAllocOS$abstract
 -> go:info.runtime.sysHugePage$abstract
 -> go:info.runtime.sysFreeOS$abstract
 -> go:info.runtime.spanClass
 -> go:info.runtime.gclinkptr
 -> go:info.uint16
 -> go:info.**internal/abi.Type
 -> go:info.uint8
 -> go:info.runtime.gcTrigger
 -> go:info.runtime.acquirem$abstract
 -> go:info.runtime.getMCache$abstract
 -> go:info.runtime.releasem$abstract
 -> go:info.runtime.nextFreeFast$abstract
 -> go:info.runtime.divRoundUp$abstract
 -> go:info.runtime.goschedguarded$abstract
 -> go:info.runtime.newobject$abstract
 -> go:info.runtime.nextSample$abstract
 -> go:info.runtime.cheaprandn$abstract
 -> go:info.runtime.fastlog2$abstract
 -> go:info.runtime.float64bits$abstract
 -> go:info.*runtime.sysMemStat
 -> go:info.**runtime.notInHeap
 -> go:info.*runtime.persistentAlloc
 -> go:info.runtime.(*notInHeap).add$abstract
 -> go:info.*runtime.linearAlloc
 -> go:info.runtime.sysUsed$abstract
 -> go:info.runtime.sysUsedOS$abstract
 -> go:info.*internal/abi.MapType
 -> go:info.*runtime.hmap
 -> go:info.*runtime.bmap
 -> go:info.runtime.bucketMask$abstract
 -> go:info.runtime.bucketShift$abstract
 -> go:info.runtime.(*hmap).sameSizeGrow$abstract
 -> go:info.runtime.evacuated$abstract
 -> go:info.runtime.(*bmap).overflow$abstract
 -> go:info.runtime.(*bmap).keys$abstract
 -> go:info.runtime.(*gcBits).bytep$abstract
 -> go:info.runtime.mSpanState
 -> go:info.runtime.(*mSpanStateBox).get$abstract
 -> go:info.runtime/internal/atomic.(*Uint8).Load$abstract
 -> go:info.runtime.spanOf$abstract
 -> go:info.runtime.(*mspan).objIndex$abstract
 -> go:info.runtime.(*mspan).divideByElemSize$abstract
 -> go:info.*uint8
 -> go:info.*[1]uintptr
 -> go:info.runtime.addb$abstract
 -> go:info.runtime.(*wbBuf).get1$abstract
 -> go:info.runtime.add1$abstract
 -> go:info.runtime.subtract1$abstract
 -> go:info.runtime.subtractb$abstract
 -> go:info.runtime.typePointers
 -> go:info.runtime.(*mspan).objBase$abstract
 -> go:info.runtime.spanClass.noscan$abstract
 -> go:info.runtime.spanClass.sizeclass$abstract
 -> go:info.runtime.readUintptr$abstract
 -> go:info.runtime.typePointers.nextFast$abstract
 -> go:info.runtime.alignDown$abstract
 -> go:info.*runtime.moduledata
 -> go:info.runtime.activeModules$abstract
 -> go:info.runtime.(*mspan).typePointersOfType$abstract
 -> go:info.runtime.heapBitsSlice$abstract
 -> go:info.**runtime.mspan
 -> go:info.**runtime.mcache
 -> go:info.runtime.(*mcentral).fullSwept$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Load$abstract
 -> go:info.*runtime.mcentral
 -> go:info.runtime.traceLocker
 -> go:info.runtime.sweepLocker
 -> go:info.runtime.sweepLocked
 -> go:info.runtime.traceAcquire$abstract
 -> go:info.runtime.traceEnabled$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).Load$abstract
 -> go:info.runtime.traceLocker.ok$abstract
 -> go:info.runtime.traceRelease$abstract
 -> go:info.runtime.(*mcentral).partialSwept$abstract
 -> go:info.runtime.(*activeSweep).begin$abstract
 -> go:info.runtime.(*mcentral).partialUnswept$abstract
 -> go:info.runtime.(*mcentral).fullUnswept$abstract
 -> go:info.*runtime.checkmarksMap
 -> go:info.runtime.gcMarkWorkAvailable$abstract
 -> go:info.runtime.(*lfstack).empty$abstract
 -> go:info.runtime.markBits
 -> go:info.runtime.markBits.isMarked$abstract
 -> go:info.runtime.sysFaultOS$abstract
 -> go:info.runtime.sysReserveOS$abstract
 -> go:info.*runtime.funcval
 -> go:info.*internal/abi.PtrType
 -> go:info.runtime/internal/atomic.(*Uint32).Or$abstract
 -> go:info.*runtime.fixalloc
 -> go:info.runtime/internal/atomic.(*Uint64).Load$abstract
 -> go:info.runtime.gcMode
 -> go:info.runtime.worldStop
 -> go:info.*runtime.p
 -> go:info.runtime.semacquire$abstract
 -> go:info.runtime.semrelease$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Add$abstract
 -> go:info.runtime.setGCPhase$abstract
 -> go:info.runtime.gcBgMarkPrepare$abstract
 -> go:info.runtime.Gosched$abstract
 -> go:info.*int64
 -> go:info.*runtime.worldStop
 -> go:info.runtime.forEachP$abstract
 -> go:info.*bool
 -> go:info.runtime.(*gcWork).empty$abstract
 -> go:info.runtime.waitReason
 -> go:info.func(*runtime.p)
 -> go:info.[]runtime.liveUserArenaChunk
 -> go:info.[24]uint8
 -> go:info.runtime.casGToWaiting$abstract
 -> go:info.runtime.(*sysMemStat).load$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Store$abstract
 -> go:info.runtime.mProf_NextCycle$abstract
 -> go:info.runtime.(*mProfCycleHolder).increment$abstract
 -> go:info.runtime.itoaDiv$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Load$abstract
 -> go:info.runtime.printunlock$abstract
 -> go:info.runtime.(*gcControllerState).heapGoal$abstract
 -> go:info.*runtime.gcWork
 -> go:info.runtime.noteclear$abstract
 -> go:info.runtime.(*activeSweep).reset$abstract
 -> go:info.runtime/internal/atomic.(*Uint64).Store$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).Store$abstract
 -> go:info.runtime.(*sweepClass).clear$abstract
 -> go:info.*runtime.sudog
 -> go:info.*runtime._defer
 -> go:info.[]uint8
 -> go:info.*runtime.gcCPULimiterState
 -> go:info.runtime.(*gcCPULimiterState).tryLock$abstract
 -> go:info.runtime.limiterEventType
 -> go:info.runtime/internal/atomic.(*Int64).Add$abstract
 -> go:info.runtime/internal/atomic.(*Bool).Store$abstract
 -> go:info.runtime/internal/atomic.(*Uint8).Store$abstract
 -> go:info.*runtime.limiterEvent
 -> go:info.runtime.limiterEventStamp
 -> go:info.runtime.limiterEventStamp.typ$abstract
 -> go:info.runtime.limiterEventStamp.duration$abstract
 -> go:info.runtime.makeLimiterEventStamp$abstract
 -> go:info.runtime/internal/atomic.(*Uint64).CompareAndSwap$abstract
 -> go:info.runtime.(*gcCPULimiterState).addIdleTime$abstract
 -> go:info.runtime.(*gcCPULimiterState).addAssistTime$abstract
 -> go:info.runtime.gcMarkRootPrepare.func1$abstract
 -> go:info.runtime.allGsSnapshot$abstract
 -> go:info.*int
 -> go:info.runtime.readgstatus$abstract
 -> go:info.*runtime/internal/atomic.Int64
 -> go:info.**runtime.moduledata
 -> go:info.*runtime.special
 -> go:info.*runtime.specialfinalizer
 -> go:info.runtime.(*gcCPULimiterState).limiting$abstract
 -> go:info.runtime/internal/atomic.(*Bool).Load$abstract
 -> go:info.runtime/internal/atomic.(*Float64).Load$abstract
 -> go:info.runtime.(*limiterEvent).start$abstract
 -> go:info.runtime.gList
 -> go:info.runtime.(*gQueue).popList$abstract
 -> go:info.runtime.(*gQueue).pushBack$abstract
 -> go:info.runtime.(*guintptr).set$abstract
 -> go:info.runtime.goparkunlock$abstract
 -> go:info.runtime.(*gQueue).empty$abstract
 -> go:info.runtime.(*gQueue).pop$abstract
 -> go:info.runtime.stackScanState
 -> go:info.runtime.unwinder
 -> go:info.*runtime.stackObject
 -> go:info.*runtime.stackObjectRecord
 -> go:info.runtime.isShrinkStackSafe$abstract
 -> go:info.runtime.(*unwinder).init$abstract
 -> go:info.runtime.(*unwinder).valid$abstract
 -> go:info.runtime.(*stackScanState).buildIndex$abstract
 -> go:info.runtime.(*stackScanState).findObject$abstract
 -> go:info.runtime.(*stackObject).setRecord$abstract
 -> go:info.runtime.(*stackObjectRecord).gcdata$abstract
 -> go:info.runtime.(*stackObjectRecord).useGCProg$abstract
 -> go:info.runtime.(*stackObjectRecord).ptrdata$abstract
 -> go:info.runtime.dematerializeGCProg$abstract
 -> go:info.*runtime.stkframe
 -> go:info.*runtime.stackScanState
 -> go:info.[]runtime.stackObjectRecord
 -> go:info.runtime.funcInfo.valid$abstract
 -> go:info.runtime.gcDrainFlags
 -> go:info.func() bool
 -> go:info.runtime.(*gcWork).tryGetFast$abstract
 -> go:info.runtime.heapBits
 -> go:info.runtime.spanOfUnchecked$abstract
 -> go:info.runtime.(*gcWork).putFast$abstract
 -> go:info.runtime.(*mspan).isFree$abstract
 -> go:info.runtime.(*gcBits).bitp$abstract
 -> go:info.runtime.(*mspan).markBitsForIndex$abstract
 -> go:info.runtime.markBits.setMarked$abstract
 -> go:info.runtime.pageIndexOf$abstract
 -> go:info.*runtime.gcControllerState
 -> go:info.runtime/internal/atomic.(*Float64).Store$abstract
 -> go:info.*runtime.pageAlloc
 -> go:info.runtime.chunkIdx
 -> go:info.runtime.pallocSum.max$abstract
 -> go:info.runtime.(*pageAlloc).chunkOf$abstract
 -> go:info.runtime.chunkIdx.l1$abstract
 -> go:info.runtime.chunkIdx.l2$abstract
 -> go:info.runtime.chunkBase$abstract
 -> go:info.runtime.sysUnused$abstract
 -> go:info.runtime.sysUnusedOS$abstract
 -> go:info.runtime.offAddr.lessThan$abstract
 -> go:info.runtime.(*pallocBits).free$abstract
 -> go:info.runtime.fillAligned.func1$abstract
 -> go:info.*runtime.pallocData
 -> go:info.runtime/internal/sys.LeadingZeros64$abstract
 -> go:info.*runtime.scavengeIndex
 -> go:info.runtime.chunkIndex$abstract
 -> go:info.*runtime.atomicOffAddr
 -> go:info.runtime.(*atomicOffAddr).Load$abstract
 -> go:info.runtime.chunkPageIndex$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreUnmark$abstract
 -> go:info.runtime/internal/atomic.(*Int64).CompareAndSwap$abstract
 -> go:info.runtime.(*atomicScavChunkData).load$abstract
 -> go:info.runtime.unpackScavChunkData$abstract
 -> go:info.runtime.scavChunkData.shouldScavenge$abstract
 -> go:info.runtime.(*scavChunkFlags).isEmpty$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreMin$abstract
 -> go:info.runtime.(*atomicOffAddr).Clear$abstract
 -> go:info.runtime.scavChunkData
 -> go:info.runtime.(*atomicScavChunkData).store$abstract
 -> go:info.runtime.scavChunkData.pack$abstract
 -> go:info.runtime.(*atomicOffAddr).StoreMarked$abstract
 -> go:info.runtime.(*scavChunkFlags).setEmpty$abstract
 -> go:info.*runtime.scavChunkData
 -> go:info.runtime.(*scavChunkFlags).setNonEmpty$abstract
 -> go:info.**runtime.stackWorkBuf
 -> go:info.*runtime.stackWorkBuf
 -> go:info.*runtime.stackObjectBuf
 -> go:info.runtime.sweepClass
 -> go:info.runtime.(*sweepClass).load$abstract
 -> go:info.runtime.sweepClass.split$abstract
 -> go:info.runtime.(*sweepClass).update$abstract
 -> go:info.*runtime.activeSweep
 -> go:info.*runtime.sweepLocker
 -> go:info.runtime/internal/atomic.(*Uintptr).Add$abstract
 -> go:info.runtime.(*activeSweep).markDrained$abstract
 -> go:info.runtime.(*scavengerState).ready$abstract
 -> go:info.*runtime.sweepLocked
 -> go:info.runtime.specialsIter
 -> go:info.runtime.(*specialsIter).valid$abstract
 -> go:info.runtime.(*specialsIter).next$abstract
 -> go:info.runtime.(*specialsIter).unlinkAndNext$abstract
 -> go:info.runtime.markBits.setMarkedNonAtomic$abstract
 -> go:info.runtime.spanHasNoSpecials$abstract
 -> go:info.runtime.(*mspan).markBitsForBase$abstract
 -> go:info.runtime.(*mspan).allocBitsForIndex$abstract
 -> go:info.runtime.(*mspan).countAlloc$abstract
 -> go:info.runtime.(*mSpanStateBox).set$abstract
 -> go:info.runtime.(*mheap).freeSpan$abstract
 -> go:info.runtime.(*markBits).advance$abstract
 -> go:info.runtime.clobberfree$abstract
 -> go:info.*runtime.workbuf
 -> go:info.runtime.(*lfstack).pop$abstract
 -> go:info.runtime.(*mSpanList).takeAll$abstract
 -> go:info.runtime.(*mSpanList).isEmpty$abstract
 -> go:info.runtime/internal/atomic.(*Uintptr).CompareAndSwap$abstract
 -> go:info.runtime.isSweepDone$abstract
 -> go:info.runtime.(*activeSweep).isDone$abstract
 -> go:info.runtime.spanAllocType
 -> go:info.runtime.spanAllocType.manual$abstract
 -> go:info.*runtime.pageCache
 -> go:info.runtime.(*pageCache).empty$abstract
 -> go:info.runtime.(*mheap).tryAllocMSpan$abstract
 -> go:info.runtime.heapRetained$abstract
 -> go:info.runtime.heapBitsInSpan$abstract
 -> go:info.runtime.newAllocBits$abstract
 -> go:info.runtime.(*mheap).freeMSpanLocked$abstract
 -> go:info.*runtime.mSpanList
 -> go:info.**runtime.special
 -> go:info.runtime.(*mspan).specialFindSplicePoint$abstract
 -> go:info.runtime.spanHasSpecials$abstract
 -> go:info.*runtime.bucket
 -> go:info.*runtime.specialprofile
 -> go:info.*runtime.specialReachable
 -> go:info.*runtime.gcBits
 -> go:info.*runtime.gcBitsArena
 -> go:info.runtime.(*gcBitsArena).tryAlloc$abstract
 -> go:info.runtime.pallocSum
 -> go:info.[]runtime.pallocSum
 -> go:info.runtime.addrsToSummaryRange$abstract
 -> go:info.runtime.(*pallocData).allocAll$abstract
 -> go:info.runtime.(*pageBits).clearAll$abstract
 -> go:info.runtime.(*pallocBits).allocAll$abstract
 -> go:info.runtime.(*pageBits).setAll$abstract
 -> go:info.func(runtime.offAddr, uintptr)
 -> go:info.struct { runtime.base runtime.offAddr; runtime.bound runtime.offAddr }
 -> go:info.runtime.offAddrToLevelIndex$abstract
 -> go:info.runtime.pallocSum.start$abstract
 -> go:info.runtime.pallocSum.end$abstract
 -> go:info.runtime.levelIndexToOffAddr$abstract
 -> go:info.runtime.offAddr.add$abstract
 -> go:info.*struct { runtime.base runtime.offAddr; runtime.bound runtime.offAddr }
 -> go:info.runtime.offAddr.lessEqual$abstract
 -> go:info.runtime.(*pallocBits).free1$abstract
 -> go:info.runtime.(*pageBits).clear$abstract
 -> go:info.runtime.(*pallocBits).freeAll$abstract
 -> go:info.runtime.pallocSum.unpack$abstract
 -> go:info.runtime.packPallocSum$abstract
 -> go:info.func(int, runtime.addrRange) (int, int)
 -> go:info.func(int, int, int) runtime.addrRange
 -> go:info.func(int, runtime.addrRange) runtime.addrRange
 -> go:info.runtime.addrRange
 -> go:info.runtime.(*pageAlloc).sysGrow.func2$abstract
 -> go:info.runtime.addrRange.size$abstract
 -> go:info.runtime.offAddr.diff$abstract
 -> go:info.runtime.findBitRange64$abstract
 -> go:info.runtime.pageCache
 -> go:info.runtime.(*pallocBits).pages64$abstract
 -> go:info.runtime.(*pageBits).block64$abstract
 -> go:info.runtime.(*pallocBits).allocPages64$abstract
 -> go:info.runtime.(*pageBits).setBlock64$abstract
 -> go:info.runtime.(*pageBits).clearBlock64$abstract
 -> go:info.*runtime.pageBits
 -> go:info.runtime.(*pageBits).set$abstract
 -> go:info.*runtime.pallocBits
 -> go:info.runtime.(*pallocBits).find1$abstract
 -> go:info.runtime.(*pallocBits).allocRange$abstract
 -> go:info.runtime.bucketType
 -> go:info.*[32]uintptr
 -> go:info.*runtime.memRecord
 -> go:info.*runtime.blockRecord
 -> go:info.*runtime.buckhashArray
 -> go:info.*runtime/internal/atomic.UnsafePointer
 -> go:info.runtime/internal/atomic.(*UnsafePointer).Load$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).StoreNoWB$abstract
 -> go:info.runtime.eqslice$abstract
 -> go:info.runtime.(*mProfCycleHolder).setFlushed$abstract
 -> go:info.runtime.(*memRecordCycle).add$abstract
 -> go:info.[32]uintptr
 -> go:info.runtime.(*mProfCycleHolder).read$abstract
 -> go:info.runtime.cheaprand64$abstract
 -> go:info.*runtime.mLockProfile
 -> go:info.[1]uintptr
 -> go:info.runtime.traceback$abstract
 -> go:info.*runtime.addrRanges
 -> go:info.runtime.addrRange.contains$abstract
 -> go:info.runtime.offAddr.equal$abstract
 -> go:info.*runtime.spanSet
 -> go:info.*runtime.spanSetBlock
 -> go:info.runtime.spanSetSpinePointer
 -> go:info.runtime.(*atomicSpanSetSpinePointer).Load$abstract
 -> go:info.runtime.(*atomicSpanSetSpinePointer).StoreNoWB$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).StoreNoWB$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).Load$abstract
 -> go:info.runtime.(*atomicMSpanPointer).StoreNoWB$abstract
 -> go:info.runtime.headTailIndex
 -> go:info.runtime.(*atomicHeadTailIndex).load$abstract
 -> go:info.runtime.headTailIndex.split$abstract
 -> go:info.runtime.headTailIndex.head$abstract
 -> go:info.runtime.(*atomicHeadTailIndex).cas$abstract
 -> go:info.runtime.makeHeadTailIndex$abstract
 -> go:info.runtime.(*atomicMSpanPointer).Load$abstract
 -> go:info.runtime.(*spanSetBlockAlloc).free$abstract
 -> go:info.*runtime.spanSetBlockAlloc
 -> go:info.*runtime.atomicHeadTailIndex
 -> go:info.*runtime.consistentHeapStats
 -> go:info.*runtime.cpuStats
 -> go:info.*runtime.wbBuf
 -> go:info.runtime.(*wbBuf).discard$abstract
 -> go:info.runtime.closeonexec$abstract
 -> go:info.*runtime.pollDesc
 -> go:info.*runtime.gList
 -> go:info.runtime.netpollunblock$abstract
 -> go:info.runtime.(*gList).push$abstract
 -> go:info.runtime.keventt
 -> go:info.*runtime.timespec
 -> go:info.[64]runtime.keventt
 -> go:info.runtime.timespec
 -> go:info.[16]uint8
 -> go:info.runtime.taggedPointer
 -> go:info.runtime.(*timespec).setNsec$abstract
 -> go:info.runtime.taggedPointer.tag$abstract
 -> go:info.runtime.pthreadattr
 -> go:info.runtime.writeErrStr$abstract
 -> go:info.*runtime.pthreadattr
 -> go:info.runtime.usigactiont
 -> go:info.runtime.pageTraceFree$abstract
 -> go:info.runtime.funcname$abstract
 -> go:info.runtime.hasPrefix$abstract
 -> go:info.*runtime/internal/atomic.Pointer[runtime._defer]
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }]).Load$abstract
 -> go:info.runtime.badDefer$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }]).CompareAndSwap$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).CompareAndSwap$abstract
 -> go:info.runtime._panic
 -> go:info.*runtime._panic
 -> go:info.runtime.stringer
 -> go:info.*runtime.savedOpenDeferState
 -> go:info.runtime/internal/sys.LeadingZeros8$abstract
 -> go:info.runtime.funcInfo
 -> go:info.runtime.funcdata$abstract
 -> go:info.runtime.readvarintUnsafe$abstract
 -> go:info.runtime.funcInfo.entry$abstract
 -> go:info.runtime.throwType
 -> go:info.runtime.crash$abstract
 -> go:info.runtime.signame$abstract
 -> go:info.runtime.gotraceback$abstract
 -> go:info.*runtime.pinnerBits
 -> go:info.runtime.(*mspan).getPinnerBits$abstract
 -> go:info.runtime.(*mspan).pinnerBitSize$abstract
 -> go:info.runtime.(*mspan).newPinnerBits$abstract
 -> go:info.runtime.(*mspan).setPinnerBits$abstract
 -> go:info.runtime.suspendGState
 -> go:info.runtime.dumpgstatus$abstract
 -> go:info.runtime.canPreemptM$abstract
 -> go:info.runtime.(*inlineUnwinder).srcFunc$abstract
 -> go:info.runtime.funcInfo.srcFunc$abstract
 -> go:info.runtime.srcFunc.name$abstract
 -> go:info.runtime.writeErr$abstract
 -> go:info.[14]uint8
 -> go:info.[100]uint8
 -> go:info.runtime.printpointer$abstract
 -> go:info.runtime.bytes$abstract
 -> go:info.func(uintptr) uint8
 -> go:info.func(*runtime.g, unsafe.Pointer) bool
 -> go:info.runtime.traceBlockReason
 -> go:info.func(*runtime.g)
 -> go:info.runtime.atomicAllG$abstract
 -> go:info.runtime.atomicAllGIndex$abstract
 -> go:info.runtime.mcount$abstract
 -> go:info.runtime.mpreinit$abstract
 -> go:info.runtime.waitReason.isMutexWait$abstract
 -> go:info.runtime.stwReason
 -> go:info.runtime.stwReason.isGC$abstract
 -> go:info.runtime.netpollinited$abstract
 -> go:info.runtime.netpollAdjustWaiters$abstract
 -> go:info.runtime.(*puintptr).set$abstract
 -> go:info.runtime.traceShuttingDown$abstract
 -> go:info.**runtime.m
 -> go:info.runtime.(*muintptr).set$abstract
 -> go:info.runtime.cgothreadstart
 -> go:info.runtime.mget$abstract
 -> go:info.runtime.muintptr.ptr$abstract
 -> go:info.runtime.runqempty$abstract
 -> go:info.runtime.traceReaderAvailable$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Int32).CompareAndSwap$abstract
 -> go:info.runtime.nobarrierWakeTime$abstract
 -> go:info.runtime/internal/atomic.(*Int32).Add$abstract
 -> go:info.func(int)
 -> go:info.runtime.gQueue
 -> go:info.runtime.(*gList).empty$abstract
 -> go:info.runtime.guintptr.ptr$abstract
 -> go:info.runtime.globrunqputbatch$abstract
 -> go:info.runtime.(*gQueue).pushBackAll$abstract
 -> go:info.runtime.round2$abstract
 -> go:info.runtime.(*goroutineProfileStateHolder).Store$abstract
 -> go:info.runtime.(*gcControllerState).addScannableStack$abstract
 -> go:info.runtime.(*gTraceState).reset$abstract
 -> go:info.*[]runtime.ancestorInfo
 -> go:info.[]runtime.ancestorInfo
 -> go:info.[50]uintptr
 -> go:info.runtime.(*gList).pop$abstract
 -> go:info.runtime.(*gQueue).push$abstract
 -> go:info.runtime.(*gList).pushAll$abstract
 -> go:info.[64]uintptr
 -> go:info.runtime.pMask.set$abstract
 -> go:info.runtime.pMask.clear$abstract
 -> go:info.runtime.globrunqputhead$abstract
 -> go:info.runtime.freemcache$abstract
 -> go:info.[]uint32
 -> go:info.runtime.traceLocker.GoSched$abstract
 -> go:info.runtime.(*randomOrder).reset$abstract
 -> go:info.runtime.gcd$abstract
 -> go:info.runtime.guintptr
 -> go:info.runtime.(*guintptr).cas$abstract
 -> go:info.[129]*runtime.g
 -> go:info.*runtime.gQueue
 -> go:info.*runtime.profBuf
 -> go:info.runtime.profIndex
 -> go:info.runtime.profIndex.tagCount$abstract
 -> go:info.runtime.(*profAtomic).load$abstract
 -> go:info.runtime.countSub$abstract
 -> go:info.[]uint64
 -> go:info.runtime.(*profBuf).hasOverflow$abstract
 -> go:info.runtime.(*profBuf).takeOverflow$abstract
 -> go:info.runtime.(*profBuf).incrementOverflow$abstract
 -> go:info.runtime.profIndex.addCountsAndClearFlags$abstract
 -> go:info.runtime.(*profAtomic).cas$abstract
 -> go:info.internal/chacha8rand.(*State).Next$abstract
 -> go:info.[4]uint64
 -> go:info.internal/chacha8rand.(*State).Init64$abstract
 -> go:info.func() int32
 -> go:info.*func()
 -> go:info.*func(string) func()
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).CompareAndSwap$abstract
 -> go:info.*runtime.rwmutex
 -> go:info.runtime.goready$abstract
 -> go:info.*uint32
 -> go:info.runtime.semaProfileFlags
 -> go:info.*runtime.semaRoot
 -> go:info.runtime.cansemacquire$abstract
 -> go:info.runtime.(*semTable).rootFor$abstract
 -> go:info.runtime.goyield$abstract
 -> go:info.**runtime.sudog
 -> go:info.*runtime.sigctxt
 -> go:info.runtime.(*sigctxt).rax$abstract
 -> go:info.runtime.(*sigctxt).regs$abstract
 -> go:info.runtime.(*sigctxt).rbx$abstract
 -> go:info.runtime.(*sigctxt).rcx$abstract
 -> go:info.runtime.(*sigctxt).rdx$abstract
 -> go:info.runtime.(*sigctxt).rdi$abstract
 -> go:info.runtime.(*sigctxt).rsi$abstract
 -> go:info.runtime.(*sigctxt).rbp$abstract
 -> go:info.runtime.(*sigctxt).rsp$abstract
 -> go:info.runtime.(*sigctxt).r8$abstract
 -> go:info.runtime.(*sigctxt).r9$abstract
 -> go:info.runtime.(*sigctxt).r10$abstract
 -> go:info.runtime.(*sigctxt).r11$abstract
 -> go:info.runtime.(*sigctxt).r12$abstract
 -> go:info.runtime.(*sigctxt).r13$abstract
 -> go:info.runtime.(*sigctxt).r14$abstract
 -> go:info.runtime.(*sigctxt).r15$abstract
 -> go:info.runtime.(*sigctxt).rip$abstract
 -> go:info.runtime.(*sigctxt).rflags$abstract
 -> go:info.runtime.(*sigctxt).cs$abstract
 -> go:info.runtime.(*sigctxt).fs$abstract
 -> go:info.runtime.(*sigctxt).gs$abstract
 -> go:info.*[4]uint8
 -> go:info.runtime.(*sigctxt).pushCall$abstract
 -> go:info.runtime.(*sigctxt).set_rsp$abstract
 -> go:info.runtime.(*sigctxt).set_rip$abstract
 -> go:info.runtime.wantAsyncPreempt$abstract
 -> go:info.runtime.(*sigctxt).sigpc$abstract
 -> go:info.runtime.(*sigctxt).sigsp$abstract
 -> go:info.runtime.signalM$abstract
 -> go:info.*runtime.siginfo
 -> go:info.runtime.(*sigctxt).sigFromUser$abstract
 -> go:info.runtime.(*sigctxt).sigcode$abstract
 -> go:info.os/signal.signal_ignored$abstract
 -> go:info.runtime.(*sigctxt).fault$abstract
 -> go:info.runtime.(*sigctxt).sigaddr$abstract
 -> go:info.*[16]uint8
 -> go:info.runtime.sigaddset$abstract
 -> go:info.runtime.sigNoteWakeup$abstract
 -> go:info.runtime.panicmakeslicelen$abstract
 -> go:info.runtime.panicmakeslicecap$abstract
 -> go:info.runtime.slice
 -> go:info.runtime.nextslicecap$abstract
 -> go:info.runtime.roundupsize$abstract
 -> go:info.runtime.isPowerOfTwo$abstract
 -> go:info.runtime.gclinkptr.ptr$abstract
 -> go:info.runtime.stack
 -> go:info.runtime.stacklog2$abstract
 -> go:info.*runtime.bitvector
 -> go:info.*runtime.adjustinfo
 -> go:info.runtime.bitvector
 -> go:info.runtime.adjustpointer$abstract
 -> go:info.*runtime.hchan
 -> go:info.runtime.adjustsudogs$abstract
 -> go:info.runtime.adjustinfo
 -> go:info.runtime.fillstack$abstract
 -> go:info.runtime.findsghi$abstract
 -> go:info.runtime.adjustpanics$abstract
 -> go:info.*runtime.gobuf
 -> go:info.runtime.gostartcall$abstract
 -> go:info.*runtime.reflectMethodValue
 -> go:info.*runtime.stackmap
 -> go:info.runtime.stackmapdata$abstract
 -> go:info.*runtime.tmpBuf
 -> go:info.runtime.stringDataOnStack$abstract
 -> go:info.runtime.rawstring$abstract
 -> go:info.runtime.gostringnocopy$abstract
 -> go:info.*runtime.findfuncbucket
 -> go:info.runtime.findmoduledatap$abstract
 -> go:info.runtime.(*moduledata).textOff$abstract
 -> go:info.*[8]runtime.pcvalueCacheEnt
 -> go:info.runtime.pcvalueCacheKey$abstract
 -> go:info.runtime.pcdatastart$abstract
 -> go:info.*int32
 -> go:info.runtime.readvarint$abstract
 -> go:info.runtime.inlineUnwinder
 -> go:info.runtime.inlineFrame
 -> go:info.*[1048576]runtime.inlinedCall
 -> go:info.runtime.(*inlineUnwinder).resolveInternal$abstract
 -> go:info.*runtime.inlineUnwinder
 -> go:info.runtime.pthread
 -> go:info.struct { runtime.addr unsafe.Pointer; runtime.n uintptr; runtime.prot int32; runtime.flags int32; runtime.fd int32; runtime.off uint32; runtime.ret1 unsafe.Pointer; runtime.ret2 int }
 -> go:info.[2]int32
 -> go:info.struct { runtime.t int64; runtime.numer uint32; runtime.denom uint32 }
 -> go:info.*runtime.usigactiont
 -> go:info.*runtime.sigset
 -> go:info.struct { runtime.fd int32; runtime.cmd int32; runtime.arg int32; runtime.ret int32; runtime.errno int32 }
 -> go:info.*runtime.keventt
 -> go:info.*runtime.pthreadmutex
 -> go:info.*runtime.pthreadmutexattr
 -> go:info.*runtime.pthreadcond
 -> go:info.*runtime.pthreadcondattr
 -> go:info.*runtime.timer
 -> go:info.[]*runtime.timer
 -> go:info.runtime.traceWriter
 -> go:info.runtime.(*traceBuf).available$abstract
 -> go:info.runtime.traceTime
 -> go:info.runtime.traceClockNow$abstract
 -> go:info.runtime.(*traceBuf).byte$abstract
 -> go:info.runtime.(*traceBuf).varint$abstract
 -> go:info.runtime.(*traceBuf).varintReserve$abstract
 -> go:info.*runtime.traceWriter
 -> go:info.*runtime.traceBuf
 -> go:info.runtime.(*traceBufQueue).push$abstract
 -> go:info.[3]uint64
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.r runtime.profAtomic; runtime.w runtime.profAtomic; runtime.overflow runtime/internal/atomic.Uint64; runtime.overflowTime runtime/internal/atomic.Uint64; runtime.eof runtime/internal/atomic.Uint32; runtime.hdrsize uintptr; runtime.data []uint64; runtime.tags []unsafe.Pointer; runtime.rNext runtime.profIndex; runtime.overflowBuf []uint64; runtime.wait runtime.note }]).Load$abstract
 -> go:info.runtime.traceGoStatus
 -> go:info.runtime.traceProcStatus
 -> go:info.runtime.traceEventWriter
 -> go:info.runtime.traceLocker.writer$abstract
 -> go:info.runtime.(*traceSchedResourceState).statusWasTraced$abstract
 -> go:info.runtime.(*traceSchedResourceState).acquireStatus$abstract
 -> go:info.runtime.(*traceSchedResourceState).readyNextGen$abstract
 -> go:info.runtime.traceNextGen$abstract
 -> go:info.runtime.traceEv
 -> go:info.[]runtime.traceArg
 -> go:info.runtime.traceEventWriter.write$abstract
 -> go:info.runtime.traceEventWriter.end$abstract
 -> go:info.runtime.traceWriter.end$abstract
 -> go:info.runtime.traceArg
 -> go:info.*runtime.traceMap
 -> go:info.*uint64
 -> go:info.*runtime.traceMapNode
 -> go:info.runtime.(*traceMap).bucket$abstract
 -> go:info.runtime.(*traceMapNode).next$abstract
 -> go:info.runtime.notInHeapSlice
 -> go:info.*runtime.traceRegionAlloc
 -> go:info.*runtime.traceRegionAllocBlock
 -> go:info.runtime.traceLocker.stack$abstract
 -> go:info.runtime.(*traceSchedResourceState).nextSeq$abstract
 -> go:info.runtime.stwReason.String$abstract
 -> go:info.runtime.traceLocker.string$abstract
 -> go:info.runtime.(*traceSchedResourceState).setStatusTraced$abstract
 -> go:info.runtime.puintptr
 -> go:info.runtime.traceGoStopReason
 -> go:info.[128]uintptr
 -> go:info.runtime.tracefpunwindoff$abstract
 -> go:info.runtime.(*m).hasCgoOnStack$abstract
 -> go:info.runtime.fpTracebackPCs$abstract
 -> go:info.*runtime.traceStackTable
 -> go:info.*runtime.traceStringTable
 -> go:info.*runtime.stringStruct
 -> go:info.*string
 -> go:info.runtime.(*traceBuf).stringData$abstract
 -> go:info.*runtime.unwinder
 -> go:info.runtime.unwindFlags
 -> go:info.runtime.stkframe
 -> go:info.runtime.(*g).guintptr$abstract
 -> go:info.internal/abi.FuncFlag
 -> go:info.runtime.funcspdelta$abstract
 -> go:info.runtime.srcFunc
 -> go:info.runtime.inlineFrame.valid$abstract
 -> go:info.runtime.elideWrapperCalling$abstract
 -> go:info.*[171]uint8
 -> go:info.func(uint8, uint8) bool
 -> go:info.func(uint8, uint8, uint8)
 -> go:info.runtime.printArgs.func3$abstract
 -> go:info.runtime.readUnaligned64$abstract
 -> go:info.runtime.funcline$abstract
 -> go:info.func(bool) int
 -> go:info.runtime.cgoCallers
 -> go:info.runtime.ancestorInfo
 -> go:info.func() (bool, bool)
 -> go:info.internal/abi.FuncID
 -> go:info.runtime.cgoSymbolizerArg
 -> go:info.runtime.traceback2.func1$abstract
 -> go:info.runtime.(*inlineUnwinder).fileLine$abstract
 -> go:info.runtime.isExportedRuntime$abstract
 -> go:info.runtime.waitReason.String$abstract
 -> go:info.*runtime.cgoCallers
 -> go:info.*runtime.cgoSymbolizerArg
 -> go:info.func(unsafe.Pointer, unsafe.Pointer) int32
 -> go:info.runtime.cgoTracebackArg
 -> go:info.internal/abi.NameOff
 -> go:info.internal/abi.Name
 -> go:info.runtime.reflectOffsLock$abstract
 -> go:info.runtime.reflectOffsUnlock$abstract
 -> go:info.internal/abi.TypeOff
 -> go:info.internal/abi.TextOff
 -> go:info.internal/abi.Name.ReadVarint$abstract
 -> go:info.internal/abi.Name.DataChecked$abstract
 -> go:info.internal/abi.addChecked$abstract
 -> go:info.internal/abi.Name.Data$abstract
 -> go:info.runtime.panicunsafestringlen$abstract
 -> go:info.runtime.panicunsafestringnilptr$abstract
type:*internal/abi.Type <UsedInIface> -> type:.namedata.*abi.Type.
type:*internal/abi.Type <UsedInIface> -> type:internal/abi.Type <UsedInIface>
type:*internal/abi.Type <UsedInIface> -> type:.importpath.internal/abi.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Align.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ArrayType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ChanDir.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Common.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Elem.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.ExportedMethods.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.FieldAlign.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.FuncType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.GcSlice.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.HasName.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.IfaceIndir.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.InterfaceType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.IsDirectIface.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Key.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Kind.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Len.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.MapType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.NumMethod.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Pointers.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Size.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.StructType.
type:*internal/abi.Type <UsedInIface> -> type:.namedata.Uncommon.
type:internal/abi.Type <UsedInIface> -> runtime.gcbits.1800000000000000
type:internal/abi.Type <UsedInIface> -> type:.namedata.Size_.
type:internal/abi.Type <UsedInIface> -> type:.namedata.PtrBytes.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Hash.
type:internal/abi.Type <UsedInIface> -> type:uint32 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.TFlag.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.TFlag <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.Align_.
type:internal/abi.Type <UsedInIface> -> type:uint8 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.FieldAlign_.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Kind_.
type:internal/abi.Type <UsedInIface> -> type:.namedata.Equal.
type:internal/abi.Type <UsedInIface> -> type:func(unsafe.Pointer, unsafe.Pointer) bool <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.GCData.
type:internal/abi.Type <UsedInIface> -> type:*uint8 <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.Str.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.NameOff <UsedInIface>
type:internal/abi.Type <UsedInIface> -> type:.namedata.PtrToThis.
type:internal/abi.Type <UsedInIface> -> type:internal/abi.TypeOff <UsedInIface>
type:uint32 <UsedInIface> -> type:*uint32 <UsedInIface>
type:internal/abi.TFlag <UsedInIface> -> type:.namedata.*abi.TFlag.
type:internal/abi.TFlag <UsedInIface> -> type:*internal/abi.TFlag <UsedInIface>
type:internal/abi.NameOff <UsedInIface> -> type:.namedata.*abi.NameOff.
type:internal/abi.NameOff <UsedInIface> -> type:*internal/abi.NameOff <UsedInIface>
type:internal/abi.TypeOff <UsedInIface> -> type:.namedata.*abi.TypeOff.
type:internal/abi.TypeOff <UsedInIface> -> type:*internal/abi.TypeOff <UsedInIface>
type:runtime/internal/atomic.noCopy -> type:.namedata.*atomic.noCopy-
type:runtime/internal/atomic.noCopy -> type:*runtime/internal/atomic.noCopy
type:*runtime/internal/atomic.noCopy -> type:.namedata.Lock.
type:*runtime/internal/atomic.noCopy -> type:.namedata.Unlock.
type:runtime/internal/atomic.Int64 -> type:.eqfunc.runtime/internal/atomic.Int64
type:runtime/internal/atomic.Int64 -> type:.namedata.*atomic.Int64.
type:runtime/internal/atomic.Int64 -> type:*runtime/internal/atomic.Int64
type:runtime/internal/atomic.Int64 -> type:runtime/internal/atomic.align64
type:*runtime/internal/atomic.Int64 -> type:.namedata.Add.
type:*runtime/internal/atomic.Int64 -> type:.namedata.Swap.
type:runtime/internal/atomic.align64 -> type:.namedata.*atomic.align64-
type:runtime/internal/atomic.align64 -> type:*runtime/internal/atomic.align64
type:runtime/internal/atomic.Bool -> type:.namedata.*atomic.Bool.
type:runtime/internal/atomic.Bool -> type:*runtime/internal/atomic.Bool
type:runtime/internal/atomic.Bool -> type:.namedata.u-
type:runtime/internal/atomic.Bool -> type:runtime/internal/atomic.Uint8
type:runtime/internal/atomic.Uint8 -> type:.namedata.*atomic.Uint8.
type:runtime/internal/atomic.Uint8 -> type:*runtime/internal/atomic.Uint8
type:*runtime/internal/atomic.Uint8 -> type:.namedata.And.
type:*runtime/internal/atomic.Uint8 -> type:.namedata.Or.
type:runtime/internal/atomic.Uint32 -> type:.namedata.*atomic.Uint32.
type:runtime/internal/atomic.Uint32 -> type:*runtime/internal/atomic.Uint32
type:*runtime/internal/atomic.Uint32 -> type:.namedata.CompareAndSwapRelease.
type:*runtime/internal/atomic.Uint32 -> type:.namedata.LoadAcquire.
type:*runtime/internal/atomic.Uint32 -> type:.namedata.StoreRelease.
type:runtime/internal/atomic.Uint64 -> type:.eqfunc.runtime/internal/atomic.Uint64
type:runtime/internal/atomic.Uint64 -> type:.namedata.*atomic.Uint64.
type:runtime/internal/atomic.Uint64 -> type:*runtime/internal/atomic.Uint64
type:runtime/internal/atomic.Uintptr -> type:.namedata.*atomic.Uintptr.
type:runtime/internal/atomic.Uintptr -> type:*runtime/internal/atomic.Uintptr
type:runtime/internal/sys.NotInHeap -> type:.eqfunc.runtime/internal/sys.NotInHeap
type:runtime/internal/sys.NotInHeap -> type:.namedata.*sys.NotInHeap.
type:runtime/internal/sys.NotInHeap -> type:*runtime/internal/sys.NotInHeap
type:runtime/internal/sys.NotInHeap -> type:.importpath.runtime/internal/sys.
type:runtime/internal/sys.NotInHeap -> type:runtime/internal/sys.nih
type:runtime/internal/sys.nih -> type:.namedata.*sys.nih-
type:runtime/internal/sys.nih -> type:*runtime/internal/sys.nih
type:internal/chacha8rand.State -> type:.eqfunc.internal/chacha8rand.State
type:internal/chacha8rand.State -> type:.namedata.*chacha8rand.State.
type:internal/chacha8rand.State -> type:*internal/chacha8rand.State
type:internal/chacha8rand.State -> type:.importpath.internal/chacha8rand.
type:internal/chacha8rand.State -> type:[32]uint64
type:internal/chacha8rand.State -> type:.namedata.seed-
type:internal/chacha8rand.State -> type:[4]uint64
type:internal/chacha8rand.State -> type:.namedata.i-
type:*internal/chacha8rand.State -> type:.namedata.Init.
type:*internal/chacha8rand.State -> type:.namedata.Init64.
type:*internal/chacha8rand.State -> type:.namedata.Next.
type:*internal/chacha8rand.State -> type:.namedata.Refill.
type:*internal/chacha8rand.State -> type:.namedata.Reseed.
 -> go:info.*internal/chacha8rand.State
runtime.memequal64·f -> runtime.memequal64
runtime.memequal32·f -> runtime.memequal32
runtime.strequal·f -> runtime.strequal
type:func() string <UsedInIface> -> type:.namedata.*func() string-
runtime.interequal·f -> runtime.interequal
runtime.interequal -> runtime.ifaceeq
runtime.ifaceeq -> go:string."comparing uncomparable type "
runtime.ifaceeq -> runtime.concatstring2
runtime.concatstring2 -> gclocals·hYXh8R94h8YSj6dF425rfQ==
runtime.concatstring2 -> io/fs.glob.stkobj
runtime.concatstring2 -> fmt.(*fmt).fmtSx.arginfo1
 -> go:info.func(unsafe.Pointer, unsafe.Pointer) bool
 -> go:info.runtime.isDirectIface$abstract
type:func() <UsedInIface> -> type:.namedata.*func()-
type:.eqfunc24 -> runtime.memequal_varlen
runtime.memequal128·f -> runtime.memequal128
runtime.f64equal·f -> runtime.f64equal
type:[2]uint64 -> type:.namedata.*[2]uint64-
type:[2]uint64 -> type:[]uint64
runtime.memequal16·f -> runtime.memequal16
runtime.memequal0·f -> runtime.memequal0
type:func(unsafe.Pointer, unsafe.Pointer) bool <UsedInIface> -> type:.namedata.*func(unsafe.Pointer, unsafe.Pointer) bool-
type:func(unsafe.Pointer, unsafe.Pointer) bool <UsedInIface> -> type:bool <UsedInIface>
type:bool <UsedInIface> -> type:*bool <UsedInIface>
runtime.memequal -> memeqbody
memeqbody -> internal/cpu.X86
 -> go:info.struct { internal/cpu._ internal/cpu.CacheLinePad; HasAES bool; HasADX bool; HasAVX bool; HasAVX2 bool; HasAVX512F bool; HasAVX512BW bool; HasAVX512VL bool; HasBMI1 bool; HasBMI2 bool; HasERMS bool; HasFMA bool; HasOSXSAVE bool; HasPCLMULQDQ bool; HasPOPCNT bool; HasRDTSCP bool; HasSHA bool; HasSSE3 bool; HasSSSE3 bool; HasSSE41 bool; HasSSE42 bool; internal/cpu._ internal/cpu.CacheLinePad }
internal/bytealg.IndexByteString -> indexbytebody
internal/bytealg.IndexByteString -> internal/bytealg.IndexByteString.args_stackmap
internal/bytealg.IndexByteString -> internal/bytealg.IndexByteString.arginfo0
io/fs.glob.stkobj -> runtime.gcbits.0500000000000000
io/fs.ReadFile.stkobj -> runtime.gcbits.0400000000000000
runtime..stmp_126 -> go:string."non-empty mark queue after concurrent mark"
runtime..stmp_135 -> go:string."Bad varint"
runtime..stmp_147 -> go:string."semaRoot queue"
runtime..stmp_149 -> go:string."makeslice: len out of range"
runtime..stmp_150 -> go:string."makeslice: cap out of range"
runtime..stmp_156 -> go:string."growslice: len out of range"
runtime..stmp_177 -> go:string."unsafe.String: len out of range"
runtime..stmp_178 -> go:string."unsafe.String: ptr is nil and len is not zero"
runtime.cgoCheckPtrWrite.stkobj -> runtime.gcbits.0600000000000000
runtime.debugCallWrap.stkobj -> runtime.gcbits.1200000000000000
runtime.markroot.stkobj -> runtime.gcbits.0e00000000000000
runtime.(*mLockProfile).captureStack.stkobj -> runtime.gcbits.5800000000000000
runtime.netpoll.stkobj -> runtime.gcbits.8888888888888888888888888888888888888888888888888888888888888888
runtime.entersyscallblock.stkobj -> runtime.gcbits.1000000000000000
runtime.concatstring3.stkobj -> os..stmp_11
runtime.mmap.stkobj -> os..stmp_17
runtime.(*traceMap).put.stkobj -> runtime.gcbits.4e00000000000000
runtime.traceback1.stkobj -> runtime.gcbits.2200000000000000
runtime.traceback2.stkobj -> runtime.gcbits.1e00000000000000
runtime.exitsyscall -> runtime.exitsyscallfast
runtime.exitsyscall -> runtime.exitsyscall.func1
runtime.exitsyscall -> runtime.exitsyscall.func2
runtime.exitsyscall -> runtime.exitsyscall0·f
runtime.exitsyscall -> go:string."exitsyscall: syscall frame is no longer valid"
runtime.exitsyscall -> gclocals·YX5S7yJdB8lXgytvPhYWZg==
runtime.exitsyscall -> runtime.exitsyscall.stkobj
runtime.exitsyscall.func2 -> runtime.traceLocker.GoSysExit
runtime.exitsyscall.func1 -> runtime.tryRecordGoroutineProfileWB
runtime.tryRecordGoroutineProfileWB -> runtime.osyield·f
runtime.tryRecordGoroutineProfileWB -> runtime.tryRecordGoroutineProfile
runtime.tryRecordGoroutineProfileWB -> go:string."no P available, write barriers are forbidden"
runtime.tryRecordGoroutineProfile -> runtime.doRecordGoroutineProfile
runtime.doRecordGoroutineProfile -> runtime.doRecordGoroutineProfile.func1
runtime.doRecordGoroutineProfile -> go:string."doRecordGoroutineProfile gp1="
runtime.doRecordGoroutineProfile -> go:string."cannot read stack of running goroutine"
runtime.doRecordGoroutineProfile.func1 -> runtime.saveg
runtime.exitsyscallfast -> runtime.exitsyscallfast.func1
runtime.exitsyscallfast -> runtime.exitsyscallfast_reacquired
runtime.exitsyscallfast -> gclocals·NUrQwRM5jZV7b769uXYLhw==
runtime.exitsyscallfast.func1 -> runtime.exitsyscallfast_pidle
runtime.exitsyscallfast_reacquired -> runtime.exitsyscallfast_reacquired.func1
runtime.exitsyscallfast_reacquired -> runtime.exitsyscallfast_reacquired.stkobj
 -> go:info.runtime.goroutineProfileState
 -> go:info.runtime.(*goroutineProfileStateHolder).Load$abstract
 -> go:info.runtime.(*goroutineProfileStateHolder).CompareAndSwap$abstract
 -> go:info.*runtime.StackRecord
 -> go:info.runtime.schedEnabled$abstract
runtime.exit -> runtime.exit_trampoline
time.now -> runtime.walltime
runtime.walltime -> runtime.walltime_trampoline
runtime.morestackc -> runtime.morestackc
runtime.morestackc -> go:string."attempt to execute system stack code on user stack"
go:info.runtime/internal/atomic.(*Uint32).Load$abstract -> go:info.*runtime/internal/atomic.Uint32
go:info.runtime.(*guintptr).set$abstract -> go:info.*runtime.guintptr
go:info.runtime.(*moduledata).textOff$abstract -> go:info.runtime.textsect
go:info.runtime.gostringnocopy$abstract -> go:info.runtime.stringStruct
go:info.runtime/internal/atomic.(*Uintptr).Load$abstract -> go:info.*runtime/internal/atomic.Uintptr
go:info.runtime/internal/atomic.(*Uint64).Add$abstract -> go:info.*runtime/internal/atomic.Uint64
go:info.runtime.(*traceSchedResourceState).readyNextGen$abstract -> go:info.*runtime.traceSchedResourceState
go:info.runtime/internal/atomic.(*Uint8).Load$abstract -> go:info.*runtime/internal/atomic.Uint8
go:info.runtime.(*mSpanStateBox).get$abstract -> go:info.*runtime.mSpanStateBox
go:info.runtime/internal/atomic.(*Bool).Load$abstract -> go:info.*runtime/internal/atomic.Bool
go:info.runtime.(*scavChunkFlags).isEmpty$abstract -> go:info.*runtime.scavChunkFlags
go:info.runtime.(*atomicScavChunkData).load$abstract -> go:info.*runtime.atomicScavChunkData
go:info.runtime.(*fixalloc).free$abstract -> go:info.*runtime.mlink
go:info.runtime/internal/atomic.(*Int32).Load$abstract -> go:info.*runtime/internal/atomic.Int32
go:info.runtime/internal/atomic.(*Float64).Store$abstract -> go:info.*runtime/internal/atomic.Float64
go:info.runtime.(*muintptr).set$abstract -> go:info.*runtime.muintptr
go:info.runtime.muintptr.ptr$abstract -> go:info.runtime.muintptr
go:info.runtime/internal/atomic.(*Pointer[go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef]
go:info.runtime.(*profAtomic).load$abstract -> go:info.*runtime.profAtomic
go:info.runtime.lockWithRank$abstract -> go:info.runtime.lockRank
go:info.runtime.(*inlineUnwinder).srcFunc$abstract -> go:info.*runtime.inlinedCall
go:info.runtime.(*puintptr).set$abstract -> go:info.*runtime.puintptr
go:info.runtime.(*traceBufQueue).push$abstract -> go:info.*runtime.traceBufQueue
go:info.runtime.(*specialsIter).valid$abstract -> go:info.*runtime.specialsIter
go:info.runtime.(*markBits).advance$abstract -> go:info.*runtime.markBits
go:info.runtime.(*mProfCycleHolder).read$abstract -> go:info.*runtime.mProfCycleHolder
go:info.runtime.readUnaligned64$abstract -> go:info.*[8]uint8
go:info.runtime.(*atomicSpanSetSpinePointer).Load$abstract -> go:info.*runtime.atomicSpanSetSpinePointer
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }]).StoreNoWB$abstract -> go:info.*go.shape.struct { runtime.lfnode; runtime.popped runtime/internal/atomic.Uint32; runtime.spans [512]runtime.atomicMSpanPointer }
go:info.runtime.(*atomicMSpanPointer).StoreNoWB$abstract -> go:info.*runtime.atomicMSpanPointer
go:info.runtime.(*goroutineProfileStateHolder).Load$abstract -> go:info.*runtime.goroutineProfileStateHolder
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.r runtime.profAtomic; runtime.w runtime.profAtomic; runtime.overflow runtime/internal/atomic.Uint64; runtime.overflowTime runtime/internal/atomic.Uint64; runtime.eof runtime/internal/atomic.Uint32; runtime.hdrsize uintptr; runtime.data []uint64; runtime.tags []unsafe.Pointer; runtime.rNext runtime.profIndex; runtime.overflowBuf []uint64; runtime.wait runtime.note }]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.struct { runtime.r runtime.profAtomic; runtime.w runtime.profAtomic; runtime.overflow runtime/internal/atomic.Uint64; runtime.overflowTime runtime/internal/atomic.Uint64; runtime.eof runtime/internal/atomic.Uint32; runtime.hdrsize uintptr; runtime.data []uint64; runtime.tags []unsafe.Pointer; runtime.rNext runtime.profIndex; runtime.overflowBuf []uint64; runtime.wait runtime.note }]
go:info.runtime.(*semTable).rootFor$abstract -> go:info.*runtime.semTable
go:info.runtime.(*randomOrder).reset$abstract -> go:info.*runtime.randomOrder
go:info.runtime.(*sweepClass).load$abstract -> go:info.*runtime.sweepClass
go:info.runtime.(*scavengerState).ready$abstract -> go:info.*runtime.scavengerState
go:info.runtime.(*memRecordCycle).add$abstract -> go:info.*runtime.memRecordCycle
go:info.runtime.(*gTraceState).reset$abstract -> go:info.*runtime.gTraceState
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }]
go:info.runtime/internal/atomic.(*Pointer[go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }]).CompareAndSwap$abstract -> go:info.*go.shape.struct { runtime.heap bool; runtime.rangefunc bool; runtime.sp uintptr; runtime.pc uintptr; runtime.fn func(); runtime.link *runtime._defer; runtime.head *runtime/internal/atomic.Pointer[runtime._defer] }
go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.func()]
go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.func(string) func()]
go:info.runtime/internal/atomic.(*Pointer[go.shape.func()]).CompareAndSwap$abstract -> go:info.*go.shape.func()
go:info.runtime.bytes$abstract -> go:info.*runtime.slice
runtime.memequal8·f -> runtime.memequal8
type:[]uint8 -> type:.namedata.*[]uint8-
type:[]uint64 -> type:.namedata.*[]uint64-
type:[]uintptr -> type:.namedata.*[]uintptr-
runtime.c64equal·f -> runtime.c64equal
runtime.c128equal·f -> runtime.c128equal
runtime.f32equal·f -> runtime.f32equal
type:[]unsafe.Pointer -> type:.namedata.*[]unsafe.Pointer-
type:interface {} -> runtime.nilinterequal·f
type:interface {} -> type:.namedata.*interface {}-
runtime.nilinterequal·f -> runtime.nilinterequal
runtime.nilinterequal -> runtime.efaceeq
type:map[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.*map[abi.TypeOff]*abi.Type-
type:map[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type
type:map[internal/abi.TypeOff]*internal/abi.Type -> runtime.memhash32·f
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> runtime.gcbits.e03f000000000000
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.*map.bucket[abi.TypeOff]*abi.Type-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.importpath..
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.topbits-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:[8]uint8
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.keys-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.[8]internal/abi.TypeOff
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.elems-
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:noalg.[8]*internal/abi.Type
type:noalg.map.bucket[internal/abi.TypeOff]*internal/abi.Type -> type:.namedata.overflow-
type:[8]uint8 -> type:.namedata.*[8]uint8-
type:noalg.[8]internal/abi.TypeOff -> type:.namedata.*[8]abi.TypeOff-
type:noalg.[8]internal/abi.TypeOff -> type:[]internal/abi.TypeOff
type:[]internal/abi.TypeOff -> type:.namedata.*[]abi.TypeOff-
type:noalg.[8]*internal/abi.Type -> runtime.gcbits.ff00000000000000
type:noalg.[8]*internal/abi.Type -> type:.namedata.*[8]*abi.Type-
type:noalg.[8]*internal/abi.Type -> type:[]*internal/abi.Type
type:[]*internal/abi.Type -> type:.namedata.*[]*abi.Type-
runtime.memhash32·f -> runtime.memhash32
type:.eqfunc.runtime.PanicNilError -> type:.eq.runtime.PanicNilError
 -> go:info.*runtime.PanicNilError
type:[0]*runtime.PanicNilError <UsedInIface> -> type:.namedata.*[0]*runtime.PanicNilError-
type:[0]*runtime.PanicNilError <UsedInIface> -> type:[]*runtime.PanicNilError <UsedInIface>
type:[]*runtime.PanicNilError <UsedInIface> -> type:.namedata.*[]*runtime.PanicNilError-
type:*runtime/internal/atomic.Pointer[runtime._defer] -> type:.namedata.*atomic.Pointer[runtime._defer].
type:*runtime/internal/atomic.Pointer[runtime._defer] -> type:runtime/internal/atomic.Pointer[runtime._defer]
type:*runtime/internal/atomic.Pointer[runtime._defer] -> type:.namedata.CompareAndSwapNoWB.
type:*runtime/internal/atomic.Pointer[runtime._defer] -> type:.namedata.StoreNoWB.
type:runtime/internal/atomic.Pointer[runtime._defer] -> type:runtime/internal/atomic.UnsafePointer
type:runtime/internal/atomic.UnsafePointer -> type:.namedata.*atomic.UnsafePointer.
type:runtime/internal/atomic.UnsafePointer -> type:*runtime/internal/atomic.UnsafePointer
type:.eqfunc.runtime._panic -> type:.eq.runtime._panic
type:[6]uintptr -> type:.namedata.*[6]uintptr-
type:.eqfunc.runtime.sysmontick -> type:.eq.runtime.sysmontick
 -> go:info.*runtime.sysmontick
type:.eqfunc.runtime.mcache -> type:.eq.runtime.mcache
type:[136]*runtime.mspan -> type:.eqfunc1088
type:[136]*runtime.mspan -> type:.namedata.*[136]*runtime.mspan-
type:[136]*runtime.mspan -> type:*runtime.mspan
type:[136]*runtime.mspan -> type:[]*runtime.mspan
type:*runtime.mspan -> type:.namedata.*runtime.mspan-
type:*runtime.mspan -> type:runtime.mspan
type:*runtime.mspan -> type:.namedata.allocBitsForIndex-
type:*runtime.mspan -> type:.namedata.countAlloc-
type:*runtime.mspan -> type:.namedata.decPinCounter-
type:*runtime.mspan -> type:.namedata.divideByElemSize-
type:*runtime.mspan -> type:.namedata.ensureSwept-
type:*runtime.mspan -> type:.namedata.getPinnerBits-
type:*runtime.mspan -> type:.namedata.heapBits-
type:*runtime.mspan -> type:.namedata.heapBitsSmallForAddr-
type:*runtime.mspan -> type:.namedata.inList-
type:*runtime.mspan -> type:.namedata.incPinCounter-
type:*runtime.mspan -> type:.namedata.initHeapBits-
type:*runtime.mspan -> type:.namedata.isFree-
type:*runtime.mspan -> type:.namedata.isUnusedUserArenaChunk-
type:*runtime.mspan -> type:.namedata.layout-
type:*runtime.mspan -> type:.namedata.markBitsForBase-
type:*runtime.mspan -> type:.namedata.markBitsForIndex-
type:*runtime.mspan -> type:.namedata.newPinnerBits-
type:*runtime.mspan -> type:.namedata.nextFreeIndex-
type:*runtime.mspan -> type:.namedata.objBase-
type:*runtime.mspan -> type:.namedata.objIndex-
type:*runtime.mspan -> type:.namedata.pinnerBitSize-
type:*runtime.mspan -> type:.namedata.refillAllocCache-
type:*runtime.mspan -> type:.namedata.refreshPinnerBits-
type:*runtime.mspan -> type:.namedata.reportZombies-
type:*runtime.mspan -> type:.namedata.setPinnerBits-
type:*runtime.mspan -> type:.namedata.setUserArenaChunkToFault-
type:*runtime.mspan -> type:.namedata.specialFindSplicePoint-
type:*runtime.mspan -> type:.namedata.typePointersOf-
type:*runtime.mspan -> type:.namedata.typePointersOfType-
type:*runtime.mspan -> type:.namedata.typePointersOfUnchecked-
type:*runtime.mspan -> type:.namedata.userArenaNextFree-
type:*runtime.mspan -> type:.namedata.writeHeapBitsSmall-
type:*runtime.mspan -> type:.namedata.writeUserArenaHeapBits-
type:runtime.mspan -> type:.eqfunc.runtime.mspan
type:runtime.mspan -> runtime.gcbits.0000080000000000
type:runtime.mspan -> type:.namedata.list-
type:runtime.mspan -> type:*runtime.mSpanList
type:runtime.mspan -> type:.namedata.startAddr-
type:runtime.mspan -> type:.namedata.npages-
type:runtime.mspan -> type:.namedata.manualFreeList-
type:runtime.mspan -> type:runtime.gclinkptr
type:runtime.mspan -> type:.namedata.freeindex-
type:runtime.mspan -> type:.namedata.nelems-
type:runtime.mspan -> type:.namedata.freeIndexForScan-
type:runtime.mspan -> type:.namedata.allocCache-
type:runtime.mspan -> type:.namedata.allocBits-
type:runtime.mspan -> type:*runtime.gcBits
type:runtime.mspan -> type:.namedata.gcmarkBits-
type:runtime.mspan -> type:.namedata.pinnerBits-
type:runtime.mspan -> type:.namedata.sweepgen-
type:runtime.mspan -> type:.namedata.divMul-
type:runtime.mspan -> type:.namedata.allocCount-
type:runtime.mspan -> type:.namedata.spanclass-
type:runtime.mspan -> type:runtime.spanClass
type:runtime.mspan -> type:.namedata.state-
type:runtime.mspan -> type:runtime.mSpanStateBox
type:runtime.mspan -> type:.namedata.needzero-
type:runtime.mspan -> type:.namedata.isUserArenaChunk-
type:runtime.mspan -> type:.namedata.allocCountBeforeCache-
type:runtime.mspan -> type:.namedata.limit-
type:runtime.mspan -> type:.namedata.speciallock-
type:runtime.mspan -> type:.namedata.specials-
type:runtime.mspan -> type:*runtime.special
type:runtime.mspan -> type:.namedata.userArenaChunkFree-
type:runtime.mspan -> type:runtime.addrRange
type:runtime.mspan -> type:.namedata.largeType-
type:runtime.addrRange -> type:.namedata.*runtime.addrRange-
type:runtime.addrRange -> type:*runtime.addrRange
type:runtime.addrRange -> type:runtime.offAddr
type:runtime.addrRange -> type:.namedata.contains-
type:runtime.addrRange -> type:.namedata.removeGreaterEqual-
type:runtime.addrRange -> type:.namedata.size-
type:runtime.addrRange -> type:.namedata.subtract-
type:*runtime.addrRange -> type:.namedata.takeFromBack-
type:*runtime.addrRange -> type:.namedata.takeFromFront-
type:runtime.offAddr -> type:.namedata.*runtime.offAddr-
type:runtime.offAddr -> type:*runtime.offAddr
type:runtime.offAddr -> type:.namedata.a-
type:runtime.offAddr -> type:.namedata.addr-
type:runtime.offAddr -> type:.namedata.diff-
type:runtime.offAddr -> type:.namedata.equal-
type:runtime.offAddr -> type:.namedata.lessEqual-
type:runtime.offAddr -> type:.namedata.lessThan-
type:runtime.offAddr -> type:.namedata.sub-
type:*runtime.mSpanList -> type:.namedata.*runtime.mSpanList-
type:*runtime.mSpanList -> type:runtime.mSpanList
type:*runtime.mSpanList -> type:.namedata.insert-
type:*runtime.mSpanList -> type:.namedata.insertBack-
type:*runtime.mSpanList -> type:.namedata.isEmpty-
type:*runtime.mSpanList -> type:.namedata.remove-
type:*runtime.mSpanList -> type:.namedata.takeAll-
type:runtime.mSpanList -> type:.eqfunc.runtime.mSpanList
type:runtime.gclinkptr -> type:.namedata.*runtime.gclinkptr-
type:runtime.gclinkptr -> type:*runtime.gclinkptr
type:*runtime.gcBits -> type:.namedata.*runtime.gcBits-
type:*runtime.gcBits -> type:runtime.gcBits
type:*runtime.gcBits -> type:.namedata.bitp-
type:*runtime.gcBits -> type:.namedata.bytep-
type:runtime.gcBits -> type:.eqfunc.runtime.gcBits
type:runtime.gcBits -> type:.namedata.x-
type:runtime.spanClass -> type:.namedata.*runtime.spanClass-
type:runtime.spanClass -> type:*runtime.spanClass
type:runtime.spanClass -> type:.namedata.noscan-
type:runtime.spanClass -> type:.namedata.sizeclass-
type:runtime.mSpanStateBox -> type:.namedata.*runtime.mSpanStateBox-
type:runtime.mSpanStateBox -> type:*runtime.mSpanStateBox
type:runtime.mSpanStateBox -> type:.namedata.s-
type:*runtime.mSpanStateBox -> type:.namedata.get-
type:*runtime.special -> type:.namedata.*runtime.special-
type:*runtime.special -> type:runtime.special
type:runtime.special -> type:.eqfunc.runtime.special
type:runtime.special -> type:.namedata.offset-
type:runtime.special -> type:.namedata.kind-
type:.eqfunc.runtime.mspan -> type:.eq.runtime.mspan
type:.eqfunc.runtime.mSpanList -> type:.eq.runtime.mSpanList
type:.eqfunc.runtime.gcBits -> type:.eq.runtime.gcBits
type:.eqfunc.runtime.special -> type:.eq.runtime.special
type:[]*runtime.mspan -> type:.namedata.*[]*runtime.mspan-
type:[4]runtime.stackfreelist -> type:.namedata.*[4]runtime.stackfreelist-
type:[4]runtime.stackfreelist -> type:runtime.stackfreelist
type:[4]runtime.stackfreelist -> type:[]runtime.stackfreelist
type:runtime.stackfreelist -> type:.namedata.*runtime.stackfreelist-
type:runtime.stackfreelist -> type:*runtime.stackfreelist
type:[]runtime.stackfreelist -> type:.namedata.*[]runtime.stackfreelist-
type:[]*runtime._defer -> type:.namedata.*[]*runtime._defer-
type:[32]*runtime._defer -> runtime.gcbits.ffffffff00000000
type:[32]*runtime._defer -> type:.namedata.*[32]*runtime._defer-
type:[256]runtime.guintptr -> type:.eqfunc2048
type:[256]runtime.guintptr -> type:.namedata.*[256]runtime.guintptr-
type:[256]runtime.guintptr -> type:[]runtime.guintptr
type:[]runtime.guintptr -> type:.namedata.*[]runtime.guintptr-
type:struct { runtime.gList; runtime.n int32 } -> type:.eqfunc.struct { runtime.gList; runtime.n int32 }
type:struct { runtime.gList; runtime.n int32 } -> type:.namedata.*struct { runtime.gList; n int32 }-
type:struct { runtime.gList; runtime.n int32 } -> type:*struct { runtime.gList; runtime.n int32 }
type:struct { runtime.gList; runtime.n int32 } -> type:.namedata.gList-.embedded
type:struct { runtime.gList; runtime.n int32 } -> type:runtime.gList
type:runtime.gList -> type:.namedata.*runtime.gList-
type:runtime.gList -> type:*runtime.gList
type:*runtime.gList -> type:.namedata.pop-
type:*runtime.gList -> type:.namedata.push-
type:*runtime.gList -> type:.namedata.pushAll-
type:.eqfunc.struct { runtime.gList; runtime.n int32 } -> type:.eq.struct { runtime.gList; runtime.n int32 }
 -> go:info.*struct { runtime.gList; runtime.n int32 }
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.0
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.1
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.2
type:*struct { runtime.gList; runtime.n int32 } -> type:.namedata.runtime.3
type:.eqfunc.runtime.hchan -> type:.eq.runtime.hchan
type:[]*runtime.sudog -> type:.namedata.*[]*runtime.sudog-
type:[128]*runtime.sudog -> type:.eqfunc1024
type:[128]*runtime.sudog -> runtime.gcbits.ffffffffffffffffffffffffffffffff
type:[128]*runtime.sudog -> type:.namedata.*[128]*runtime.sudog-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.eqfunc1032
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.namedata.*struct { len int; buf [128]*runtime.mspan }-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:.namedata.len-
type:struct { runtime.len int; runtime.buf [128]*runtime.mspan } -> type:[128]*runtime.mspan
type:[128]*runtime.mspan -> type:.namedata.*[128]*runtime.mspan-
type:[5]unsafe.Pointer -> runtime.gcbits.1f00000000000000
type:[5]unsafe.Pointer -> type:.namedata.*[5]unsafe.Pointer-
type:.eqfunc.runtime.pTraceState -> type:.eq.runtime.pTraceState
 -> go:info.*runtime.pTraceState
type:.eqfunc.runtime.traceSchedResourceState -> type:.eq.runtime.traceSchedResourceState
type:[3]runtime/internal/atomic.Uint32 -> type:.eqfunc12
type:[3]runtime/internal/atomic.Uint32 -> type:.namedata.*[3]atomic.Uint32-
type:[3]runtime/internal/atomic.Uint32 -> type:[]runtime/internal/atomic.Uint32
type:[]runtime/internal/atomic.Uint32 -> type:.namedata.*[]atomic.Uint32-
type:.eqfunc.runtime.notInHeap -> type:.eq.runtime.notInHeap
type:.eqfunc.runtime.limiterEvent -> type:.eq.runtime.limiterEvent
type:.eqfunc.runtime.gcWork -> type:.eq.runtime.gcWork
type:.eqfunc.runtime.workbuf -> type:.eq.runtime.workbuf
type:[253]uintptr -> type:.eqfunc2024
type:[253]uintptr -> type:.namedata.*[253]uintptr-
type:[512]uintptr -> type:.eqfunc4096
type:[512]uintptr -> type:.namedata.*[512]uintptr-
type:func(interface {}, uintptr) -> type:.namedata.*func(interface {}, uintptr)-
type:[]*runtime.timer -> type:.namedata.*[]*runtime.timer-
type:[32]uintptr -> type:.namedata.*[32]uintptr-
type:.eqfunc.runtime.mLockProfile -> type:.eq.runtime.mLockProfile
type:func(*runtime.g, unsafe.Pointer) bool -> type:.namedata.*func(*runtime.g, unsafe.Pointer) bool-
type:[2]*runtime.traceBuf -> type:.namedata.*[2]*runtime.traceBuf-
type:[2]*runtime.traceBuf -> type:*runtime.traceBuf
type:[2]*runtime.traceBuf -> type:[]*runtime.traceBuf
type:*runtime.traceBuf -> type:.namedata.*runtime.traceBuf-
type:*runtime.traceBuf -> type:runtime.traceBuf
type:*runtime.traceBuf -> type:.namedata.available-
type:*runtime.traceBuf -> type:.namedata.byte-
type:*runtime.traceBuf -> type:.namedata.stringData-
type:*runtime.traceBuf -> type:.namedata.varint-
type:*runtime.traceBuf -> type:.namedata.varintAt-
type:*runtime.traceBuf -> type:.namedata.varintReserve-
type:runtime.traceBuf -> type:.eqfunc.runtime.traceBuf
type:runtime.traceBuf -> type:.namedata.traceBufHeader-.embedded
type:runtime.traceBuf -> type:runtime.traceBufHeader
type:runtime.traceBuf -> type:.namedata.arr-
type:runtime.traceBuf -> type:[65504]uint8
type:runtime.traceBufHeader -> type:.namedata.*runtime.traceBufHeader-
type:runtime.traceBufHeader -> type:*runtime.traceBufHeader
type:runtime.traceBufHeader -> type:.namedata.lastTime-
type:runtime.traceBufHeader -> type:runtime.traceTime
type:runtime.traceBufHeader -> type:.namedata.pos-
type:runtime.traceBufHeader -> type:.namedata.lenPos-
type:runtime.traceTime -> type:.namedata.*runtime.traceTime-
type:runtime.traceTime -> type:*runtime.traceTime
type:.eqfunc.runtime.traceBuf -> type:.eq.runtime.traceBuf
type:[65504]uint8 -> type:.eqfunc65504
type:[65504]uint8 -> type:.namedata.*[65504]uint8-
type:[]*runtime.traceBuf -> type:.namedata.*[]*runtime.traceBuf-
type:[2][8]runtime.pcvalueCacheEnt -> type:.eqfunc384
type:[2][8]runtime.pcvalueCacheEnt -> type:.namedata.*[2][8]runtime.pcvalueCacheEnt-
type:[2][8]runtime.pcvalueCacheEnt -> type:[8]runtime.pcvalueCacheEnt
type:[2][8]runtime.pcvalueCacheEnt -> type:[][8]runtime.pcvalueCacheEnt
type:[8]runtime.pcvalueCacheEnt -> type:.eqfunc192
type:[8]runtime.pcvalueCacheEnt -> type:.namedata.*[8]runtime.pcvalueCacheEnt-
type:[8]runtime.pcvalueCacheEnt -> type:runtime.pcvalueCacheEnt
type:[8]runtime.pcvalueCacheEnt -> type:[]runtime.pcvalueCacheEnt
type:runtime.pcvalueCacheEnt -> type:.namedata.*runtime.pcvalueCacheEnt-
type:runtime.pcvalueCacheEnt -> type:*runtime.pcvalueCacheEnt
type:runtime.pcvalueCacheEnt -> type:.namedata.targetpc-
type:runtime.pcvalueCacheEnt -> type:.namedata.val-
type:runtime.pcvalueCacheEnt -> type:.namedata.valPC-
type:[]runtime.pcvalueCacheEnt -> type:.namedata.*[]runtime.pcvalueCacheEnt-
type:[][8]runtime.pcvalueCacheEnt -> type:.namedata.*[][8]runtime.pcvalueCacheEnt-
type:.eqfunc.runtime.mOS -> type:.eq.runtime.mOS
 -> go:info.*runtime.mOS
type:[56]int8 <UsedInIface> -> type:.namedata.*[56]int8-
type:[56]int8 <UsedInIface> -> type:int8 <UsedInIface>
type:[56]int8 <UsedInIface> -> type:[]int8 <UsedInIface>
type:int8 <UsedInIface> -> type:*int8 <UsedInIface>
type:[]int8 <UsedInIface> -> type:.namedata.*[]int8-
type:[40]int8 <UsedInIface> -> type:.namedata.*[40]int8-
type:[10]runtime.heldLockInfo -> type:.eqfunc160
type:[10]runtime.heldLockInfo -> type:.namedata.*[10]runtime.heldLockInfo-
type:[10]runtime.heldLockInfo -> type:runtime.heldLockInfo
type:[10]runtime.heldLockInfo -> type:[]runtime.heldLockInfo
type:runtime.heldLockInfo -> type:.namedata.*runtime.heldLockInfo-
type:runtime.heldLockInfo -> type:*runtime.heldLockInfo
type:runtime.heldLockInfo -> type:.namedata.lockAddr-
type:runtime.heldLockInfo -> type:.namedata.rank-
type:runtime.heldLockInfo -> type:runtime.lockRank
type:runtime.lockRank -> type:.namedata.*runtime.lockRank-
type:runtime.lockRank -> type:*runtime.lockRank
type:[]runtime.heldLockInfo -> type:.namedata.*[]runtime.heldLockInfo-
type:[]runtime.ancestorInfo -> type:.namedata.*[]runtime.ancestorInfo-
type:.eqfunc.runtime.gTraceState -> type:.eq.runtime.gTraceState
type:func(*runtime.coro) -> type:.namedata.*func(*runtime.coro)-
type:.eqfunc.runtime.TypeAssertionError -> type:.eq.runtime.TypeAssertionError
 -> go:info.*runtime.TypeAssertionError
type:map[int32]unsafe.Pointer -> type:.namedata.*map[int32]unsafe.Pointer-
type:map[int32]unsafe.Pointer -> type:noalg.map.bucket[int32]unsafe.Pointer
type:noalg.map.bucket[int32]unsafe.Pointer -> type:.namedata.*map.bucket[int32]unsafe.Pointer-
type:noalg.map.bucket[int32]unsafe.Pointer -> type:noalg.[8]int32
type:noalg.map.bucket[int32]unsafe.Pointer -> type:noalg.[8]unsafe.Pointer
type:noalg.[8]unsafe.Pointer -> type:.namedata.*[8]unsafe.Pointer-
type:noalg.[8]int32 -> type:.namedata.*[8]int32-
type:noalg.[8]int32 -> type:[]int32
type:[]int32 -> type:.namedata.*[]int32-
type:[4]uint64 -> type:.namedata.*[4]uint64-
runtime.(*mheap).allocSpan.func1·f -> runtime.(*mheap).allocSpan.func1
runtime.(*pageAlloc).sysGrow.func1·f -> runtime.(*pageAlloc).sysGrow.func1
 -> go:info.runtime.blockAlignSummaryRange$abstract
runtime.asmcgocall·f -> runtime.asmcgocall
runtime.cgocall·f -> runtime.cgocall
runtime.cgocall -> type:*runtime.m <UsedInIface>
runtime.cgocall -> runtime.entersyscall
runtime.cgocall -> go:string."cgocall nil"
runtime.cgocall -> go:string."cgocall unavailable"
type:*runtime.m <UsedInIface> -> type:runtime.m <UsedInIface>
type:runtime.m <UsedInIface> -> type:*runtime.g <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.gobuf <UsedInIface>
type:runtime.m <UsedInIface> -> type:uint64 <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.gsignalStack <UsedInIface>
type:runtime.m <UsedInIface> -> type:[6]uintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.guintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.puintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:int32 <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.throwType <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime/internal/atomic.Uint32 <UsedInIface>
type:runtime.m <UsedInIface> -> type:*runtime.cgoCallers <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.note <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.muintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:[32]uintptr <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.mLockProfile <UsedInIface>
type:runtime.m <UsedInIface> -> type:func(*runtime.g, unsafe.Pointer) bool <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.traceBlockReason <UsedInIface>
type:runtime.m <UsedInIface> -> type:int <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.mTraceState <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.libcall <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.pcvalueCache <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.dlogPerM <UsedInIface>
type:runtime.m <UsedInIface> -> type:runtime.mOS <UsedInIface>
type:runtime.m <UsedInIface> -> type:internal/chacha8rand.State <UsedInIface>
type:runtime.m <UsedInIface> -> type:[10]runtime.heldLockInfo <UsedInIface>
type:int32 <UsedInIface> -> type:*int32 <UsedInIface>
type:uint64 <UsedInIface> -> type:*uint64 <UsedInIface>
type:int <UsedInIface> -> type:*int <UsedInIface>
type:*runtime.cgoCallers <UsedInIface> -> type:runtime.cgoCallers <UsedInIface>
type:runtime.cgoCallers <UsedInIface> -> type:[]uintptr <UsedInIface>
type:runtime.gobuf <UsedInIface> -> type:*runtime.gobuf <UsedInIface>
type:runtime.gsignalStack <UsedInIface> -> type:*runtime.gsignalStack <UsedInIface>
type:runtime.gsignalStack <UsedInIface> -> type:runtime.stack <UsedInIface>
type:runtime.stack <UsedInIface> -> type:*runtime.stack <UsedInIface>
type:runtime.muintptr <UsedInIface> -> type:*runtime.muintptr <UsedInIface>
type:runtime.puintptr <UsedInIface> -> type:*runtime.puintptr <UsedInIface>
type:runtime.throwType <UsedInIface> -> type:*runtime.throwType <UsedInIface>
type:runtime.note <UsedInIface> -> type:*runtime.note <UsedInIface>
type:runtime.mLockProfile <UsedInIface> -> type:*runtime.mLockProfile <UsedInIface>
type:runtime.mLockProfile <UsedInIface> -> type:runtime/internal/atomic.Int64 <UsedInIface>
type:runtime.traceBlockReason <UsedInIface> -> type:*runtime.traceBlockReason <UsedInIface>
type:runtime.mTraceState <UsedInIface> -> type:*runtime.mTraceState <UsedInIface>
type:runtime.mTraceState <UsedInIface> -> type:runtime/internal/atomic.Uintptr <UsedInIface>
type:runtime.mTraceState <UsedInIface> -> type:[2]*runtime.traceBuf <UsedInIface>
type:runtime.libcall <UsedInIface> -> type:*runtime.libcall <UsedInIface>
type:runtime.pcvalueCache <UsedInIface> -> type:*runtime.pcvalueCache <UsedInIface>
type:runtime.pcvalueCache <UsedInIface> -> type:[2][8]runtime.pcvalueCacheEnt <UsedInIface>
type:runtime.dlogPerM <UsedInIface> -> type:*runtime.dlogPerM <UsedInIface>
type:runtime.mOS <UsedInIface> -> type:*runtime.mOS <UsedInIface>
type:*runtime.g <UsedInIface> -> type:runtime.g <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime._panic <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime._defer <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.waitReason <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime/internal/atomic.Bool <UsedInIface>
type:runtime.g <UsedInIface> -> type:[]uint8 <UsedInIface>
type:runtime.g <UsedInIface> -> type:*[]runtime.ancestorInfo <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime.sudog <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime.timer <UsedInIface>
type:runtime.g <UsedInIface> -> type:*runtime.coro <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.goroutineProfileStateHolder <UsedInIface>
type:runtime.g <UsedInIface> -> type:runtime.gTraceState <UsedInIface>
type:*runtime._defer <UsedInIface> -> type:runtime._defer <UsedInIface>
type:runtime._defer <UsedInIface> -> type:*runtime/internal/atomic.Pointer[runtime._defer] <UsedInIface>
type:*runtime.coro <UsedInIface> -> type:runtime.coro <UsedInIface>
type:*runtime._panic <UsedInIface> -> type:runtime._panic <UsedInIface>
type:runtime._panic <UsedInIface> -> type:interface {} <UsedInIface>
type:*runtime.sudog <UsedInIface> -> type:runtime.sudog <UsedInIface>
type:runtime.sudog <UsedInIface> -> type:uint16 <UsedInIface>
type:runtime.sudog <UsedInIface> -> type:*runtime.hchan <UsedInIface>
type:uint16 <UsedInIface> -> type:*uint16 <UsedInIface>
type:*runtime.hchan <UsedInIface> -> type:runtime.hchan <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:uint <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:runtime.waitq <UsedInIface>
type:runtime.hchan <UsedInIface> -> type:runtime.mutex <UsedInIface>
type:uint <UsedInIface> -> type:*uint <UsedInIface>
type:runtime.mutex <UsedInIface> -> type:*runtime.mutex <UsedInIface>
type:runtime.mutex <UsedInIface> -> type:runtime.lockRankStruct <UsedInIface>
type:runtime.lockRankStruct <UsedInIface> -> type:*runtime.lockRankStruct <UsedInIface>
type:runtime.waitq <UsedInIface> -> type:*runtime.waitq <UsedInIface>
type:*runtime.timer <UsedInIface> -> type:runtime.timer <UsedInIface>
type:runtime.timer <UsedInIface> -> type:func(interface {}, uintptr) <UsedInIface>
type:runtime.waitReason <UsedInIface> -> type:*runtime.waitReason <UsedInIface>
type:runtime.goroutineProfileStateHolder <UsedInIface> -> type:*runtime.goroutineProfileStateHolder <UsedInIface>
type:runtime.goroutineProfileStateHolder <UsedInIface> -> type:runtime/internal/atomic.noCopy <UsedInIface>
type:runtime.gTraceState <UsedInIface> -> type:*runtime.gTraceState <UsedInIface>
type:runtime.gTraceState <UsedInIface> -> type:runtime.traceSchedResourceState <UsedInIface>
type:runtime.traceSchedResourceState <UsedInIface> -> type:*runtime.traceSchedResourceState <UsedInIface>
type:runtime.traceSchedResourceState <UsedInIface> -> type:[3]runtime/internal/atomic.Uint32 <UsedInIface>
type:runtime.traceSchedResourceState <UsedInIface> -> type:[2]uint64 <UsedInIface>
type:runtime.guintptr <UsedInIface> -> type:*runtime.guintptr <UsedInIface>
type:runtime.coro <UsedInIface> -> type:func(*runtime.coro) <UsedInIface>
type:runtime/internal/atomic.noCopy <UsedInIface> -> type:*runtime/internal/atomic.noCopy <UsedInIface>
type:runtime/internal/atomic.Int64 <UsedInIface> -> type:*runtime/internal/atomic.Int64 <UsedInIface>
type:runtime/internal/atomic.Int64 <UsedInIface> -> type:runtime/internal/atomic.align64 <UsedInIface>
type:runtime/internal/atomic.align64 <UsedInIface> -> type:*runtime/internal/atomic.align64 <UsedInIface>
type:runtime/internal/atomic.Bool <UsedInIface> -> type:*runtime/internal/atomic.Bool <UsedInIface>
type:runtime/internal/atomic.Bool <UsedInIface> -> type:runtime/internal/atomic.Uint8 <UsedInIface>
type:runtime/internal/atomic.Uint8 <UsedInIface> -> type:*runtime/internal/atomic.Uint8 <UsedInIface>
type:runtime/internal/atomic.Uint32 <UsedInIface> -> type:*runtime/internal/atomic.Uint32 <UsedInIface>
type:runtime/internal/atomic.Uintptr <UsedInIface> -> type:*runtime/internal/atomic.Uintptr <UsedInIface>
type:internal/chacha8rand.State <UsedInIface> -> type:*internal/chacha8rand.State <UsedInIface>
type:internal/chacha8rand.State <UsedInIface> -> type:[32]uint64 <UsedInIface>
type:internal/chacha8rand.State <UsedInIface> -> type:[4]uint64 <UsedInIface>
type:[2]uint64 <UsedInIface> -> type:[]uint64 <UsedInIface>
runtime.entersyscall -> runtime.reentersyscall
runtime.reentersyscall -> runtime.reentersyscall.func1
runtime.reentersyscall -> runtime.reentersyscall.func2
runtime.reentersyscall -> runtime.entersyscall_sysmon·f
runtime.reentersyscall -> runtime.runSafePointFn·f
runtime.reentersyscall -> runtime.entersyscall_gcwait·f
runtime.reentersyscall -> gclocals·A5Lk+3az1rgtNYe+HTsqRQ==
runtime.reentersyscall -> runtime.reentersyscall.stkobj
runtime.reentersyscall.func2 -> runtime.traceLocker.GoSysCall
runtime.reentersyscall.func1 -> go:string."entersyscall inconsistent "
runtime.reentersyscall.func1 -> go:string."entersyscall"
runtime.traceLocker.GoSysCall -> gclocals·WLA81huw5JiUYrFtuuX0QA==
type:*runtime/internal/atomic.Pointer[runtime._defer] <UsedInIface> -> type:runtime/internal/atomic.Pointer[runtime._defer] <UsedInIface>
type:runtime/internal/atomic.Pointer[runtime._defer] <UsedInIface> -> type:runtime/internal/atomic.UnsafePointer <UsedInIface>
type:runtime/internal/atomic.UnsafePointer <UsedInIface> -> type:*runtime/internal/atomic.UnsafePointer <UsedInIface>
type:[3]runtime/internal/atomic.Uint32 <UsedInIface> -> type:[]runtime/internal/atomic.Uint32 <UsedInIface>
type:[2]*runtime.traceBuf <UsedInIface> -> type:*runtime.traceBuf <UsedInIface>
type:[2]*runtime.traceBuf <UsedInIface> -> type:[]*runtime.traceBuf <UsedInIface>
type:*runtime.traceBuf <UsedInIface> -> type:runtime.traceBuf <UsedInIface>
type:runtime.traceBuf <UsedInIface> -> type:runtime/internal/sys.NotInHeap <UsedInIface>
type:runtime.traceBuf <UsedInIface> -> type:runtime.traceBufHeader <UsedInIface>
type:runtime.traceBuf <UsedInIface> -> type:[65504]uint8 <UsedInIface>
type:runtime.traceBufHeader <UsedInIface> -> type:*runtime.traceBufHeader <UsedInIface>
type:runtime.traceBufHeader <UsedInIface> -> type:runtime.traceTime <UsedInIface>
type:runtime.traceTime <UsedInIface> -> type:*runtime.traceTime <UsedInIface>
type:runtime/internal/sys.NotInHeap <UsedInIface> -> type:*runtime/internal/sys.NotInHeap <UsedInIface>
type:runtime/internal/sys.NotInHeap <UsedInIface> -> type:runtime/internal/sys.nih <UsedInIface>
type:runtime/internal/sys.nih <UsedInIface> -> type:*runtime/internal/sys.nih <UsedInIface>
type:[2][8]runtime.pcvalueCacheEnt <UsedInIface> -> type:[8]runtime.pcvalueCacheEnt <UsedInIface>
type:[2][8]runtime.pcvalueCacheEnt <UsedInIface> -> type:[][8]runtime.pcvalueCacheEnt <UsedInIface>
type:[8]runtime.pcvalueCacheEnt <UsedInIface> -> type:runtime.pcvalueCacheEnt <UsedInIface>
type:[8]runtime.pcvalueCacheEnt <UsedInIface> -> type:[]runtime.pcvalueCacheEnt <UsedInIface>
type:runtime.pcvalueCacheEnt <UsedInIface> -> type:*runtime.pcvalueCacheEnt <UsedInIface>
type:[10]runtime.heldLockInfo <UsedInIface> -> type:runtime.heldLockInfo <UsedInIface>
type:[10]runtime.heldLockInfo <UsedInIface> -> type:[]runtime.heldLockInfo <UsedInIface>
type:runtime.heldLockInfo <UsedInIface> -> type:*runtime.heldLockInfo <UsedInIface>
type:runtime.heldLockInfo <UsedInIface> -> type:runtime.lockRank <UsedInIface>
type:runtime.lockRank <UsedInIface> -> type:*runtime.lockRank <UsedInIface>
type:*[]runtime.ancestorInfo <UsedInIface> -> type:[]runtime.ancestorInfo <UsedInIface>
type:[]runtime.ancestorInfo <UsedInIface> -> type:runtime.ancestorInfo <UsedInIface>
type:runtime.ancestorInfo <UsedInIface> -> type:*runtime.ancestorInfo <UsedInIface>
runtime.entersyscall_gcwait·f -> runtime.entersyscall_gcwait
runtime.entersyscall_sysmon·f -> runtime.entersyscall_sysmon
runtime.entersyscallblock_handoff·f -> runtime.entersyscallblock_handoff
runtime.exitsyscall0·f -> runtime.exitsyscall0
runtime.exitsyscall0 -> runtime.execute
runtime.exitsyscall0 -> runtime.stoplockedm
runtime.exitsyscall0 -> runtime.stopm
runtime.exitsyscall0 -> runtime.schedule
runtime.stopm -> runtime.mput
runtime.stopm -> go:string."stopm spinning"
runtime.stopm -> go:string."stopm holding p"
runtime.stopm -> go:string."stopm holding locks"
runtime.stoplockedm -> runtime.incidlelocked
runtime.stoplockedm -> go:string."runtime:stoplockedm: lockedg (atomicstatus="
runtime.stoplockedm -> go:string.") is not Grunnable or Gscanrunnable\n"
runtime.stoplockedm -> go:string."stoplockedm: not runnable"
runtime.stoplockedm -> go:string."stoplockedm: inconsistent locking"
runtime.stoplockedm -> gclocals·4FI4FushYEU3mjALcQ0xCQ==
runtime.execute -> runtime.gogo
runtime.schedule -> runtime.startlockedm
runtime.schedule -> runtime.findRunnable
runtime.schedule -> runtime.resetspinning
runtime.schedule -> go:string."schedule: spinning with local work"
runtime.schedule -> go:string."schedule: in cgo"
runtime.schedule -> go:string."schedule: holding locks"
runtime.startlockedm -> go:string."startlockedm: m has p"
runtime.startlockedm -> go:string."startlockedm: locked to me"
runtime.findRunnable -> runtime.runSafePointFn
runtime.findRunnable -> runtime.checkTimers
runtime.findRunnable -> runtime.traceReader
runtime.findRunnable -> runtime.(*gcControllerState).findRunnableGCWorker
runtime.findRunnable -> runtime.globrunqget
runtime.findRunnable -> runtime.fing
runtime.findRunnable -> runtime.gcstopm
runtime.findRunnable -> runtime.stealWork
runtime.findRunnable -> runtime.(*gcControllerState).addIdleMarkWorker
runtime.findRunnable -> runtime.checkRunqsNoP
runtime.findRunnable -> runtime.checkIdleGCNoP
runtime.findRunnable -> runtime.checkTimersNoP
runtime.findRunnable -> runtime.faketime
runtime.findRunnable -> go:string."global runq empty with non-zero runqsize"
runtime.findRunnable -> go:string."findrunnable: netpoll with spinning"
runtime.findRunnable -> go:string."findrunnable: netpoll with p"
runtime.findRunnable -> go:string."findrunnable: negative nmspinning"
runtime.findRunnable -> go:string."findrunnable: wrong p"
runtime.findRunnable -> runtime.gcBgMarkWorkerPool
runtime.findRunnable -> runtime.(*gcControllerState).removeIdleMarkWorker
runtime.findRunnable -> gclocals·ZEqG3SPlZVw7WSNG25iP8Q==
runtime.findRunnable -> gclocals·uvIQPYGF52sukrm7Psx8vw==
runtime.(*gcControllerState).findRunnableGCWorker -> go:string."gcControllerState.findRunnable: blackening not enabled"
runtime.(*gcControllerState).findRunnableGCWorker -> gclocals·bCM+E/n8R3vObPlYz/Iwog==
runtime.gcstopm -> go:string."gcstopm: negative nmspinning"
runtime.gcstopm -> go:string."gcstopm: not waiting for gc"
runtime.stealWork -> runtime.runqsteal
runtime.checkRunqsNoP -> gclocals·2A2zbY2sHTuUjMt5MjKHOA==
runtime.checkRunqsNoP -> fmt.Append.arginfo1
runtime.checkTimersNoP -> reflect.deepValueEqual.arginfo1
runtime.resetspinning -> go:string."resetspinning: not a spinning m"
runtime.checkTimers -> runtime.adjusttimers
runtime.checkTimers -> runtime.runtimer
runtime.checkTimers -> runtime.clearDeletedTimers
runtime.incidlelocked -> runtime.checkdead
runtime.checkdead -> runtime.islibrary
runtime.checkdead -> runtime.isarchive
runtime.checkdead -> runtime.cgoHasExtraM
runtime.checkdead -> runtime.checkdead.func1
runtime.checkdead -> go:string."no goroutines (main called runtime.Goexit) - deadlock!"
runtime.checkdead -> runtime.timeSleepUntil
runtime.checkdead -> go:string."checkdead: no m for timer"
runtime.checkdead -> go:string."checkdead: no p for timer"
runtime.checkdead -> go:string."all goroutines are asleep - deadlock!"
runtime.checkdead -> go:string."runtime: checkdead: nmidle="
runtime.checkdead -> go:string." mcount="
runtime.checkdead -> go:string." nmsys="
runtime.checkdead -> go:string."checkdead: inconsistent counts"
runtime.checkdead.func1 -> go:string."runtime: checkdead: find g "
runtime.checkdead.func1 -> go:string." in status "
runtime.checkdead.func1 -> go:string."checkdead: runnable g"
runtime.runqsteal -> runtime.runqgrab
runtime.runqsteal -> go:string."runqsteal: runq overflow"
runtime.runqgrab -> runtime.runqgrab.arginfo1
runtime.adjusttimers -> runtime.adjusttimers.jump19
runtime.adjusttimers -> runtime.dodeltimer
runtime.adjusttimers -> runtime.addAdjustedTimers
runtime.adjusttimers -> go:string."adjusttimers: bad p"
runtime.adjusttimers -> gclocals·IEvgBZYKa2AgiMWIYzMedQ==
runtime.dodeltimer -> runtime.siftdownTimer
runtime.dodeltimer -> go:string."dodeltimer: wrong P"
runtime.runtimer -> runtime.runtimer.jump13
runtime.runtimer -> runtime.dodeltimer0
runtime.runtimer -> runtime.runOneTimer
runtime.runtimer -> go:string."runtimer: bad p"
runtime.dodeltimer0 -> go:string."dodeltimer0: wrong P"
runtime.runOneTimer -> gclocals·t/xps2kNqDgeo8aGJO2G+A==
runtime.runOneTimer -> gclocals·jiTyHuuhQcickEQkR7IMlw==
runtime.clearDeletedTimers -> runtime.clearDeletedTimers.jump14
 -> go:info.runtime.lfstack
 -> go:info.*runtime.gcBgMarkWorkerNode
 -> go:info.runtime.(*gcCPULimiterState).needUpdate$abstract
 -> go:info.runtime.(*gcControllerState).findRunnableGCWorker.func1$abstract
 -> go:info.runtime.mPark$abstract
 -> go:info.runtime.setThreadCPUProfiler$abstract
 -> go:info.runtime.setThreadCPUProfilerHz$abstract
 -> go:info.runtime.runqget$abstract
 -> go:info.runtime.wakefing$abstract
 -> go:info.runtime.netpollAnyWaiters$abstract
 -> go:info.runtime.(*m).becomeSpinning$abstract
 -> go:info.runtime/internal/atomic.(*Int64).Swap$abstract
 -> go:info.runtime.randomEnum
 -> go:info.runtime.(*randomOrder).start$abstract
 -> go:info.runtime.(*randomEnum).next$abstract
 -> go:info.runtime.(*randomEnum).done$abstract
 -> go:info.runtime.(*randomEnum).position$abstract
 -> go:info.runtime.pMask.read$abstract
 -> go:info.runtime.(*gcControllerState).needIdleMarkWorker$abstract
 -> go:info.runtime.traceExitingSyscall$abstract
 -> go:info.runtime.traceExitedSyscall$abstract
 -> go:info.runtime.dropg$abstract
 -> go:info.runtime.setMNoWB$abstract
 -> go:info.runtime.setGNoWB$abstract
 -> go:info.runtime.globrunqput$abstract
 -> go:info.*[256]runtime.guintptr
 -> go:info.runtime.updateTimer0When$abstract
 -> go:info.func(interface {}, uintptr)
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef]).CompareAndSwapNoWB$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).CompareAndSwapNoWB$abstract
go:info.runtime/internal/atomic.(*Pointer[go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef]).CompareAndSwapNoWB$abstract -> go:info.*go.shape.310da7890f312c3e9e77825750bad066709f9dcd04a3cf1be91d69e56d19c9ef
go:info.runtime.(*randomEnum).done$abstract -> go:info.*runtime.randomEnum
runtime.fatalpanic.func2·f -> runtime.fatalpanic.func2
runtime.freeStackSpans·f -> runtime.freeStackSpans
runtime.gcBgMarkWorker·f -> runtime.gcBgMarkWorker
runtime.gcBgMarkWorker -> go:string."GC worker init"
runtime.gcBgMarkWorker -> type:runtime.gcBgMarkWorkerNode
runtime.gcBgMarkWorker -> runtime.gcBgMarkWorker.func1·f
runtime.gcBgMarkWorker -> runtime.gcBgMarkWorker.func2
runtime.gcBgMarkWorker -> runtime.(*gcControllerState).markWorkerStop
runtime.gcBgMarkWorker -> go:string."runtime: p.gcMarkWorkerMode= "
runtime.gcBgMarkWorker -> go:string." work.nwait= "
runtime.gcBgMarkWorker -> go:string."work.nwait was > work.nproc"
runtime.gcBgMarkWorker -> go:string."gcBgMarkWorker: mode not set"
runtime.gcBgMarkWorker -> go:string."worker mode "
runtime.gcBgMarkWorker -> go:string."gcBgMarkWorker: blackening not enabled"
runtime.gcBgMarkWorker -> gclocals·a+eYhiuKSeQLzGI1ENJjKg==
runtime.gcBgMarkWorker.func2 -> runtime.runqdrain
runtime.gcBgMarkWorker.func2 -> go:string."gcBgMarkWorker: unexpected gcMarkWorkerMode"
runtime.gcBgMarkWorker.func2 -> gclocals·ARj0ZiCgYnc03+5wTwVRqw==
runtime.(*gcControllerState).markWorkerStop -> go:string."markWorkerStop: unknown mark worker mode"
type:runtime.gcBgMarkWorkerNode -> type:.namedata.*runtime.gcBgMarkWorkerNode-
type:runtime.gcBgMarkWorkerNode -> type:*runtime.gcBgMarkWorkerNode
 -> go:info.runtime.gcDrainMarkWorkerIdle$abstract
 -> go:info.runtime.gcDrainMarkWorkerFractional$abstract
 -> go:info.runtime.gcDrainMarkWorkerDedicated$abstract
 -> go:info.runtime.gcMarkWorkerMode
runtime.gcBgMarkWorker.func1·f -> runtime.gcBgMarkWorker.func1
runtime.gcControllerCommit·f -> runtime.gcControllerCommit
runtime.gcControllerCommit -> runtime.(*gcControllerState).commit
runtime.gcControllerCommit -> runtime.traceLocker.HeapGoal
runtime.gcControllerCommit -> runtime.gcPaceSweeper
runtime.gcControllerCommit -> runtime.gcPaceScavenger
runtime.(*gcControllerState).commit -> $f64.3fe8000000000000
runtime.(*gcControllerState).commit -> $f64.4010000000000000
runtime.(*gcControllerState).commit -> $f64.43e0000000000000
runtime.gcPaceScavenger -> $f64.3fee666666666666
runtime.gcMarkDone.func1·f -> runtime.gcMarkDone.func1
runtime.gcMarkTermination.func4·f -> runtime.gcMarkTermination.func4
runtime.gcMarkTermination.func4 -> runtime.gcMarkTermination.func4.1
runtime.gcMarkTermination.func5·f -> runtime.gcMarkTermination.func5
runtime.gcMarkTermination.func5 -> runtime.(*mheap).enableMetadataHugePages
runtime.(*mheap).enableMetadataHugePages -> runtime.(*pageAlloc).enableChunkHugePages
runtime.(*pageAlloc).enableChunkHugePages -> runtime.(*addrRanges).cloneInto
runtime.(*pageAlloc).enableChunkHugePages -> runtime.(*pageAlloc).enableChunkHugePages.stkobj
 -> go:info.runtime.addrRanges
runtime.gcResetMarkState.func1·f -> runtime.gcResetMarkState.func1
runtime.gcStart.func2·f -> runtime.gcStart.func2
runtime.gcStart.func2 -> runtime.finishsweep_m
runtime.finishsweep_m -> runtime.(*spanSet).reset
runtime.finishsweep_m -> runtime.(*scavengerState).wake
runtime.finishsweep_m -> runtime.nextMarkBitArenaEpoch
runtime.finishsweep_m -> go:string."active sweepers found at start of mark phase"
runtime.(*spanSet).reset -> go:string."fully empty unfreed span set block found in reset"
runtime.(*spanSet).reset -> go:string."span set block with unpopped elements found in reset"
runtime.(*spanSet).reset -> go:string."head = "
runtime.(*spanSet).reset -> go:string."attempt to clear non-empty span set"
 -> go:info.runtime.(*activeSweep).sweepers$abstract
 -> go:info.runtime.(*atomicHeadTailIndex).reset$abstract
runtime.gosched_m·f -> runtime.gosched_m
runtime.gosched_m -> runtime.goschedImpl
runtime.goschedImpl -> go:string."bad g status"
runtime.goschedImpl -> gclocals·zHkrXHBdB0rEHjLQ36odgQ==
runtime.goschedImpl -> gclocals·FfBTJeTdwm8yg7e+zJB7FA==
 -> go:info.runtime.traceLocker.GoPreempt$abstract
runtime.goschedguarded_m·f -> runtime.goschedguarded_m
runtime.goyield_m·f -> runtime.goyield_m
runtime.injectglist.func1·f -> runtime.injectglist.func1
runtime.markrootFreeGStacks·f -> runtime.markrootFreeGStacks
runtime.mspinning·f -> runtime.mspinning
runtime.osyield·f -> runtime.osyield
runtime.park_m·f -> runtime.park_m
runtime.park_m -> runtime.traceLocker.GoPark
runtime.park_m -> gclocals·0fglQhjx6s6qoAoZi+mFwA==
runtime.traceLocker.GoPark -> fmt.ScanState.Token.arginfo1
runtime.parkunlock_c·f -> runtime.parkunlock_c
runtime.pollFractionalWorkerExit·f -> runtime.pollFractionalWorkerExit
runtime.pollFractionalWorkerExit -> $f64.3ff3333333333333
runtime.pollWork·f -> runtime.pollWork
runtime.printCgoTraceback.func1·f -> runtime.printCgoTraceback.func1
runtime.recovery·f -> runtime.recovery
runtime.recovery -> type:runtime.savedOpenDeferState
runtime.recovery -> go:string."recover: "
runtime.recovery -> go:string." not in ["
runtime.recovery -> go:string."bad recovery"
runtime.recovery -> go:string."unexpected gp.param"
type:runtime.savedOpenDeferState -> type:.namedata.*runtime.savedOpenDeferState-
type:runtime.savedOpenDeferState -> type:*runtime.savedOpenDeferState
type:runtime.savedOpenDeferState -> type:.namedata.deferBitsOffset-
type:runtime.savedOpenDeferState -> type:.namedata.slotsOffset-
runtime.schedtrace.func1·f -> runtime.schedtrace.func1
runtime.schedtrace.func1 -> go:string."  G"
runtime.schedtrace.func1 -> go:string.") m="
runtime.schedtrace.func1 -> go:string." lockedm="
runtime.sweepone.func1·f -> runtime.sweepone.func1
runtime.sweepone.func1 -> runtime.printScavTrace
runtime.printScavTrace -> go:string."scav "
runtime.printScavTrace -> go:string." KiB work (bg), "
runtime.printScavTrace -> go:string." KiB work (eager), "
runtime.printScavTrace -> go:string." KiB now, "
runtime.printScavTrace -> go:string."% util"
runtime.printScavTrace -> go:string." [controller reset]"
runtime.wbBufFlush.func1·f -> runtime.wbBufFlush.func1
runtime.wirep.func1·f -> runtime.wirep.func1
runtime.wirep.func1 -> go:string."wirep: already in go"
runtime.mstart -> runtime.mstart0
runtime.mstart -> runtime.mstart.args_stackmap
runtime.mstart -> runtime.mstart.arginfo0
runtime.mstart0 -> runtime.mstart0
runtime.mstart0 -> runtime.mstart1
runtime.mstart0 -> runtime.mexit
runtime.mstart1 -> runtime.asminit
runtime.mstart1 -> runtime.minit
runtime.mstart1 -> runtime.m0
runtime.mstart1 -> runtime.mstartm0
runtime.mstart1 -> go:string."bad runtime·mstart"
runtime.minit -> runtime.minitSignalStack
runtime.minit -> runtime.minitSignalMask
runtime.minit -> runtime.pthread_self
runtime.mstartm0 -> runtime.newextram
runtime.mstartm0 -> runtime.initsig
runtime.mexit -> runtime.sigblock
runtime.mexit -> runtime.unminitSignals
runtime.mexit -> runtime.ncgocall
runtime.mexit -> runtime.exitThread
runtime.mexit -> go:string."m not found in allm"
runtime.mexit -> go:string."locked m0 woke up"
runtime.newextram -> runtime.extraMWaiters
runtime.newextram -> runtime.oneNewExtraM
runtime.oneNewExtraM -> runtime.addExtraM
runtime.addExtraM -> runtime.lockextra
runtime.addExtraM -> runtime.extraM
runtime.initsig -> runtime.signalsOK
runtime.initsig -> runtime.fwdSig
runtime.initsig -> runtime.setsigstack
runtime.sigblock -> runtime.sigsetAllExiting
runtime.minitSignalStack -> runtime.sigaltstack
runtime.minitSignalStack -> runtime.signalstack
runtime.minitSignalStack -> gclocals·bZa5j5FSTN4B4hKDzNgv3w==
runtime.minitSignalStack -> runtime.minitSignalStack.stkobj
runtime.unminitSignals -> gclocals·h9/3ZXR9C8aF0T5QhErdzQ==
runtime.unminitSignals -> runtime.freeUserArenaChunk.stkobj
runtime.pthread_self -> runtime.pthread_self_trampoline
runtime.sigaltstack -> runtime.sigaltstack_trampoline
runtime.exitThread -> go:string."exitThread"
 -> go:info.runtime.m
 -> go:info.runtime/internal/atomic.Uintptr
 -> go:info.runtime.unminit$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).Swap$abstract
 -> go:info.runtime.osyield_no_g$abstract
 -> go:info.runtime.unlockextra$abstract
 -> go:info.runtime.getsig$abstract
 -> go:info.runtime.sigInstallGoHandler$abstract
 -> go:info.runtime.sigInitIgnored$abstract
 -> go:info.runtime.stackt
 -> go:info.runtime.setGsignalStack$abstract
 -> go:info.runtime.blockableSig$abstract
 -> go:info.runtime.sigdelset$abstract
 -> go:info.runtime.restoreGsignalStack$abstract
 -> go:info.*runtime.stack
 -> go:info.runtime.setSignalstackSP$abstract
 -> go:info.*runtime.stackt
go:info.runtime.sigInstallGoHandler$abstract -> go:info.*runtime.sigTabT
go:info.runtime.setGsignalStack$abstract -> go:info.*runtime.gsignalStack
runtime.asminit -> runtime.asminit.args_stackmap
runtime.asminit -> runtime.asminit.arginfo0
runtime.gogo -> gogo
runtime.gogo -> runtime.gogo.args_stackmap
runtime.gogo -> runtime.gogo.arginfo0
runtime.mcall -> runtime.badmcall
runtime.mcall -> runtime.badmcall2
runtime.badmcall -> runtime.badmcall
runtime.badmcall -> go:string."runtime: mcall called on m->g0 stack"
runtime.badmcall2 -> runtime.badmcall2
runtime.badmcall2 -> go:string."runtime: mcall function returned"
runtime.systemstack -> gosave_systemstack_switch
runtime.systemstack -> runtime.badsystemstack
runtime.systemstack -> runtime.systemstack.args_stackmap
runtime.systemstack -> runtime.systemstack.arginfo0
gosave_systemstack_switch -> runtime.systemstack_switch
gosave_systemstack_switch -> runtime.abort
runtime.badsystemstack -> runtime.badsystemstack
runtime.badsystemstack -> go:string."fatal: systemstack called from unexpected goroutine"
runtime.systemstack_switch -> runtime.systemstack_switch.args_stackmap
runtime.systemstack_switch -> runtime.systemstack_switch.arginfo0
runtime.morestack -> runtime.badmorestackg0
runtime.morestack -> runtime.badmorestackgsignal
runtime.morestack -> runtime.newstack
runtime.morestack -> runtime.morestack.args_stackmap
runtime.morestack -> runtime.morestack.arginfo0
runtime.badmorestackg0 -> runtime.badmorestackg0
runtime.badmorestackg0 -> runtime.badmorestackg0.func1
runtime.badmorestackg0 -> runtime.switchToCrashStack
runtime.badmorestackg0.func1 -> go:string."runtime: morestack on g0, stack ["
runtime.badmorestackg0.func1 -> go:string."], sp="
runtime.badmorestackg0.func1 -> go:string.", called from\n"
runtime.badmorestackg0.func1 -> go:string."morestack on g0"
runtime.switchToCrashStack -> runtime.crashingG
runtime.switchToCrashStack -> runtime.switchToCrashStack0
runtime.switchToCrashStack -> go:string."fatal: recursive switchToCrashStack\n"
runtime.switchToCrashStack -> go:string."fatal: concurrent switchToCrashStack\n"
 -> go:info.runtime/internal/atomic.Pointer[runtime.g]
runtime.badmorestackgsignal -> runtime.badmorestackgsignal
runtime.badmorestackgsignal -> go:string."fatal: morestack on gsignal\n"
runtime.newstack -> runtime.newstack
runtime.newstack -> go:string."runtime: newstack sp="
runtime.newstack -> go:string." stack=["
runtime.newstack -> go:string."]\n\tmorebuf={pc:"
runtime.newstack -> go:string." sp:"
runtime.newstack -> go:string." lr:"
runtime.newstack -> go:string."}\n\tsched={pc:"
runtime.newstack -> go:string." ctxt:"
runtime.newstack -> runtime.preemptPark
runtime.newstack -> runtime.funcMaxSPDelta
runtime.newstack -> runtime.maxstackceiling
runtime.newstack -> go:string."runtime: goroutine stack exceeds "
runtime.newstack -> go:string."-byte limit\n"
runtime.newstack -> go:string."runtime: sp="
runtime.newstack -> go:string."stack overflow"
runtime.newstack -> go:string."runtime: g is running but p is not"
runtime.newstack -> go:string."runtime: preempt g0"
runtime.newstack -> go:string.", gp->status="
runtime.newstack -> go:string."\n "
runtime.newstack -> go:string."runtime: split stack overflow: "
runtime.newstack -> go:string." < "
runtime.newstack -> go:string."runtime: split stack overflow"
runtime.newstack -> go:string."missing stack in newstack"
runtime.newstack -> go:string."(unknown)"
runtime.newstack -> go:string."runtime: newstack at "
runtime.newstack -> go:string."runtime: stack split at bad time"
runtime.newstack -> go:string."runtime: newstack called from g="
runtime.newstack -> go:string."\n\tm="
runtime.newstack -> go:string." m->curg="
runtime.newstack -> go:string." m->g0="
runtime.newstack -> go:string." m->gsignal="
runtime.newstack -> go:string."runtime: wrong goroutine in newstack"
runtime.newstack -> go:string."stack growth after fork"
runtime.newstack -> gclocals·5ycp9muDlH1Gn4j7Ub8szg==
runtime.newstack -> gclocals·LzJ8Vk6/2aJB5AH54urlhg==
runtime.preemptPark -> runtime.casGToPreemptScan
runtime.preemptPark -> go:string."runtime: unexpected SPWRITE function "
runtime.preemptPark -> go:string." in async preempt\n"
runtime.preemptPark -> go:string."preempt SPWRITE"
runtime.preemptPark -> go:string."preempt at unknown pc"
runtime.preemptPark -> gclocals·H+g+tB+N1wvBnXJbd/b6CA==
runtime.preemptPark -> gclocals·PG3pHXi4mxXlEBM9wv/QrQ==
 -> go:info.runtime.gobuf
 -> go:info.runtime.gopreempt_m$abstract
runtime.switchToCrashStack0 -> runtime.gcrash
 -> go:info.runtime.g
runtime.morestack_noctxt -> runtime.morestack_noctxt.args_stackmap
runtime.morestack_noctxt -> runtime.morestack_noctxt.arginfo0
runtime.procyield -> runtime.procyield.args_stackmap
runtime.procyield -> runtime.procyield.arginfo0
runtime.asmcgocall_no_g -> runtime.asmcgocall_no_g.args_stackmap
runtime.asmcgocall_no_g -> runtime.asmcgocall_no_g.arginfo0
runtime.asmcgocall -> runtime.asmcgocall_landingpad
runtime.asmcgocall -> runtime.asmcgocall.args_stackmap
runtime.asmcgocall -> runtime.asmcgocall.arginfo0
runtime.asmcgocall_landingpad -> runtime.asmcgocall_landingpad.args_stackmap
runtime.asmcgocall_landingpad -> runtime.asmcgocall_landingpad.arginfo0
runtime.abort -> runtime.abort.args_stackmap
runtime.abort -> runtime.abort.arginfo0
runtime.cputicks -> runtime.cputicks.args_stackmap
runtime.cputicks -> runtime.cputicks.arginfo0
runtime.memhash -> runtime.useAeshash
runtime.memhash -> aeshashbody
runtime.memhash -> runtime.memhashFallback
runtime.memhashFallback -> runtime.hashkey
 -> go:info.[4]uintptr
 -> go:info.runtime.r8$abstract
 -> go:info.runtime.r4$abstract
 -> go:info.runtime.readUnaligned32$abstract
 -> go:info.runtime.mix$abstract
aeshashbody -> runtime.aeskeysched
aeshashbody -> masks
aeshashbody -> shifts
 -> go:info.[128]uint8
runtime.memhash32 -> runtime.memhash32Fallback
runtime.goexit -> runtime.goexit1
runtime.goexit -> runtime.goexit.args_stackmap
runtime.goexit -> runtime.goexit.arginfo0
runtime.goexit1 -> runtime.goexit1
runtime.goexit1 -> runtime.traceLocker.GoEnd
runtime.goexit1 -> runtime.goexit0·f
runtime.goexit0·f -> runtime.goexit0
runtime.goexit0 -> runtime.gdestroy
runtime.gdestroy -> runtime.gfput
runtime.gdestroy -> go:string."invalid m->lockedInt = "
runtime.gdestroy -> go:string."internal lockOSThread error"
runtime.gfput -> go:string."gfput: bad status (not Gdead)"
runtime.sigpanic0 -> runtime.sigpanic
runtime.sigpanic0 -> runtime.sigpanic0.args_stackmap
runtime.sigpanic0 -> runtime.sigpanic0.arginfo0
runtime.sigpanic -> runtime.canpanic
runtime.sigpanic -> go:string."floating point error"
runtime.sigpanic -> runtime.floatError
runtime.sigpanic -> go:string."integer overflow"
runtime.sigpanic -> runtime.overflowError
runtime.sigpanic -> go:string."invalid memory address or nil pointer dereference"
runtime.sigpanic -> type:runtime.errorAddressString <UsedInIface>
runtime.sigpanic -> runtime.convT
runtime.sigpanic -> go:string."unexpected fault address "
runtime.sigpanic -> go:string."fault"
runtime.sigpanic -> runtime.memoryError
runtime.sigpanic -> go:string."accessed data from freed user arena "
runtime.sigpanic -> go:string."unexpected signal value"
runtime.sigpanic -> go:string."unexpected signal during runtime execution"
runtime.convT -> runtime.typedmemmove
type:runtime.errorAddressString <UsedInIface> -> type:.eqfunc.runtime.errorAddressString
type:runtime.errorAddressString <UsedInIface> -> type:.namedata.*runtime.errorAddressString-
type:runtime.errorAddressString <UsedInIface> -> type:*runtime.errorAddressString <UsedInIface>
type:runtime.errorAddressString <UsedInIface> -> type:.namedata.msg-
type:runtime.errorAddressString <UsedInIface> -> type:.namedata.Addr.
runtime.overflowError -> runtime..stmp_65
runtime.floatError -> runtime..stmp_66
runtime.memoryError -> runtime..stmp_67
 -> go:info.runtime.panicfloat$abstract
 -> go:info.runtime.panicoverflow$abstract
 -> go:info.runtime.panicmemAddr$abstract
 -> go:info.runtime.panicmem$abstract
 -> go:info.runtime.inUserArenaChunk$abstract
type:.eqfunc.runtime.errorAddressString -> type:.eq.runtime.errorAddressString
 -> go:info.*runtime.errorAddressString
runtime.gcWriteBarrier1 -> gcWriteBarrier
gcWriteBarrier -> runtime.wbBufFlush
runtime.panicIndex -> runtime.goPanicIndex
runtime.goPanicIndex -> go:string."index out of range"
runtime.goPanicIndex -> type:runtime.boundsError <UsedInIface>
runtime.goPanicIndex -> runtime.convTnoptr
type:runtime.boundsError <UsedInIface> -> type:.eqfunc.runtime.boundsError
type:runtime.boundsError <UsedInIface> -> type:.namedata.*runtime.boundsError-
type:runtime.boundsError <UsedInIface> -> type:*runtime.boundsError <UsedInIface>
type:runtime.boundsError <UsedInIface> -> type:.namedata.y-
type:runtime.boundsError <UsedInIface> -> type:.namedata.signed-
type:runtime.boundsError <UsedInIface> -> type:.namedata.code-
type:runtime.boundsError <UsedInIface> -> type:runtime.boundsErrorCode <UsedInIface>
type:runtime.boundsErrorCode <UsedInIface> -> type:.namedata.*runtime.boundsErrorCode-
type:runtime.boundsErrorCode <UsedInIface> -> type:*runtime.boundsErrorCode <UsedInIface>
type:.eqfunc.runtime.boundsError -> type:.eq.runtime.boundsError
 -> go:info.*runtime.boundsError
runtime.panicIndexU -> runtime.goPanicIndexU
runtime.panicSliceAlen -> runtime.goPanicSliceAlen
runtime.goPanicSliceAlen -> go:string."slice bounds out of range"
runtime.panicSliceAlenU -> runtime.goPanicSliceAlenU
runtime.panicSliceAcap -> runtime.goPanicSliceAcap
runtime.panicSliceAcapU -> runtime.goPanicSliceAcapU
runtime.panicSliceB -> runtime.goPanicSliceB
runtime.panicSliceBU -> runtime.goPanicSliceBU
runtime.panicSlice3Alen -> runtime.goPanicSlice3Alen
runtime.memmove -> runtime.useAVXmemmove
runtime.asyncPreempt -> runtime.asyncPreempt2
runtime.asyncPreempt -> runtime.asyncPreempt.args_stackmap
runtime.asyncPreempt -> runtime.asyncPreempt.arginfo0
runtime.asyncPreempt2 -> runtime.asyncPreempt2
runtime.asyncPreempt2 -> runtime.preemptPark·f
runtime.asyncPreempt2 -> runtime.gopreempt_m·f
runtime.gopreempt_m·f -> runtime.gopreempt_m
_rt0_amd64_darwin -> _rt0_amd64
_rt0_amd64 -> runtime.rt0_go
runtime.rt0_go -> runtime.g0
runtime.rt0_go -> runtime.isIntel
runtime.rt0_go -> runtime.processorVersionInfo
runtime.rt0_go -> _cgo_init
runtime.rt0_go -> setg_gcc
runtime.rt0_go -> runtime.settls
runtime.rt0_go -> runtime.check
runtime.rt0_go -> runtime.args
runtime.rt0_go -> runtime.osinit
runtime.rt0_go -> runtime.schedinit
runtime.rt0_go -> runtime.mainPC
runtime.rt0_go -> runtime.newproc
runtime.rt0_go -> bad_cpu_msg
runtime.rt0_go -> runtime.write
runtime.rt0_go -> runtime.debugCallV2
runtime.rt0_go -> runtime.rt0_go.args_stackmap
runtime.rt0_go -> runtime.rt0_go.arginfo0
runtime.osinit -> runtime.osinit
runtime.osinit -> runtime.getncpu
runtime.osinit -> runtime.getPageSize
runtime.osinit -> runtime.osinit_hack
runtime.getncpu -> runtime.sysctl
runtime.osinit_hack -> runtime.osinit_hack_trampoline
runtime.sysctl -> runtime.sysctl_trampoline
runtime.sysctl -> gclocals·13TDtuL9rVh9U6NSBAHk4w==
runtime.sysctl -> runtime.sysctl.arginfo0
 -> go:info.[2]uint32
runtime.schedinit -> runtime.schedinit
runtime.schedinit -> runtime.ticks
runtime.schedinit -> runtime.(*ticksType).init
runtime.schedinit -> runtime.moduledataverify1
runtime.schedinit -> runtime.mallocinit
runtime.schedinit -> runtime.getGodebugEarly
runtime.schedinit -> internal/cpu.DebugOptions
runtime.schedinit -> internal/cpu.Initialize
runtime.schedinit -> runtime.x86HasSSE41
runtime.schedinit -> runtime.x86HasFMA
runtime.schedinit -> runtime.randinit
runtime.schedinit -> runtime.alginit
runtime.schedinit -> runtime.modulesinit
runtime.schedinit -> runtime.typelinksinit
runtime.schedinit -> runtime.itabsinit
runtime.schedinit -> runtime.stkobjinit
runtime.schedinit -> runtime.goargs
runtime.schedinit -> runtime.goenvs_unix
runtime.schedinit -> runtime.secure
runtime.schedinit -> runtime.checkfds
runtime.schedinit -> runtime.parsedebugvars
runtime.schedinit -> runtime.gcinit
runtime.schedinit -> runtime.disableMemoryProfiling
runtime.schedinit -> runtime.gogetenv
runtime.schedinit -> runtime.atoi64
runtime.schedinit -> runtime.buildVersion
runtime.schedinit -> runtime.modinfo
runtime.schedinit -> go:string."unknown runnable goroutine during bootstrap"
runtime.gogetenv -> runtime.envs
runtime.gogetenv -> go:string."getenv before env init"
runtime.checkfds -> runtime.open
runtime.checkfds -> go:string."runtime: opened unexpected file descriptor "
runtime.checkfds -> go:string." when attempting to open "
runtime.checkfds -> go:string."cannot open standard fds"
runtime.checkfds -> go:string."runtime: standard file descriptor "
runtime.checkfds -> go:string." closed, unable to open /dev/null, errno="
runtime.checkfds -> go:string."runtime: unexpected error while checking standard file descriptor "
runtime.checkfds -> go:string.", errno="
runtime.mallocinit -> runtime.(*mheap).init
runtime.mallocinit -> go:string."min size of malloc header is not a size class boundary"
runtime.mallocinit -> runtime.physHugePageShift
runtime.mallocinit -> go:string."system huge page size ("
runtime.mallocinit -> go:string.") must be a power of 2\n"
runtime.mallocinit -> go:string."bad system huge page size"
runtime.mallocinit -> go:string."system page size ("
runtime.mallocinit -> go:string."bad system page size"
runtime.mallocinit -> go:string.") is smaller than minimum page size ("
runtime.mallocinit -> go:string.") is larger than maximum page size ("
runtime.mallocinit -> go:string."failed to get system page size"
runtime.mallocinit -> go:string."bad TinySizeClass"
runtime.gcinit -> runtime.readGOGC
runtime.gcinit -> runtime.readGOMEMLIMIT
runtime.gcinit -> runtime.(*gcControllerState).init
runtime.readGOGC -> go:string."GOGC"
runtime.readGOMEMLIMIT -> go:string."GOMEMLIMIT"
runtime.readGOMEMLIMIT -> runtime.parseByteCount
runtime.readGOMEMLIMIT -> go:string."GOMEMLIMIT="
runtime.readGOMEMLIMIT -> go:string."malformed GOMEMLIMIT; see `go doc runtime/debug.SetMemoryLimit`"
runtime.(*mheap).init -> runtime.recordspan·f
runtime.(*mheap).init -> runtime.(*fixalloc).init
runtime.(*mheap).init -> runtime.(*pageAlloc).init
runtime.(*fixalloc).init -> go:string."runtime: fixalloc size too large"
runtime.(*pageAlloc).init -> runtime.(*addrRanges).init
runtime.(*pageAlloc).init -> runtime.(*pageAlloc).sysInit
runtime.(*pageAlloc).init -> runtime.(*scavengeIndex).init
runtime.(*pageAlloc).init -> go:string."runtime: root level max pages = "
runtime.(*pageAlloc).init -> go:string."runtime: summary max pages = "
runtime.(*pageAlloc).init -> go:string."root level max pages doesn't fit in summary"
runtime.(*pageAlloc).init -> gclocals·YtH/kLGDroq4A+wxhTZuuQ==
runtime.(*scavengeIndex).init -> runtime.(*scavengeIndex).sysInit
runtime.(*pageAlloc).sysInit -> go:string."failed to reserve page summary memory"
runtime.getGodebugEarly -> runtime.argc
runtime.getGodebugEarly -> runtime.argv
runtime.getGodebugEarly -> runtime.gostring
runtime.randinit -> go:string."randinit twice"
runtime.randinit -> runtime.startupRand
runtime.randinit -> runtime.readRandom
runtime.randinit -> runtime.readRandomFailed
runtime.randinit -> runtime.readTimeRandom
runtime.randinit -> internal/chacha8rand.(*State).Init
runtime.readRandom -> runtime.urandom_dev
runtime.readRandom -> runtime.closefd
runtime.goargs -> runtime.argslice
runtime.parsedebugvars -> go:string."GODEBUG"
runtime.parsedebugvars -> runtime.godebugEnv
runtime.parsedebugvars -> runtime/internal/atomic.storePointer
runtime.parsedebugvars -> runtime.dbgvars
runtime.parsedebugvars -> runtime.godebugDefault
runtime.parsedebugvars -> runtime.parsegodebug
runtime.parsedebugvars -> go:string."GOTRACEBACK"
runtime.parsedebugvars -> runtime/debug.SetTraceback
runtime.parsedebugvars -> runtime.traceback_env
runtime.parsegodebug -> type:map[string]bool
runtime.parsegodebug -> runtime.mapaccess1_faststr
runtime.parsegodebug -> runtime.mapassign_faststr
runtime.parsegodebug -> go:string..gostring.102.Z2wKHf121bTZsT/ZCqMFPg==
runtime.parsegodebug -> gclocals·JmWCitoALOgbDPUdmo+yGA==
runtime.parsegodebug -> gclocals·REDuWVJv+WSlmvdByJGLtw==
runtime.mapaccess1_faststr -> gclocals·kE0DYMR7pGVKnbvkyXbL9A==
runtime.mapaccess1_faststr -> gclocals·HSr/0yBW3jmC+pu9zHAZOw==
runtime.mapaccess1_faststr -> reflect.mapassign_faststr.stkobj
runtime.mapassign_faststr -> go:string."concurrent map writes"
runtime.mapassign_faststr -> runtime.hashGrow
runtime.mapassign_faststr -> runtime.growWork_faststr
runtime.mapassign_faststr -> runtime.(*hmap).newoverflow
runtime.mapassign_faststr -> type:runtime.plainError <UsedInIface>
runtime.mapassign_faststr -> runtime..stmp_116
runtime.mapassign_faststr -> gclocals·/AoBRpNiFk8E4ZCqns7SMQ==
runtime.mapassign_faststr -> gclocals·KCpOdE6Ml8xmXI+98ErMnQ==
runtime.(*hmap).newoverflow -> runtime.(*hmap).incrnoverflow
runtime.(*hmap).newoverflow -> type:runtime.mapextra
runtime.(*hmap).newoverflow -> type:[]*runtime.bmap
runtime.(*hmap).newoverflow -> type:*runtime.bmap
runtime.(*hmap).newoverflow -> gclocals·PrmaJQWdGXnYgjD8uSxfeA==
runtime.hashGrow -> runtime.makeBucketArray
runtime.hashGrow -> go:string."oldoverflow is not nil"
runtime.hashGrow -> gclocals·z1fTi5Q9ktmU9zsaMld+eg==
runtime.makeBucketArray -> runtime.newarray
runtime.makeBucketArray -> gclocals·3iNW+PLvQFVHQmli+gLO8Q==
runtime.newarray -> runtime..stmp_104
runtime.growWork_faststr -> runtime.evacuate_faststr
runtime.evacuate_faststr -> runtime.advanceEvacuationMark
runtime.evacuate_faststr -> go:string."bad map state"
runtime.evacuate_faststr -> gclocals·EVKWQHHPFP6MuLm4GfcARA==
runtime.evacuate_faststr -> gclocals·4EXtkmf6X0WqmqO1rZhscg==
runtime.evacuate_faststr -> runtime.evacuate_fast32.stkobj
runtime.secure -> runtime.issetugid
runtime.secure -> go:string."GOTRACEBACK="
runtime.secure -> go:string."GOTRACEBACK=none"
runtime.stkobjinit -> type:internal/abi.RegArgs <UsedInIface>
runtime.stkobjinit -> go:string."methodValueCallFrameObjs is not in a module"
runtime.stkobjinit -> go:string."abiRegArgsType needs GC Prog, update methodValueCallFrameObjs"
runtime.stkobjinit -> gclocals·Unomu+3ADQ9kCzfadpasnQ==
runtime.stkobjinit -> runtime.stkobjinit.stkobj
runtime.modulesinit -> type:[]*runtime.moduledata
runtime.modulesinit -> type:*runtime.moduledata
runtime.modulesinit -> runtime.progToPointerMask
runtime.progToPointerMask -> go:string."progToPointerMask: overflow"
runtime.moduledataverify1 -> go:string."end"
runtime.moduledataverify1 -> go:string."function symbol table not sorted by PC offset: "
runtime.moduledataverify1 -> go:string." > "
runtime.moduledataverify1 -> go:string." , plugin: "
runtime.moduledataverify1 -> go:string."abi mismatch detected between "
runtime.moduledataverify1 -> go:string."abi mismatch"
runtime.moduledataverify1 -> go:string."minpc= "
runtime.moduledataverify1 -> go:string." min= "
runtime.moduledataverify1 -> go:string." maxpc= "
runtime.moduledataverify1 -> go:string." max= "
runtime.moduledataverify1 -> go:string."minpc or maxpc invalid"
runtime.moduledataverify1 -> go:string."\t "
runtime.moduledataverify1 -> go:string."runtime: pcHeader: magic= "
runtime.moduledataverify1 -> go:string." pad1= "
runtime.moduledataverify1 -> go:string." pad2= "
runtime.moduledataverify1 -> go:string." minLC= "
runtime.moduledataverify1 -> go:string." ptrSize= "
runtime.moduledataverify1 -> go:string." pcHeader.textStart= "
runtime.moduledataverify1 -> go:string." text= "
runtime.moduledataverify1 -> go:string." pluginpath= "
runtime.moduledataverify1 -> go:string."invalid function symbol table"
runtime.moduledataverify1 -> gclocals·0hXk2klAu81xRzPs/ntOeQ==
runtime.closefd -> runtime.close_trampoline
runtime.open -> runtime.open_trampoline
runtime.issetugid -> runtime.issetugid_trampoline
runtime.typelinksinit -> type:map[uint32][]*internal/abi.Type
runtime.typelinksinit -> runtime.makemap
runtime.typelinksinit -> runtime.pinnedTypemaps
runtime.typelinksinit -> runtime.mapassign_fast32
runtime.typelinksinit -> runtime.rand32
runtime.typelinksinit -> runtime.typesEqual
runtime.typelinksinit -> gclocals·JdoRESan+7rkg7O3ArpiaA==
runtime.typelinksinit -> runtime.typelinksinit.stkobj
runtime.makemap -> type:runtime.hmap
runtime.makemap -> gclocals·L5e+TMyL/60VlivqH3Fglw==
runtime.makemap -> gclocals·rmCAgMShaSZdWuXuIZGHzA==
runtime.mapassign_fast32 -> runtime.growWork_fast32
runtime.growWork_fast32 -> runtime.evacuate_fast32
runtime.typesEqual -> type:map[runtime._typePair]struct {}
runtime.typesEqual -> runtime.mapaccess2
runtime.typesEqual -> runtime.mapassign
runtime.typesEqual -> runtime.typesEqual.jump18
runtime.typesEqual -> runtime.typesEqual.jump34
runtime.typesEqual -> runtime.typesEqual.jump63
runtime.typesEqual -> internal/abi.Name.Tag
runtime.typesEqual -> runtime.panicSlice3C
runtime.typesEqual -> go:string."runtime: impossible type kind "
runtime.typesEqual -> go:string."runtime: impossible type kind"
runtime.typesEqual -> gclocals·Izq6UId3cq9C+RvP0V3U7Q==
runtime.typesEqual -> gclocals·c5cw4VqkKl8ayR1+baHc0Q==
runtime.mapaccess2 -> runtime.mapKeyError2
runtime.mapaccess2 -> gclocals·VhjwhTNxaUitnShkCBZbRg==
runtime.mapKeyError2 -> go:string."hash of unhashable type "
runtime.mapKeyError2 -> internal/abi.Name.IsBlank
runtime.mapKeyError2 -> gclocals·wfM1gsD/oVI7myY6tqtXpg==
runtime.mapKeyError2 -> gclocals·gfTQPta6IFvmtuaX/g8AkQ==
runtime.mapassign -> runtime.growWork
runtime.mapassign -> gclocals·JZJEIfWkIBgL1snEp5XInQ==
runtime.mapassign -> gclocals·87Zuq3NOdIG7OPJSDVf+EQ==
runtime.growWork -> runtime.evacuate
runtime.evacuate -> gclocals·ecGZfvfNO3pXETkBJiIa7g==
runtime.evacuate -> gclocals·+8FZ94Iu2mJgtoiCITc5Tw==
runtime.evacuate -> runtime.evacuate.stkobj
type:*runtime.moduledata -> type:.namedata.*runtime.moduledata-
type:*runtime.moduledata -> type:runtime.moduledata
type:*runtime.moduledata -> type:.namedata.funcName-
type:*runtime.moduledata -> type:.namedata.textAddr-
type:*runtime.moduledata -> type:.namedata.textOff-
type:runtime.moduledata -> runtime.gcbits.932401000092a4a4d000000000000000
type:runtime.moduledata -> type:.namedata.NotInHeap..embedded
type:runtime.moduledata -> type:.namedata.pcHeader-
type:runtime.moduledata -> type:*runtime.pcHeader
type:runtime.moduledata -> type:.namedata.funcnametab-
type:runtime.moduledata -> type:.namedata.cutab-
type:runtime.moduledata -> type:[]uint32
type:runtime.moduledata -> type:.namedata.filetab-
type:runtime.moduledata -> type:.namedata.pctab-
type:runtime.moduledata -> type:.namedata.pclntable-
type:runtime.moduledata -> type:.namedata.ftab-
type:runtime.moduledata -> type:[]runtime.functab
type:runtime.moduledata -> type:.namedata.findfunctab-
type:runtime.moduledata -> type:.namedata.minpc-
type:runtime.moduledata -> type:.namedata.maxpc-
type:runtime.moduledata -> type:.namedata.text-
type:runtime.moduledata -> type:.namedata.etext-
type:runtime.moduledata -> type:.namedata.noptrdata-
type:runtime.moduledata -> type:.namedata.enoptrdata-
type:runtime.moduledata -> type:.namedata.data-
type:runtime.moduledata -> type:.namedata.edata-
type:runtime.moduledata -> type:.namedata.bss-
type:runtime.moduledata -> type:.namedata.ebss-
type:runtime.moduledata -> type:.namedata.noptrbss-
type:runtime.moduledata -> type:.namedata.enoptrbss-
type:runtime.moduledata -> type:.namedata.covctrs-
type:runtime.moduledata -> type:.namedata.ecovctrs-
type:runtime.moduledata -> type:.namedata.gcdata-
type:runtime.moduledata -> type:.namedata.gcbss-
type:runtime.moduledata -> type:.namedata.types-
type:runtime.moduledata -> type:.namedata.etypes-
type:runtime.moduledata -> type:.namedata.rodata-
type:runtime.moduledata -> type:.namedata.gofunc-
type:runtime.moduledata -> type:.namedata.textsectmap-
type:runtime.moduledata -> type:[]runtime.textsect
type:runtime.moduledata -> type:.namedata.typelinks-
type:runtime.moduledata -> type:.namedata.itablinks-
type:runtime.moduledata -> type:[]*runtime.itab
type:runtime.moduledata -> type:.namedata.ptab-
type:runtime.moduledata -> type:[]runtime.ptabEntry
type:runtime.moduledata -> type:.namedata.pluginpath-
type:runtime.moduledata -> type:.namedata.pkghashes-
type:runtime.moduledata -> type:[]runtime.modulehash
type:runtime.moduledata -> type:.namedata.inittasks-
type:runtime.moduledata -> type:[]*runtime.initTask
type:runtime.moduledata -> type:.namedata.modulename-
type:runtime.moduledata -> type:.namedata.modulehashes-
type:runtime.moduledata -> type:.namedata.hasmain-
type:runtime.moduledata -> type:.namedata.gcdatamask-
type:runtime.moduledata -> type:runtime.bitvector
type:runtime.moduledata -> type:.namedata.gcbssmask-
type:runtime.moduledata -> type:.namedata.typemap-
type:runtime.moduledata -> type:.namedata.bad-
type:*runtime.pcHeader -> type:.namedata.*runtime.pcHeader-
type:*runtime.pcHeader -> type:runtime.pcHeader
type:runtime.pcHeader -> type:.eqfunc72
type:runtime.pcHeader -> type:.namedata.magic-
type:runtime.pcHeader -> type:.namedata.pad1-
type:runtime.pcHeader -> type:.namedata.pad2-
type:runtime.pcHeader -> type:.namedata.minLC-
type:runtime.pcHeader -> type:.namedata.ptrSize-
type:runtime.pcHeader -> type:.namedata.nfunc-
type:runtime.pcHeader -> type:.namedata.nfiles-
type:runtime.pcHeader -> type:.namedata.textStart-
type:runtime.pcHeader -> type:.namedata.funcnameOffset-
type:runtime.pcHeader -> type:.namedata.cuOffset-
type:runtime.pcHeader -> type:.namedata.filetabOffset-
type:runtime.pcHeader -> type:.namedata.pctabOffset-
type:runtime.pcHeader -> type:.namedata.pclnOffset-
type:runtime.bitvector -> type:.eqfunc.runtime.bitvector
type:runtime.bitvector -> type:.namedata.*runtime.bitvector-
type:runtime.bitvector -> type:*runtime.bitvector
type:runtime.bitvector -> type:.namedata.bytedata-
type:*runtime.bitvector -> type:.namedata.ptrbit-
type:*runtime.bmap -> type:.namedata.*runtime.bmap-
type:*runtime.bmap -> type:runtime.bmap
type:*runtime.bmap -> type:.namedata.setoverflow-
type:runtime.bmap -> type:.namedata.tophash-
type:runtime.mapextra -> runtime.gcbits.0700000000000000
type:runtime.mapextra -> type:.namedata.*runtime.mapextra-
type:runtime.mapextra -> type:*runtime.mapextra
type:runtime.mapextra -> type:*[]*runtime.bmap
type:runtime.mapextra -> type:.namedata.oldoverflow-
type:runtime.mapextra -> type:.namedata.nextOverflow-
type:runtime.hmap -> type:.namedata.*runtime.hmap-
type:runtime.hmap -> type:*runtime.hmap
type:runtime.hmap -> type:.namedata.flags-
type:runtime.hmap -> type:.namedata.B.
type:runtime.hmap -> type:.namedata.noverflow-
type:runtime.hmap -> type:.namedata.hash0-
type:runtime.hmap -> type:.namedata.buckets-
type:runtime.hmap -> type:.namedata.oldbuckets-
type:runtime.hmap -> type:.namedata.nevacuate-
type:runtime.hmap -> type:.namedata.extra-
type:*runtime.hmap -> type:.namedata.createOverflow-
type:*runtime.hmap -> type:.namedata.growing-
type:*runtime.hmap -> type:.namedata.incrnoverflow-
type:*runtime.hmap -> type:.namedata.newoverflow-
type:*runtime.hmap -> type:.namedata.noldbuckets-
type:*runtime.hmap -> type:.namedata.oldbucketmask-
type:*runtime.hmap -> type:.namedata.sameSizeGrow-
type:runtime.plainError <UsedInIface> -> type:.namedata.*runtime.plainError-
type:runtime.plainError <UsedInIface> -> type:*runtime.plainError <UsedInIface>
runtime.urandom_dev -> runtime..gobytes.2
 -> go:info.runtime.ticksType
 -> go:info.runtime/internal/atomic.Pointer[string]
 -> go:info.**uint8
runtime.dbgvars -> runtime..stmp_70
 -> go:info.[]*runtime.dbgVar
 -> go:info.[]map[internal/abi.TypeOff]*internal/abi.Type
runtime..stmp_70 -> runtime..stmp_71
runtime..stmp_70 -> runtime..stmp_72
runtime..stmp_70 -> runtime..stmp_73
runtime..stmp_70 -> runtime..stmp_74
runtime..stmp_70 -> runtime..stmp_75
runtime..stmp_70 -> runtime..stmp_76
runtime..stmp_70 -> runtime..stmp_77
runtime..stmp_70 -> runtime..stmp_78
runtime..stmp_70 -> runtime..stmp_79
runtime..stmp_70 -> runtime..stmp_80
runtime..stmp_70 -> runtime..stmp_81
runtime..stmp_70 -> runtime..stmp_82
runtime..stmp_70 -> runtime..stmp_83
runtime..stmp_70 -> runtime..stmp_84
runtime..stmp_70 -> runtime..stmp_85
runtime..stmp_70 -> runtime..stmp_86
runtime..stmp_70 -> runtime..stmp_87
runtime..stmp_70 -> runtime..stmp_88
runtime..stmp_70 -> runtime..stmp_89
runtime..stmp_70 -> runtime..stmp_90
runtime..stmp_70 -> runtime..stmp_91
runtime..stmp_70 -> runtime..stmp_92
runtime..stmp_70 -> runtime..stmp_93
runtime..stmp_70 -> runtime..stmp_94
runtime..stmp_70 -> runtime..stmp_95
runtime..stmp_70 -> runtime..stmp_96
runtime..stmp_71 -> go:string."allocfreetrace"
runtime..stmp_72 -> go:string."clobberfree"
runtime..stmp_73 -> go:string."cgocheck"
runtime..stmp_74 -> go:string."disablethp"
runtime..stmp_75 -> go:string."dontfreezetheworld"
runtime..stmp_76 -> go:string."efence"
runtime..stmp_77 -> go:string."gccheckmark"
runtime..stmp_78 -> go:string."gcpacertrace"
runtime..stmp_79 -> go:string."gcshrinkstackoff"
runtime..stmp_80 -> go:string."gcstoptheworld"
runtime..stmp_81 -> go:string."gctrace"
runtime..stmp_82 -> go:string."invalidptr"
runtime..stmp_83 -> go:string."madvdontneed"
runtime..stmp_84 -> go:string."runtimecontentionstacks"
runtime..stmp_85 -> go:string."sbrk"
runtime..stmp_86 -> go:string."scavtrace"
runtime..stmp_87 -> go:string."scheddetail"
runtime..stmp_88 -> go:string."schedtrace"
runtime..stmp_89 -> go:string."tracebackancestors"
runtime..stmp_90 -> go:string."asyncpreemptoff"
runtime..stmp_91 -> go:string."inittrace"
runtime..stmp_92 -> go:string."harddecommit"
runtime..stmp_93 -> go:string."adaptivestackstart"
runtime..stmp_94 -> go:string."tracefpunwindoff"
runtime..stmp_96 -> go:string."traceadvanceperiod"
 -> go:info.*runtime.eface
 -> go:info.*runtime.iface
 -> go:info.*internal/abi.ArrayType
 -> go:info.*internal/abi.StructType
 -> go:info.runtime.initAlgAES$abstract
 -> go:info.runtime.envKeyEqual$abstract
 -> go:info.runtime.(*bmap).setoverflow$abstract
 -> go:info.runtime.(*hmap).createOverflow$abstract
 -> go:info.runtime.overLoadFactor$abstract
 -> go:info.runtime.tophash$abstract
 -> go:info.runtime.mapKeyError$abstract
 -> go:info.internal/abi.(*MapType).HashMightPanic$abstract
 -> go:info.internal/abi.(*MapType).IndirectKey$abstract
 -> go:info.internal/abi.(*MapType).IndirectElem$abstract
 -> go:info.runtime.(*hmap).growing$abstract
 -> go:info.runtime.tooManyOverflowBuckets$abstract
 -> go:info.runtime.isEmpty$abstract
 -> go:info.internal/abi.(*MapType).NeedKeyUpdate$abstract
 -> go:info.runtime.(*hmap).oldbucketmask$abstract
 -> go:info.runtime.(*hmap).noldbuckets$abstract
 -> go:info.[2]runtime.evacDst
 -> go:info.internal/abi.(*MapType).ReflexiveKey$abstract
 -> go:info.runtime.bucketEvacuated$abstract
 -> go:info.func(unsafe.Pointer, unsafe.Pointer)
 -> go:info.runtime.(*gcControllerState).setGCPercent$abstract
 -> go:info.runtime/internal/atomic.(*Int32).Store$abstract
 -> go:info.runtime.(*gcControllerState).setMemoryLimit$abstract
 -> go:info.runtime.atoi32$abstract
 -> go:info.runtime.(*mcentral).init$abstract
 -> go:info.runtime.argv_index$abstract
 -> go:info.runtime.(*rwmutex).init$abstract
 -> go:info.runtime.moduledataverify$abstract
 -> go:info.runtime.stackinit$abstract
 -> go:info.runtime.(*mSpanList).init$abstract
 -> go:info.runtime.cpuinit$abstract
 -> go:info.runtime.sigsave$abstract
 -> go:info.runtime.goenvs$abstract
 -> go:info.*[32]uint8
 -> go:info.*runtime.ticksType
 -> go:info.*runtime.dbgVar
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract
 -> go:info.runtime/internal/atomic.(*UnsafePointer).Store$abstract
 -> go:info.map[string]bool
 -> go:info.runtime.atoi$abstract
 -> go:info.runtime.initSecureMode$abstract
 -> go:info.runtime.secureEnv$abstract
 -> go:info.runtime.(*gcControllerState).addGlobals$abstract
 -> go:info.*runtime.pcHeader
 -> go:info.runtime.modulehash
 -> go:info.map[uint32][]*internal/abi.Type
 -> go:info.[]*runtime.moduledata
 -> go:info.[]*internal/abi.Type
 -> go:info.map[internal/abi.TypeOff]*internal/abi.Type
 -> go:info.map[runtime._typePair]struct {}
 -> go:info.struct {}
 -> go:info.runtime._typePair
 -> go:info.*internal/abi.ChanType
 -> go:info.*internal/abi.FuncType
 -> go:info.*internal/abi.Imethod
 -> go:info.*internal/abi.SliceType
 -> go:info.internal/abi.(*FuncType).InSlice$abstract
 -> go:info.internal/abi.Name.IsEmbedded$abstract
 -> go:info.internal/abi.(*FuncType).OutSlice$abstract
 -> go:info.internal/abi.(*FuncType).NumOut$abstract
type:internal/abi.RegArgs <UsedInIface> -> type:.eqfunc.internal/abi.RegArgs
type:internal/abi.RegArgs <UsedInIface> -> runtime.gcbits.000000ff01000000
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.*abi.RegArgs.
type:internal/abi.RegArgs <UsedInIface> -> type:*internal/abi.RegArgs <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Ints.
type:internal/abi.RegArgs <UsedInIface> -> type:[9]uintptr <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Floats.
type:internal/abi.RegArgs <UsedInIface> -> type:[15]uint64 <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.Ptrs.
type:internal/abi.RegArgs <UsedInIface> -> type:[9]unsafe.Pointer <UsedInIface>
type:internal/abi.RegArgs <UsedInIface> -> type:.namedata.ReturnIsPtr.
type:internal/abi.RegArgs <UsedInIface> -> type:internal/abi.IntArgRegBitmap <UsedInIface>
type:*internal/abi.RegArgs <UsedInIface> -> type:.namedata.Dump.
type:*internal/abi.RegArgs <UsedInIface> -> type:.namedata.IntRegArgAddr.
type:internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.*abi.IntArgRegBitmap.
type:internal/abi.IntArgRegBitmap <UsedInIface> -> type:*internal/abi.IntArgRegBitmap <UsedInIface>
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.Get.
type:*internal/abi.IntArgRegBitmap <UsedInIface> -> type:.namedata.Set.
 -> go:info.internal/abi.Name.HasTag$abstract
internal/cpu.Initialize -> internal/cpu.doinit
internal/cpu.Initialize -> internal/cpu.processOptions
internal/cpu.processOptions -> internal/cpu.options
internal/cpu.processOptions -> go:string."GODEBUG: value \""
internal/cpu.processOptions -> go:string."\" not supported for cpu option \""
internal/cpu.processOptions -> go:string."\"\n"
internal/cpu.processOptions -> go:string."GODEBUG: no value specified for \""
internal/cpu.processOptions -> go:string."GODEBUG: can not enable \""
internal/cpu.processOptions -> go:string."\", missing CPU support\n"
internal/cpu.processOptions -> go:string."GODEBUG: unknown cpu feature \""
internal/cpu.processOptions -> gclocals·5HsMWwMM5F/pFgSwV5E8Vw==
internal/cpu.processOptions -> gclocals·LNUMIKWgmrnB3vMVfO8FBA==
internal/cpu.doinit -> type:[6]internal/cpu.option
internal/cpu.doinit -> go:string."adx"
internal/cpu.doinit -> go:string."aes"
internal/cpu.doinit -> go:string."erms"
internal/cpu.doinit -> go:string."pclmulqdq"
internal/cpu.doinit -> go:string."rdtscp"
internal/cpu.doinit -> go:string."sha"
internal/cpu.doinit -> internal/cpu.getGOAMD64level
internal/cpu.doinit -> type:internal/cpu.option
internal/cpu.doinit -> go:string."popcnt"
internal/cpu.doinit -> go:string."sse3"
internal/cpu.doinit -> go:string."sse41"
internal/cpu.doinit -> go:string."sse42"
internal/cpu.doinit -> go:string."ssse3"
internal/cpu.doinit -> go:string."avx"
internal/cpu.doinit -> go:string."avx2"
internal/cpu.doinit -> go:string."bmi1"
internal/cpu.doinit -> go:string."bmi2"
internal/cpu.doinit -> go:string."fma"
internal/cpu.doinit -> go:string."avx512f"
internal/cpu.doinit -> go:string."avx512bw"
internal/cpu.doinit -> go:string."avx512vl"
internal/cpu.doinit -> internal/cpu.cpuid
internal/cpu.doinit -> internal/cpu.maxExtendedFunctionInformation
internal/cpu.doinit -> internal/cpu.xgetbv
type:internal/cpu.option -> type:.eqfunc.internal/cpu.option
type:internal/cpu.option -> type:.namedata.*cpu.option-
type:internal/cpu.option -> type:*internal/cpu.option
type:internal/cpu.option -> type:.importpath.internal/cpu.
type:internal/cpu.option -> type:.namedata.Name.
type:internal/cpu.option -> type:.namedata.Feature.
type:internal/cpu.option -> type:.namedata.Specified.
type:internal/cpu.option -> type:.namedata.Enable.
 -> go:info.[]internal/cpu.option
 -> go:info.internal/cpu.indexByte$abstract
 -> go:info.internal/cpu.isSet$abstract
internal/chacha8rand.(*State).Init -> internal/chacha8rand.(*State).Init.arginfo1
internal/chacha8rand.(*State).Init -> internal/chacha8rand.(*State).Init.argliveinfo
 -> go:info.[32]uint8
 -> go:info.internal/chacha8rand.leUint64$abstract
type:[9]uintptr <UsedInIface> -> type:.namedata.*[9]uintptr-
runtime..stmp_104 -> go:string."runtime: allocation size out of range"
runtime..stmp_116 -> go:string."assignment to entry in nil map"
runtime.evacuate.stkobj -> runtime.gcbits.dd00000000000000
runtime.typelinksinit.stkobj -> runtime.gcbits.feff030000000000
runtime.typelinksinit.stkobj -> runtime.gcbits.2049922400000000
runtime.args -> runtime.args
runtime.args -> runtime.sysargs
runtime.sysargs -> os.executablePath
runtime.check -> runtime.check
runtime.check -> runtime.testAtomic64
runtime.check -> runtime.checkASM
runtime.check -> go:string."assembly checks failed"
runtime.check -> go:string."FixedStack is not power-of-2"
runtime.check -> go:string."float32nan2"
runtime.check -> go:string."float32nan"
runtime.check -> go:string."float64nan3"
runtime.check -> go:string."float64nan2"
runtime.check -> go:string."float64nan1"
runtime.check -> go:string."float64nan"
runtime.check -> go:string."atomicand8"
runtime.check -> go:string."atomicor8"
runtime.check -> go:string."cas6"
runtime.check -> go:string."cas5"
runtime.check -> go:string."cas4"
runtime.check -> go:string."cas3"
runtime.check -> go:string."cas2"
runtime.check -> go:string."cas1"
runtime.check -> go:string."bad timediv"
runtime.testAtomic64 -> runtime.test_z64
runtime.testAtomic64 -> runtime.test_x64
runtime.testAtomic64 -> go:string."xchg64 failed"
runtime.testAtomic64 -> go:string."xadd64 failed"
runtime.testAtomic64 -> go:string."store64 failed"
runtime.testAtomic64 -> go:string."load64 failed"
runtime.testAtomic64 -> go:string."cas64 failed"
 -> go:info.[4]uint8
 -> go:info.runtime.timediv$abstract
go:info.runtime.initAlgAES$abstract -> go:info.*[16]uint64
go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.string]
go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Store$abstract -> go:info.*go.shape.string
type:[]uint32 -> type:.namedata.*[]uint32-
type:[]runtime.functab -> type:.namedata.*[]runtime.functab-
type:[]runtime.functab -> type:runtime.functab
type:runtime.functab -> type:.namedata.*runtime.functab-
type:runtime.functab -> type:*runtime.functab
type:runtime.functab -> type:.namedata.entryoff-
type:runtime.functab -> type:.namedata.funcoff-
type:[]runtime.textsect -> type:.namedata.*[]runtime.textsect-
type:[]runtime.textsect -> type:runtime.textsect
type:runtime.textsect -> type:.namedata.*runtime.textsect-
type:runtime.textsect -> type:*runtime.textsect
type:runtime.textsect -> type:.namedata.vaddr-
type:runtime.textsect -> type:.namedata.baseaddr-
type:[]*runtime.itab -> type:.namedata.*[]*runtime.itab-
type:[]*runtime.itab -> type:*runtime.itab
type:*runtime.itab -> type:.namedata.*runtime.itab-
type:*runtime.itab -> type:runtime.itab
type:runtime.itab -> type:.eqfunc.runtime.itab
type:runtime.itab -> type:.namedata.inter-
type:runtime.itab -> type:*internal/abi.InterfaceType
type:runtime.itab -> type:.namedata._type-
type:runtime.itab -> type:.namedata.hash-
type:runtime.itab -> type:[4]uint8
type:runtime.itab -> type:.namedata.fun-
type:runtime.itab -> type:[1]uintptr
type:*internal/abi.InterfaceType -> type:.namedata.*abi.InterfaceType.
type:*internal/abi.InterfaceType -> type:internal/abi.InterfaceType
type:internal/abi.InterfaceType -> runtime.gcbits.d800000000000000
type:internal/abi.InterfaceType -> type:.namedata.Type..embedded
type:internal/abi.InterfaceType -> type:.namedata.PkgPath.
type:internal/abi.InterfaceType -> type:internal/abi.Name
type:internal/abi.InterfaceType -> type:.namedata.Methods.
type:internal/abi.InterfaceType -> type:[]internal/abi.Imethod
type:internal/abi.Name -> type:.namedata.*abi.Name.
type:internal/abi.Name -> type:*internal/abi.Name
type:internal/abi.Name -> type:.namedata.Bytes.
type:internal/abi.Name -> type:.namedata.Data.
type:internal/abi.Name -> type:.namedata.DataChecked.
type:internal/abi.Name -> type:.namedata.HasTag.
type:internal/abi.Name -> type:.namedata.IsBlank.
type:internal/abi.Name -> type:.namedata.IsEmbedded.
type:internal/abi.Name -> type:.namedata.IsExported.
type:internal/abi.Name -> type:.namedata.ReadVarint.
type:internal/abi.Name -> type:.namedata.Tag.
type:[4]uint8 -> type:.namedata.*[4]uint8-
type:[1]uintptr -> type:.namedata.*[1]uintptr-
type:.eqfunc.runtime.itab -> type:.eq.runtime.itab
type:[]runtime.ptabEntry -> type:.namedata.*[]runtime.ptabEntry-
type:[]runtime.ptabEntry -> type:runtime.ptabEntry
type:runtime.ptabEntry -> type:.namedata.*runtime.ptabEntry-
type:runtime.ptabEntry -> type:*runtime.ptabEntry
type:runtime.ptabEntry -> type:.namedata.name-
type:runtime.ptabEntry -> type:.namedata.typ-
type:[]runtime.modulehash -> type:.namedata.*[]runtime.modulehash-
type:[]runtime.modulehash -> type:runtime.modulehash
type:runtime.modulehash -> type:.eqfunc.runtime.modulehash
type:runtime.modulehash -> type:.namedata.*runtime.modulehash-
type:runtime.modulehash -> type:*runtime.modulehash
type:runtime.modulehash -> type:.namedata.linktimehash-
type:runtime.modulehash -> type:.namedata.runtimehash-
type:.eqfunc.runtime.modulehash -> type:.eq.runtime.modulehash
 -> go:info.*runtime.modulehash
type:[]*runtime.initTask -> type:.namedata.*[]*runtime.initTask-
type:[]*runtime.initTask -> type:*runtime.initTask
type:*runtime.initTask -> type:.namedata.*runtime.initTask-
type:*runtime.initTask -> type:runtime.initTask
type:runtime.initTask -> type:.namedata.nfns-
type:.eqfunc.runtime.bitvector -> type:.eq.runtime.bitvector
type:[]*runtime.bmap -> type:.namedata.*[]*runtime.bmap-
type:[]*runtime.moduledata -> type:.namedata.*[]*runtime.moduledata-
type:map[runtime._typePair]struct {} -> type:.namedata.*map[runtime._typePair]struct {}-
type:map[runtime._typePair]struct {} -> type:runtime._typePair
type:map[runtime._typePair]struct {} -> type:struct {}
type:map[runtime._typePair]struct {} -> type:noalg.map.bucket[runtime._typePair]struct {}
type:map[runtime._typePair]struct {} -> runtime.memhash128·f
type:runtime._typePair -> type:.namedata.*runtime._typePair-
type:runtime._typePair -> type:*runtime._typePair
type:runtime._typePair -> type:.namedata.t1-
type:runtime._typePair -> type:.namedata.t2-
type:struct {} -> type:.namedata.*struct {}-
type:noalg.map.bucket[runtime._typePair]struct {} -> type:.namedata.*map.bucket[runtime._typePair]struct {}-
type:noalg.map.bucket[runtime._typePair]struct {} -> type:noalg.[8]runtime._typePair
type:noalg.map.bucket[runtime._typePair]struct {} -> type:noalg.[8]struct {}
type:noalg.[8]struct {} -> type:.namedata.*[8]struct {}-
type:noalg.[8]struct {} -> type:[]struct {}
type:[]struct {} -> type:.namedata.*[]struct {}-
type:noalg.[8]runtime._typePair -> runtime.gcbits.ffff000000000000
type:noalg.[8]runtime._typePair -> type:.namedata.*[8]runtime._typePair-
type:noalg.[8]runtime._typePair -> type:[]runtime._typePair
type:[]runtime._typePair -> type:.namedata.*[]runtime._typePair-
runtime.memhash128·f -> runtime.memhash128
type:map[string]bool -> type:.namedata.*map[string]bool-
type:map[string]bool -> type:noalg.map.bucket[string]bool
type:map[string]bool -> runtime.strhash·f
runtime.strhash·f -> runtime.strhash
type:noalg.map.bucket[string]bool -> runtime.gcbits.aaaa040000000000
type:noalg.map.bucket[string]bool -> type:.namedata.*map.bucket[string]bool-
type:noalg.map.bucket[string]bool -> type:noalg.[8]string
type:noalg.map.bucket[string]bool -> type:noalg.[8]bool
type:noalg.[8]bool -> type:.namedata.*[8]bool-
type:noalg.[8]bool -> type:[]bool
type:noalg.[8]string -> runtime.gcbits.5555000000000000
type:noalg.[8]string -> type:.namedata.*[8]string-
type:noalg.[8]string -> type:[]string
type:[]bool -> type:.namedata.*[]bool-
type:[]string -> type:.namedata.*[]string-
type:map[uint32][]*internal/abi.Type -> type:.namedata.*map[uint32][]*abi.Type-
type:map[uint32][]*internal/abi.Type -> type:noalg.map.bucket[uint32][]*internal/abi.Type
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:.namedata.*map.bucket[uint32][]*abi.Type-
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:noalg.[8]uint32
type:noalg.map.bucket[uint32][]*internal/abi.Type -> type:noalg.[8][]*internal/abi.Type
type:noalg.[8]uint32 -> type:.namedata.*[8]uint32-
type:noalg.[8][]*internal/abi.Type -> runtime.gcbits.4992240000000000
type:noalg.[8][]*internal/abi.Type -> type:.namedata.*[8][]*abi.Type-
type:noalg.[8][]*internal/abi.Type -> type:[][]*internal/abi.Type
type:[][]*internal/abi.Type -> type:.namedata.*[][]*abi.Type-
runtime.recordspan·f -> runtime.recordspan
runtime.recordspan -> runtime.sysFree
 -> go:info.[]*runtime.mspan
runtime.strhash -> runtime.strhashFallback
runtime.checkASM -> runtime.checkASM.args_stackmap
runtime.checkASM -> runtime.checkASM.arginfo0
runtime.debugCallV2 -> runtime.debugCallCheck
runtime.debugCallV2 -> debugCall32
runtime.debugCallV2 -> runtime.debugCallWrap
runtime.debugCallV2 -> debugCall64
runtime.debugCallV2 -> debugCall128
runtime.debugCallV2 -> debugCall256
runtime.debugCallV2 -> debugCall512
runtime.debugCallV2 -> debugCall1024
runtime.debugCallV2 -> debugCall2048
runtime.debugCallV2 -> debugCall4096
runtime.debugCallV2 -> debugCall8192
runtime.debugCallV2 -> debugCall16384
runtime.debugCallV2 -> debugCall32768
runtime.debugCallV2 -> debugCall65536
runtime.debugCallV2 -> debugCallFrameTooLarge
runtime.debugCallCheck -> runtime.debugCallCheck
runtime.debugCallCheck -> runtime.debugCallCheck.func1
runtime.debugCallCheck -> go:string."executing on Go runtime stack"
runtime.debugCallCheck -> gclocals·nwxuCj+Mulc1h5gSBd94xQ==
runtime.debugCallCheck -> runtime.debugCallCheck.stkobj
runtime.debugCallCheck.func1 -> go:string."call from unknown function"
runtime.debugCallCheck.func1 -> go:string."call from within the Go runtime"
runtime.debugCallCheck.func1 -> go:string."call not at safe point"
runtime.debugCallWrap -> runtime.debugCallWrap
runtime.debugCallWrap -> runtime.debugCallWrap.func1
runtime.debugCallWrap -> runtime.debugCallWrap.func2·f
runtime.debugCallWrap -> runtime.unlockOSThread
runtime.debugCallWrap -> gclocals·TJqp01Pbhslx8LvL7y0LqA==
runtime.debugCallWrap.func1 -> runtime.debugCallWrap1·f
runtime.debugCallWrap.func1 -> type:runtime.debugCallWrapArgs
runtime.debugCallWrap.func1 -> go:string."inconsistent lockedm"
runtime.debugCallWrap.func1 -> gclocals·CiTjUJdY3tOeasNQ3EjOhw==
runtime.unlockOSThread -> runtime.badunlockosthread·f
type:runtime.debugCallWrapArgs -> type:.namedata.*runtime.debugCallWrapArgs-
type:runtime.debugCallWrapArgs -> type:*runtime.debugCallWrapArgs
type:runtime.debugCallWrapArgs -> type:.namedata.dispatch-
type:runtime.debugCallWrapArgs -> type:.namedata.callingG-
 -> go:info.runtime.lockOSThread$abstract
 -> go:info.runtime.dolockOSThread$abstract
 -> go:info.*runtime.debugCallWrapArgs
 -> go:info.runtime.dounlockOSThread$abstract
runtime.badunlockosthread·f -> runtime.badunlockosthread
runtime.badunlockosthread -> go:string."runtime: internal error: misuse of lockOSThread/unlockOSThread"
runtime.debugCallWrap.func2·f -> runtime.debugCallWrap.func2
runtime.debugCallWrap1·f -> runtime.debugCallWrap1
runtime.debugCallWrap1 -> runtime.debugCallWrap2
runtime.debugCallWrap1 -> runtime.debugCallWrap1.func1·f
runtime.debugCallWrap2 -> runtime.debugCallWrap2.func1
runtime.debugCallWrap2 -> gclocals·yet6sDYOFtYaEnxEKC0IWA==
runtime.debugCallWrap2 -> runtime.debugCallWrap2.stkobj
runtime.debugCallWrap2 -> runtime.debugCallWrap2.opendefer
runtime.debugCallWrap2.func1 -> runtime.debugCallPanicked
 -> go:info.runtime.funcval
runtime.debugCallWrap1.func1·f -> runtime.debugCallWrap1.func1
runtime.debugCallWrap1.func1 -> gclocals·ria7Vm7aKQ1I4U0mBtCKGQ==
runtime.debugCallWrap1.func1 -> gclocals·LWOsAv4VBQY4zaQ1Zn8JdQ==
runtime.debugCallPanicked -> runtime.debugCallPanicked.args_stackmap
runtime.debugCallPanicked -> runtime.debugCallPanicked.arginfo0
runtime.panicSlice3C -> runtime.goPanicSlice3C
runtime.mainPC -> runtime.main
runtime.main -> runtime.main.func1·f
runtime.main -> runtime.runtime_inittasks
runtime.main -> runtime.doInit1
runtime.main -> runtime.main.func2
runtime.main -> runtime.gcenable
runtime.main -> type:chan bool
runtime.main -> runtime.makechan
runtime.main -> runtime.main_init_done
runtime.main -> _cgo_pthread_key_created
runtime.main -> runtime._cgo_setenv
runtime.main -> runtime._cgo_unsetenv
runtime.main -> _cgo_notify_runtime_init_done
runtime.main -> runtime.set_crosscall2
runtime.main -> runtime.startTemplateThread
runtime.main -> runtime.closechan
runtime.main -> runtime.main_main·f
runtime.main -> runtime.runExitHooks
runtime.main -> go:string."set_crosscall2 missing"
runtime.main -> go:string."_cgo_notify_runtime_init_done missing"
runtime.main -> go:string."_cgo_unsetenv missing"
runtime.main -> go:string."_cgo_setenv missing"
runtime.main -> go:string."_cgo_pthread_key_created missing"
runtime.main -> go:string."nanotime returning zero"
runtime.main -> go:string."runtime.main not on m0"
runtime.main -> gclocals·zK+cMwcfAXhu1chOOe4LQA==
runtime.main -> runtime.main.opendefer
runtime.makechan -> runtime..stmp_107
runtime.makechan -> go:string."makechan: bad alignment"
runtime.makechan -> go:string."makechan: invalid channel element type"
runtime.closechan -> runtime.typedmemclr
runtime.closechan -> runtime.closechan.goready.func1
runtime.closechan -> runtime..stmp_112
runtime.closechan -> runtime..stmp_111
runtime.closechan -> gclocals·4sERXIH3V0NW1wnC/uQSyQ==
runtime.runExitHooks -> runtime.exitHooks
runtime.runExitHooks -> runtime.runExitHooks.func1·f
runtime.runExitHooks -> go:string."internal error: exit hook invoked panic"
runtime.runExitHooks -> go:string."internal error: exit hook invoked exit"
runtime.gcenable -> type:chan int
runtime.gcenable -> type:noalg.struct { F uintptr; X0 chan int }
runtime.gcenable -> runtime.gcenable.gowrap1
runtime.gcenable -> runtime.gcenable.gowrap2
runtime.gcenable -> runtime.chanrecv1
runtime.chanrecv1 -> runtime.chanrecv
runtime.chanrecv -> go:string."unreachable"
runtime.chanrecv -> runtime.gcWriteBarrier7
runtime.chanrecv -> runtime.gcWriteBarrier5
runtime.chanrecv -> runtime.chanparkcommit·f
runtime.chanrecv -> go:string."G waiting list is corrupted"
runtime.chanrecv -> runtime.chanrecv.func1
runtime.chanrecv -> runtime.recv
runtime.chanrecv -> gclocals·CmdfdGItXMUSC1fym9f0uw==
runtime.chanrecv -> gclocals·uwfCjT3h54Ab8NHNQtUojA==
runtime.recv -> runtime.recvDirect
runtime.recv -> runtime.recv.goready.func1
runtime.recv -> gclocals·OMeWtimgvo58gNrJcwLpQQ==
runtime.recv -> gclocals·7nw3WGXeZvA+RxswTVi3aw==
runtime.recv -> runtime.recv.argliveinfo
runtime.recvDirect -> runtime.typeBitsBulkBarrier
runtime.recvDirect -> gclocals·CcEjMr8DNisdVMgXyYQYpg==
runtime.typeBitsBulkBarrier -> go:string."runtime: typeBitsBulkBarrier with type  "
runtime.typeBitsBulkBarrier -> go:string."  with GC prog\n"
runtime.typeBitsBulkBarrier -> go:string."runtime: invalid typeBitsBulkBarrier"
runtime.typeBitsBulkBarrier -> go:string."  of size  "
runtime.typeBitsBulkBarrier -> go:string."  but memory size "
runtime.typeBitsBulkBarrier -> go:string."runtime: typeBitsBulkBarrier without type"
runtime.typeBitsBulkBarrier -> gclocals·v38RuXosoZvFGob7OKVhWw==
runtime.typeBitsBulkBarrier -> runtime.typeBitsBulkBarrier.argliveinfo
runtime.gcenable.gowrap2 -> runtime.bgscavenge
runtime.gcenable.gowrap2 -> runtime.bgscavenge.wrapinfo
runtime.gcenable.gowrap1 -> runtime.bgsweep
runtime.gcenable.gowrap1 -> runtime.bgsweep.wrapinfo
runtime.bgscavenge -> runtime.(*scavengerState).init
runtime.bgscavenge -> runtime.chansend1
runtime.bgscavenge -> runtime.(*scavengerState).park
runtime.bgscavenge -> runtime.(*scavengerState).run
runtime.bgscavenge -> runtime.(*scavengerState).sleep
runtime.chansend1 -> runtime.chansend
runtime.chansend -> runtime.chansend.func1
runtime.chansend -> runtime.send
runtime.chansend -> go:string."chansend: spurious wakeup"
runtime.chansend -> runtime..stmp_109
runtime.chansend -> gclocals·qmf99WUI/PeuzF+MqsWcQg==
runtime.chansend -> gclocals·qxExt+Cw2aJbp577Ym2sqg==
runtime.chansend -> runtime.chansend.arginfo1
runtime.send -> runtime.sendDirect
runtime.send -> runtime.send.goready.func1
runtime.send -> gclocals·bvzZQ/CnsVICTLF9VDCOYw==
runtime.send -> runtime.send.argliveinfo
runtime.(*scavengerState).init -> type:*runtime.scavengerState <UsedInIface>
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func1·f
runtime.(*scavengerState).init -> $f64.3f50624dd2f1a9fc
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func2·f
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func3·f
runtime.(*scavengerState).init -> runtime.(*scavengerState).init.func4·f
runtime.(*scavengerState).init -> go:string."scavenger state is already wired"
runtime.(*scavengerState).park -> go:string."tried to park scavenger from another goroutine"
runtime.(*scavengerState).sleep -> $f64.412e848000000000
runtime.(*scavengerState).sleep -> $f64.3ffb333333333333
runtime.(*scavengerState).sleep -> runtime.modtimer
runtime.(*scavengerState).sleep -> runtime.deltimer
runtime.(*scavengerState).sleep -> $f64.3f847ae147ae147b
runtime.(*scavengerState).sleep -> runtime.(*piController).next
runtime.(*scavengerState).sleep -> runtime.(*scavengerState).controllerFailed
runtime.(*scavengerState).sleep -> go:string."tried to sleep scavenger from another goroutine"
runtime.(*scavengerState).run -> $f64.40c3880000000000
runtime.(*scavengerState).run -> go:string."released less than one physical page of memory"
runtime.(*scavengerState).run -> go:string."tried to run scavenger from another goroutine"
runtime.bgsweep -> runtime.goschedIfBusy
runtime.startTemplateThread -> runtime.templateThread·f
runtime.doInit1 -> runtime.funcpkgpath
runtime.doInit1 -> go:string."init "
runtime.doInit1 -> go:string." ms, "
runtime.doInit1 -> go:string." bytes, "
runtime.doInit1 -> go:string." allocs"
runtime.doInit1 -> go:string."inittask with no functions"
runtime.doInit1 -> go:string."recursive call during initialization - linker skew"
runtime.doInit1 -> gclocals·oHzRy6kuSp7HW4luRrcAww==
runtime.doInit1 -> runtime.doInit1.stkobj
runtime.deltimer -> runtime.deltimer.jump8
runtime.deltimer -> gclocals·5guPwgO/oTXXYbwnvNmqbw==
runtime.modtimer -> runtime.modtimer.jump13
runtime.modtimer -> go:string."timer period must be non-negative"
runtime.modtimer -> go:string."timer when must be positive"
runtime.modtimer -> gclocals·1d0MRMDaiD/YrJE5JM5mWg==
runtime.modtimer -> gclocals·muDqG52/EJcJwD7Ry17BDA==
runtime.modtimer -> time.modTimer.arginfo1
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.*runtime.scavengerState-
type:*runtime.scavengerState <UsedInIface> -> type:runtime.scavengerState <UsedInIface>
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.controllerFailed-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.ready-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.run-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.sleep-
type:*runtime.scavengerState <UsedInIface> -> type:.namedata.wake-
type:runtime.scavengerState <UsedInIface> -> runtime.gcbits.0a000f0000000000
type:runtime.scavengerState <UsedInIface> -> type:.namedata.parked-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sysmonWake-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.targetCPUFraction-
type:runtime.scavengerState <UsedInIface> -> type:float64 <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepRatio-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepController-
type:runtime.scavengerState <UsedInIface> -> type:runtime.piController <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.controllerCooldown-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.printControllerReset-
type:runtime.scavengerState <UsedInIface> -> type:.namedata.sleepStub-
type:runtime.scavengerState <UsedInIface> -> type:func(int64) int64 <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.scavenge-
type:runtime.scavengerState <UsedInIface> -> type:func(uintptr) (uintptr, int64) <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.shouldStop-
type:runtime.scavengerState <UsedInIface> -> type:func() bool <UsedInIface>
type:runtime.scavengerState <UsedInIface> -> type:.namedata.gomaxprocs-
type:runtime.scavengerState <UsedInIface> -> type:func() int32 <UsedInIface>
type:float64 <UsedInIface> -> type:*float64 <UsedInIface>
type:runtime.piController <UsedInIface> -> type:.eqfunc.runtime.piController
type:runtime.piController <UsedInIface> -> type:.namedata.*runtime.piController-
type:runtime.piController <UsedInIface> -> type:*runtime.piController <UsedInIface>
type:runtime.piController <UsedInIface> -> type:.namedata.kp-
type:runtime.piController <UsedInIface> -> type:.namedata.ti-
type:runtime.piController <UsedInIface> -> type:.namedata.tt-
type:runtime.piController <UsedInIface> -> type:.namedata.min-
type:runtime.piController <UsedInIface> -> type:.namedata.max-
type:runtime.piController <UsedInIface> -> type:.namedata.errIntegral-
type:runtime.piController <UsedInIface> -> type:.namedata.errOverflow-
type:runtime.piController <UsedInIface> -> type:.namedata.inputOverflow-
 -> go:info.struct { runtime.hooks []runtime.exitHook; runtime.runningExitHooks bool }
runtime.runtime_inittasks -> go:runtime.inittasks
 -> go:info.chan bool
 -> go:info.runtime.(*hchan).raceaddr$abstract
 -> go:info.runtime.full$abstract
 -> go:info.runtime.(*waitq).dequeue$abstract
 -> go:info.runtime.(*waitq).enqueue$abstract
 -> go:info.runtime.chanbuf$abstract
 -> go:info.runtime.empty$abstract
 -> go:info.func(func()) bool
 -> go:info.chan int
 -> go:info.time.resetTimer$abstract
 -> go:info.runtime.resettimer$abstract
 -> go:info.time.stopTimer$abstract
 -> go:info.*runtime.piController
 -> go:info.runtime.isInf$abstract
 -> go:info.runtime.isNaN$abstract
 -> go:info.runtime.isFinite$abstract
 -> go:info.runtime.(*piController).reset$abstract
 -> go:info.runtime.doInit$abstract
 -> go:info.*runtime.initTask
 -> go:info.runtime.itoa$abstract
 -> go:info.runtime.funcNameForPrint$abstract
 -> go:info.runtime.updateTimerModifiedEarliest$abstract
type:func() int32 <UsedInIface> -> type:.namedata.*func() int32-
type:chan int -> type:.namedata.*chan int-
type:func() bool <UsedInIface> -> type:.namedata.*func() bool-
runtime..stmp_107 -> go:string."makechan: size out of range"
runtime..stmp_109 -> go:string."send on closed channel"
runtime..stmp_111 -> go:string."close of nil channel"
runtime..stmp_112 -> go:string."close of closed channel"
go:info.runtime.(*waitq).dequeue$abstract -> go:info.*runtime.waitq
go:info.runtime.doInit$abstract -> go:info.[]*runtime.initTask
type:func(int64) int64 <UsedInIface> -> type:.namedata.*func(int64) int64-
type:.eqfunc.runtime.piController -> type:.eq.runtime.piController
type:func(uintptr) (uintptr, int64) <UsedInIface> -> type:.namedata.*func(uintptr) (uintptr, int64)-
type:chan bool -> type:.namedata.*chan bool-
type:noalg.struct { F uintptr; X0 chan int } -> type:.namedata.*struct { F uintptr; X0 chan int }-
type:noalg.struct { F uintptr; X0 chan int } -> type:.namedata.F.
type:noalg.struct { F uintptr; X0 chan int } -> type:.namedata.X0.
runtime.main_main·f -> main.main
main.main -> demo/pkga.Foo
main.main -> fmt.Println
main.main -> gclocals·3hjyHrpBtcfpc7UmCpH+VA==
fmt.Println -> os.Stdout
fmt.Println -> go:itab.*os.File,io.Writer
fmt.Println -> fmt.Fprintln
fmt.Fprintln -> fmt.newPrinter
fmt.Fprintln -> fmt.(*pp).doPrintln
fmt.Fprintln -> fmt.(*pp).free
fmt.Fprintln -> gclocals·RT1JGNq6OcJkunM7qcDolg==
fmt.Fprintln -> gclocals·T0vNXQbfR9dfSiyvq7g5/w==
fmt.Fprintln -> fmt.Errorf.arginfo1
fmt.newPrinter -> fmt.ppFree
fmt.newPrinter -> sync.(*Pool).Get
fmt.newPrinter -> type:*fmt.pp
fmt.newPrinter -> runtime.panicdottypeE
fmt.(*pp).free -> type:*fmt.pp <UsedInIface>
fmt.(*pp).free -> sync.(*Pool).Put
fmt.(*pp).doPrintln -> fmt.(*pp).printArg
fmt.(*pp).doPrintln -> gclocals·YK7s5NHmu61HhranEBEZBw==
fmt.(*pp).doPrintln -> gclocals·VztAWi4EvUFJi25QE3jnTg==
fmt.(*pp).printArg -> fmt.(*pp).printArg.jump40
fmt.(*pp).printArg -> fmt.(*pp).fmtBool
fmt.(*pp).printArg -> go:string."[]byte"
fmt.(*pp).printArg -> fmt.(*pp).fmtBytes
fmt.(*pp).printArg -> fmt.(*pp).fmtInteger
fmt.(*pp).printArg -> fmt.(*pp).fmtComplex
fmt.(*pp).printArg -> fmt.(*pp).fmtFloat
fmt.(*pp).printArg -> fmt.(*pp).fmtString
fmt.(*pp).printArg -> type:reflect.Value
fmt.(*pp).printArg -> reflect.valueInterface
fmt.(*pp).printArg -> fmt.(*pp).handleMethods
fmt.(*pp).printArg -> fmt.(*pp).printValue
fmt.(*pp).printArg -> fmt.(*pp).fmtPointer
fmt.(*pp).printArg -> go:itab.*reflect.rtype,reflect.Type
fmt.(*pp).printArg -> fmt.(*fmt).fmtS
fmt.(*pp).printArg -> go:string."<nil>"
fmt.(*pp).printArg -> fmt.(*fmt).padString
fmt.(*pp).printArg -> fmt.(*pp).badVerb
fmt.(*pp).printArg -> gclocals·1mWdAtCD37V+xtbcfTgM6A==
fmt.(*pp).printArg -> gclocals·0Lv+auA7Pg3YYqmqTYQMaQ==
fmt.(*pp).printArg -> fmt.(*pp).printArg.stkobj
fmt.(*pp).printArg -> fmt.(*pp).fmtString.arginfo1
fmt.(*fmt).padString -> unicode/utf8.RuneCountInString
fmt.(*fmt).padString -> fmt.(*fmt).writePadding
fmt.(*fmt).padString -> gclocals·THyWSF6xKWF/BKZFwvOijg==
fmt.(*fmt).padString -> gclocals·QLT0Ly+Zc7eOqEUdCfw/IQ==
fmt.(*fmt).fmtS -> runtime.decoderune
fmt.(*pp).badVerb -> unicode/utf8.appendRuneNonASCII
fmt.(*pp).badVerb -> reflect.Value.typeSlow
fmt.(*pp).badVerb -> gclocals·SBD4yYdu0g5HYZ0ch8dMcw==
fmt.(*pp).fmtBool -> fmt.(*fmt).fmtBoolean
fmt.(*pp).fmtBool -> fmt.(*pp).fmtBool.arginfo1
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtUnicode
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtC
fmt.(*pp).fmtInteger -> go:string."0123456789abcdefx"
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtInteger
fmt.(*pp).fmtInteger -> go:string."0123456789ABCDEFX"
fmt.(*pp).fmtInteger -> fmt.(*pp).fmt0x64
fmt.(*pp).fmtInteger -> fmt.(*fmt).fmtQc
fmt.(*pp).fmtInteger -> fmt.(*pp).fmtInteger.arginfo1
fmt.(*fmt).fmtUnicode -> strconv.IsPrint
fmt.(*fmt).fmtUnicode -> unicode/utf8.EncodeRune
fmt.(*fmt).fmtUnicode -> fmt.(*fmt).pad
fmt.(*fmt).pad -> unicode/utf8.RuneCount
fmt.(*fmt).pad -> fmt.(*fmt).pad.argliveinfo
fmt.(*fmt).fmtInteger -> fmt..stmp_3
fmt.(*fmt).fmtInteger -> gclocals·dAEQfkX+CmyUTfVKHTwEyQ==
fmt.(*fmt).fmtInteger -> fmt.(*fmt).fmtInteger.arginfo1
fmt.(*fmt).fmtInteger -> fmt.(*fmt).fmtInteger.argliveinfo
fmt.(*fmt).fmtQc -> strconv.appendQuotedRuneWith
fmt.(*pp).fmtFloat -> fmt.(*fmt).fmtFloat
fmt.(*pp).fmtFloat -> fmt.(*pp).fmtFloat.arginfo1
fmt.(*fmt).fmtFloat -> strconv.genericFtoa
fmt.(*fmt).fmtFloat -> gclocals·mlHaC5xEQP3YmChGxFqrzQ==
fmt.(*fmt).fmtFloat -> gclocals·WSzv42LJZ33rmU2aJVRGWg==
fmt.(*fmt).fmtFloat -> fmt.(*fmt).fmtFloat.arginfo1
fmt.(*pp).fmtComplex -> fmt.(*pp).fmtComplex.arginfo1
fmt.(*pp).fmtComplex -> fmt.(*pp).fmtComplex.argliveinfo
fmt.(*pp).fmtString -> fmt.(*fmt).fmtQ
fmt.(*pp).fmtString -> fmt.(*fmt).fmtSbx
fmt.(*fmt).fmtSbx -> gclocals·jjYRaA7sv+FSHVm0VcEIHQ==
fmt.(*fmt).fmtSbx -> fmt.(*fmt).fmtSbx.arginfo1
fmt.(*fmt).fmtSbx -> fmt.(*fmt).fmtSbx.argliveinfo
fmt.(*fmt).fmtQ -> strconv.CanBackquote
fmt.(*fmt).fmtQ -> strconv.appendQuotedWith
fmt.(*fmt).fmtQ -> go:string."`"
fmt.(*pp).fmtBytes -> runtime.convTslice
fmt.(*pp).fmtBytes -> fmt.(*fmt).fmtBs
fmt.(*pp).fmtBytes -> gclocals·6OjZ0a04H8YIBd62D5aeaQ==
fmt.(*pp).fmtBytes -> gclocals·8jK9Yzbijaln+Oymhjn9xw==
fmt.(*pp).fmtBytes -> fmt.(*pp).fmtBytes.stkobj
fmt.(*pp).fmtBytes -> fmt.(*pp).fmtBytes.arginfo1
fmt.(*pp).fmtBytes -> fmt.(*pp).fmtBytes.argliveinfo
fmt.(*fmt).fmtBs -> fmt.(*fmt).truncate
fmt.(*fmt).truncate -> unicode/utf8.DecodeRune
fmt.(*pp).fmtPointer -> reflect.Value.UnsafePointer
fmt.(*pp).fmtPointer -> gclocals·Fk6a18rDscRrKEKbVX2vWA==
fmt.(*pp).fmtPointer -> gclocals·01/xo09qUtSWTRc8qTJ9Tg==
fmt.(*pp).fmtPointer -> fmt.(*pp).fmtPointer.arginfo1
fmt.(*pp).fmtPointer -> fmt.(*pp).fmtPointer.argliveinfo
fmt.(*pp).handleMethods -> fmt..typeAssert.2
fmt.(*pp).handleMethods -> fmt..typeAssert.3
fmt.(*pp).handleMethods -> fmt..typeAssert.4
fmt.(*pp).handleMethods -> fmt..interfaceSwitch.0
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.deferwrap1
fmt.(*pp).handleMethods -> runtime.deferprocStack
fmt.(*pp).handleMethods -> go:itab.*fmt.pp,fmt.State
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.deferwrap4
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.deferwrap3
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.deferwrap2
fmt.(*pp).handleMethods -> runtime.typeAssert
fmt.(*pp).handleMethods -> gclocals·p0I/0YnT+rMIs5JiEwrkAw==
fmt.(*pp).handleMethods -> gclocals·BT5pmYtc9N7QwRsqusykIA==
fmt.(*pp).handleMethods -> fmt.(*pp).handleMethods.stkobj
fmt.(*pp).handleMethods.deferwrap4 -> go:string."String"
fmt.(*pp).handleMethods.deferwrap4 -> fmt.(*pp).catchPanic
fmt.(*pp).handleMethods.deferwrap4 -> fmt.(*pp).catchPanic.wrapinfo
fmt.(*pp).catchPanic -> gclocals·7W6NV5HLRZ6rDrAf2DAeHg==
fmt.(*pp).catchPanic -> gclocals·8aE8CwEPdDR+G4YZ11xJvw==
fmt.(*pp).catchPanic -> fmt.(*pp).catchPanic.arginfo1
fmt.(*pp).handleMethods.deferwrap3 -> go:string."Error"
fmt.(*pp).handleMethods.deferwrap2 -> go:string."GoString"
fmt.(*pp).handleMethods.deferwrap1 -> go:string."Format"
fmt.(*pp).printValue -> fmt.(*pp).printValue.jump18
fmt.(*pp).printValue -> go:string."<invalid reflect.Value>"
fmt.(*pp).printValue -> reflect.Value.Elem
fmt.(*pp).printValue -> internal/fmtsort.Sort
fmt.(*pp).printValue -> reflect.Value.lenNonSlice
fmt.(*pp).printValue -> reflect.bytesType
fmt.(*pp).printValue -> reflect.Value.bytesSlow
fmt.(*pp).printValue -> fmt.(*pp).unknownType
fmt.(*pp).printValue -> fmt.getField
fmt.(*pp).printValue -> reflect.Value.NumField
fmt.(*pp).printValue -> reflect.Value.Index
fmt.(*pp).printValue -> type:reflect.ValueError
fmt.(*pp).printValue -> go:string."reflect.Value.Uint"
fmt.(*pp).printValue -> type:*reflect.ValueError <UsedInIface>
fmt.(*pp).printValue -> go:string."reflect.Value.Int"
fmt.(*pp).printValue -> gclocals·vID8S3T2dEZwqIkwkA4DMg==
fmt.(*pp).printValue -> gclocals·4JkWYm3ACU6xeCC5gUdbxQ==
fmt.(*pp).printValue -> fmt.(*pp).printValue.arginfo1
fmt.getField -> reflect.Value.Field
fmt.(*pp).unknownType -> gclocals·TDFV0/D34++ehcXXDsf8Bw==
fmt.(*pp).unknownType -> gclocals·YBx7UlhgSzSqYe9dkt/rmg==
type:*fmt.pp <UsedInIface> -> type:.namedata.*fmt.pp-
type:*fmt.pp <UsedInIface> -> type:fmt.pp <UsedInIface>
type:*fmt.pp <UsedInIface> -> type:.importpath.fmt.
type:*fmt.pp <UsedInIface> -> type:.namedata.Flag.
type:*fmt.pp <UsedInIface> -> type:.namedata.Precision.
type:*fmt.pp <UsedInIface> -> type:.namedata.Width.
type:*fmt.pp <UsedInIface> -> type:.namedata.Write.
type:*fmt.pp <UsedInIface> -> type:.namedata.WriteString.
type:*fmt.pp <UsedInIface> -> type:.namedata.argNumber-
type:*fmt.pp <UsedInIface> -> type:.namedata.badArgNum-
type:*fmt.pp <UsedInIface> -> type:.namedata.badVerb-
type:*fmt.pp <UsedInIface> -> type:.namedata.catchPanic-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrint-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrintf-
type:*fmt.pp <UsedInIface> -> type:.namedata.doPrintln-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmt0x64-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtBool-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtBytes-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtComplex-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtFloat-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtInteger-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtPointer-
type:*fmt.pp <UsedInIface> -> type:.namedata.fmtString-
type:*fmt.pp <UsedInIface> -> type:.namedata.free-
type:*fmt.pp <UsedInIface> -> type:.namedata.handleMethods-
type:*fmt.pp <UsedInIface> -> type:.namedata.missingArg-
type:*fmt.pp <UsedInIface> -> type:.namedata.printArg-
type:*fmt.pp <UsedInIface> -> type:.namedata.printValue-
type:*fmt.pp <UsedInIface> -> type:.namedata.unknownType-
type:fmt.pp <UsedInIface> -> runtime.gcbits.7101800000000000
type:fmt.pp <UsedInIface> -> type:fmt.buffer <UsedInIface>
type:fmt.pp <UsedInIface> -> type:reflect.Value <UsedInIface>
type:fmt.pp <UsedInIface> -> type:fmt.fmt <UsedInIface>
type:fmt.pp <UsedInIface> -> type:.namedata.reordered-
type:fmt.pp <UsedInIface> -> type:.namedata.goodArgNum-
type:fmt.pp <UsedInIface> -> type:.namedata.panicking-
type:fmt.pp <UsedInIface> -> type:.namedata.erroring-
type:fmt.pp <UsedInIface> -> type:.namedata.wrapErrs-
type:fmt.pp <UsedInIface> -> type:.namedata.wrappedErrs-
type:fmt.pp <UsedInIface> -> type:[]int <UsedInIface>
type:fmt.buffer <UsedInIface> -> type:.namedata.*fmt.buffer-
type:fmt.buffer <UsedInIface> -> type:*fmt.buffer <UsedInIface>
type:*fmt.buffer <UsedInIface> -> type:.namedata.write-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeByte-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeRune-
type:*fmt.buffer <UsedInIface> -> type:.namedata.writeString-
type:fmt.fmt <UsedInIface> -> type:.eqfunc.fmt.fmt
type:fmt.fmt <UsedInIface> -> type:.namedata.*fmt.fmt-
type:fmt.fmt <UsedInIface> -> type:*fmt.fmt <UsedInIface>
type:fmt.fmt <UsedInIface> -> type:.namedata.fmtFlags-.embedded
type:fmt.fmt <UsedInIface> -> type:fmt.fmtFlags <UsedInIface>
type:fmt.fmt <UsedInIface> -> type:.namedata.wid-
type:fmt.fmt <UsedInIface> -> type:.namedata.prec-
type:fmt.fmt <UsedInIface> -> type:.namedata.intbuf-
type:fmt.fmt <UsedInIface> -> type:[68]uint8 <UsedInIface>
type:*fmt.fmt <UsedInIface> -> type:.namedata.clearflags-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBoolean-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBs-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtBx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtC-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtQ-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtQc-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtS-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtSbx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtSx-
type:*fmt.fmt <UsedInIface> -> type:.namedata.fmtUnicode-
type:*fmt.fmt <UsedInIface> -> type:.namedata.pad-
type:*fmt.fmt <UsedInIface> -> type:.namedata.padString-
type:*fmt.fmt <UsedInIface> -> type:.namedata.truncate-
type:*fmt.fmt <UsedInIface> -> type:.namedata.truncateString-
type:*fmt.fmt <UsedInIface> -> type:.namedata.writePadding-
type:fmt.fmtFlags <UsedInIface> -> type:.eqfunc9
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.*fmt.fmtFlags-
type:fmt.fmtFlags <UsedInIface> -> type:*fmt.fmtFlags <UsedInIface>
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.widPresent-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.precPresent-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.minus-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.plus-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.sharp-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.space-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.zero-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.plusV-
type:fmt.fmtFlags <UsedInIface> -> type:.namedata.sharpV-
fmt.ppFree -> fmt.init.func1·f
 -> go:info.sync.Pool
fmt..typeAssert.2 -> runtime.emptyTypeAssertCache
fmt..typeAssert.3 -> type:fmt.Formatter
type:fmt.Formatter -> type:.namedata.*fmt.Formatter.
type:fmt.Formatter -> type:*fmt.Formatter
type:fmt.Formatter -> type:.namedata.Format.
type:fmt.Formatter -> type:func(fmt.State, int32)
fmt..typeAssert.4 -> type:fmt.GoStringer
type:fmt.GoStringer -> type:.namedata.*fmt.GoStringer.
type:fmt.GoStringer -> type:*fmt.GoStringer
type:fmt.GoStringer -> type:.namedata.GoString.
fmt..interfaceSwitch.0 -> type:fmt.Stringer
type:fmt.Stringer -> type:.namedata.*fmt.Stringer.
type:fmt.Stringer -> type:*fmt.Stringer
 -> go:info.*fmt.fmt
 -> go:info.fmt.buffer
 -> go:info.fmt.(*buffer).write$abstract
 -> go:info.fmt.(*buffer).writeString$abstract
 -> go:info.unicode/utf8.RuneLen$abstract
 -> go:info.fmt.(*fmt).truncateString$abstract
 -> go:info.strconv.AppendQuote$abstract
 -> go:info.strconv.AppendQuoteToASCII$abstract
 -> go:info.unicode/utf8.AppendRune$abstract
 -> go:info.strconv.AppendQuoteRuneToASCII$abstract
 -> go:info.strconv.AppendQuoteRune$abstract
 -> go:info.[6]uint8
 -> go:info.strconv.AppendFloat$abstract
 -> go:info.fmt.(*buffer).writeByte$abstract
 -> go:info.*fmt.pp
 -> go:info.fmt.(*fmt).init$abstract
 -> go:info.fmt.(*fmt).clearflags$abstract
 -> go:info.io.Writer
 -> go:info.[]interface {}
 -> go:info.reflect.Value
 -> go:info.reflect.Value.Kind$abstract
 -> go:info.reflect.flag.kind$abstract
 -> go:info.reflect.Value.IsNil$abstract
 -> go:info.reflect.Value.IsValid$abstract
 -> go:info.reflect.Value.Type$abstract
 -> go:info.fmt.(*buffer).writeRune$abstract
 -> go:info.reflect.TypeOf$abstract
 -> go:info.reflect.toType$abstract
 -> go:info.fmt.(*fmt).fmtSx$abstract
 -> go:info.fmt.(*fmt).fmtBx$abstract
 -> go:info.reflect.ValueOf$abstract
 -> go:info.reflect.unpackEface$abstract
 -> go:info.internal/abi.(*Type).IfaceIndir$abstract
 -> go:info.fmt.fmtFlags
 -> go:info.fmt.Formatter
 -> go:info.fmt.GoStringer
 -> go:info.fmt.Stringer
 -> go:info.reflect.Value.CanInterface$abstract
 -> go:info.reflect.Value.Interface$abstract
 -> go:info.*internal/fmtsort.SortedMap
 -> go:info.reflect.Type
 -> go:info.reflect.Value.Bool$abstract
 -> go:info.reflect.Value.Int$abstract
 -> go:info.reflect.Value.Uint$abstract
 -> go:info.reflect.Value.Float$abstract
 -> go:info.reflect.Value.Complex$abstract
 -> go:info.reflect.Value.CanAddr$abstract
 -> go:info.reflect.Value.Len$abstract
 -> go:info.reflect.Value.Bytes$abstract
 -> go:info.reflect.Value.String$abstract
demo/pkga.Foo -> demo/pkgb.Zoo
demo/pkga.Foo -> go:string."Hello from Foo!"
strconv.genericFtoa -> strconv.float32info
strconv.genericFtoa -> strconv.float64info
strconv.genericFtoa -> strconv.fmtX
strconv.genericFtoa -> strconv.optimize
strconv.genericFtoa -> strconv.ryuFtoaFixed32
strconv.genericFtoa -> strconv.ryuFtoaFixed64
strconv.genericFtoa -> strconv.bigFtoa
strconv.genericFtoa -> strconv.ryuFtoaShortest
strconv.genericFtoa -> strconv.formatDigits
strconv.genericFtoa -> strconv.fmtB
strconv.genericFtoa -> strconv..stmp_12
strconv.genericFtoa -> gclocals·/0e7XDi+yPTlYfaVle7v7w==
strconv.genericFtoa -> gclocals·wzjvU32ZYOnONMc39GyyQQ==
strconv.genericFtoa -> strconv.genericFtoa.stkobj
strconv.genericFtoa -> strconv.AppendFloat.arginfo1
strconv.genericFtoa -> strconv.genericFtoa.argliveinfo
strconv.bigFtoa -> strconv.(*decimal).Assign
strconv.bigFtoa -> strconv.(*decimal).Shift
strconv.bigFtoa -> strconv.(*decimal).Round
strconv.bigFtoa -> strconv.roundShortest
strconv.bigFtoa -> gclocals·WLNLDMnlx/MJz9q6ZPhyng==
strconv.bigFtoa -> gclocals·yROwgZmxcEjQO7qZUR29ZQ==
strconv.bigFtoa -> strconv.bigFtoa.arginfo1
strconv.bigFtoa -> strconv.bigFtoa.argliveinfo
strconv.(*decimal).Shift -> strconv.rightShift
strconv.(*decimal).Shift -> strconv.leftShift
strconv.leftShift -> strconv.leftcheats
strconv.formatDigits -> strconv.fmtE
strconv.formatDigits -> strconv.fmtF
strconv.formatDigits -> gclocals·aJ0RFkXHGs1bnq/DJ5J1yw==
strconv.formatDigits -> strconv.formatDigits.arginfo1
strconv.formatDigits -> strconv.formatDigits.argliveinfo
strconv.fmtE -> gclocals·Ir0e+QuI3Rw8KXGenHkHEw==
strconv.fmtE -> strconv.fmtE.arginfo1
strconv.fmtE -> strconv.fmtE.argliveinfo
strconv.fmtF -> gclocals·85x/2q5RKyAjZD0Eugv6Tg==
strconv.fmtF -> strconv.fmtF.arginfo1
strconv.fmtF -> strconv.fmtF.argliveinfo
strconv.fmtB -> strconv.formatBits
strconv.fmtB -> gclocals·JeqdgTi6SjErUxFdeiy//Q==
strconv.fmtB -> strconv.fmtB.arginfo1
strconv.fmtB -> strconv.fmtB.argliveinfo
strconv.fmtX -> go:string."0123456789ABCDEF"
strconv.fmtX -> gclocals·fI1B4FjKb6qh0g2VTxO0oA==
strconv.fmtX -> strconv.fmtX.argliveinfo
strconv.ryuFtoaFixed32 -> strconv.mult64bitPow10
strconv.ryuFtoaFixed32 -> strconv.formatDecimal
strconv.ryuFtoaFixed32 -> strconv..stmp_15
strconv.ryuFtoaFixed32 -> strconv..stmp_14
strconv.ryuFtoaFixed32 -> strconv..stmp_13
strconv.ryuFtoaFixed32 -> strconv.ryuFtoaFixed32.arginfo1
strconv.ryuFtoaFixed64 -> strconv.mult128bitPow10
strconv.ryuFtoaFixed64 -> strconv..stmp_17
strconv.ryuFtoaFixed64 -> strconv..stmp_16
strconv.formatDecimal -> strconv.uint64pow10
strconv.formatDecimal -> go:string..gostring.200.QSBD6CASPFh8N+gldNET7A==
strconv.ryuFtoaShortest -> strconv.ryuDigits
strconv.ryuFtoaShortest -> gclocals·h0OUVQBt0BPrp9N+m46wyQ==
strconv.ryuDigits -> strconv.ryuDigits32
strconv.ryuDigits -> strconv.ryuDigits.arginfo1
strconv.ryuDigits32 -> strconv.ryuDigits32.arginfo1
strconv.mult64bitPow10 -> strconv.detailedPowersOfTen
strconv.mult64bitPow10 -> strconv..stmp_19
strconv.mult128bitPow10 -> strconv..stmp_20
strconv.formatBits -> go:string."0123456789abcdefghijklmnopqrstuvwxyz"
strconv.formatBits -> strconv..stmp_21
strconv.formatBits -> strconv.formatBits.arginfo1
strconv.appendQuotedWith -> unicode/utf8.DecodeRuneInString
strconv.appendQuotedWith -> strconv.appendEscapedRune
strconv.appendQuotedWith -> gclocals·y+jrKPbABt0/5+nBN1COxA==
strconv.appendQuotedWith -> gclocals·w/w3ma/9mcu3ZEYTbpGxlA==
strconv.appendQuotedWith -> strconv.appendQuotedWith.arginfo1
strconv.appendQuotedWith -> strconv.appendQuotedWith.argliveinfo
strconv.appendQuotedRuneWith -> strconv.appendQuotedRuneWith.arginfo1
strconv.appendQuotedRuneWith -> strconv.appendQuotedRuneWith.argliveinfo
strconv.appendEscapedRune -> strconv.isGraphic
strconv.appendEscapedRune -> strconv.appendEscapedRune.argliveinfo
strconv.IsPrint -> strconv.isPrint16
strconv.IsPrint -> strconv.isPrint32
strconv.IsPrint -> strconv.isNotPrint32
strconv.IsPrint -> strconv.isNotPrint16
strconv.leftcheats -> strconv..stmp_5
 -> go:info.[]strconv.leftCheat
 -> go:info.[696][2]uint64
 -> go:info.strconv.floatInfo
 -> go:info.[20]uint64
strconv.isPrint16 -> strconv..stmp_6
 -> go:info.[]uint16
strconv.isNotPrint16 -> strconv..stmp_7
strconv.isPrint32 -> strconv..stmp_8
strconv.isNotPrint32 -> strconv..stmp_9
strconv.isGraphic -> strconv..stmp_10
strconv..stmp_5 -> syscall..stmp_36
strconv..stmp_5 -> go:string."25"
strconv..stmp_5 -> go:string."125"
strconv..stmp_5 -> go:string."625"
strconv..stmp_5 -> go:string."3125"
strconv..stmp_5 -> go:string."15625"
strconv..stmp_5 -> go:string."78125"
strconv..stmp_5 -> go:string."390625"
strconv..stmp_5 -> go:string."1953125"
strconv..stmp_5 -> go:string."9765625"
strconv..stmp_5 -> go:string."48828125"
strconv..stmp_5 -> go:string."244140625"
strconv..stmp_5 -> go:string."1220703125"
strconv..stmp_5 -> go:string."6103515625"
strconv..stmp_5 -> go:string."30517578125"
strconv..stmp_5 -> go:string."152587890625"
strconv..stmp_5 -> go:string."762939453125"
strconv..stmp_5 -> go:string."3814697265625"
strconv..stmp_5 -> go:string."19073486328125"
strconv..stmp_5 -> go:string."95367431640625"
strconv..stmp_5 -> go:string."476837158203125"
strconv..stmp_5 -> go:string."2384185791015625"
strconv..stmp_5 -> go:string."11920928955078125"
strconv..stmp_5 -> go:string."59604644775390625"
strconv..stmp_5 -> go:string."298023223876953125"
strconv..stmp_5 -> go:string."1490116119384765625"
strconv..stmp_5 -> go:string."7450580596923828125"
strconv..stmp_5 -> go:string."37252902984619140625"
strconv..stmp_5 -> go:string."186264514923095703125"
strconv..stmp_5 -> go:string."931322574615478515625"
strconv..stmp_5 -> go:string."4656612873077392578125"
strconv..stmp_5 -> go:string."23283064365386962890625"
strconv..stmp_5 -> go:string."116415321826934814453125"
strconv..stmp_5 -> go:string."582076609134674072265625"
strconv..stmp_5 -> go:string."2910383045673370361328125"
strconv..stmp_5 -> go:string."14551915228366851806640625"
strconv..stmp_5 -> go:string."72759576141834259033203125"
strconv..stmp_5 -> go:string."363797880709171295166015625"
strconv..stmp_5 -> go:string."1818989403545856475830078125"
strconv..stmp_5 -> go:string."9094947017729282379150390625"
strconv..stmp_5 -> go:string."45474735088646411895751953125"
strconv..stmp_5 -> go:string."227373675443232059478759765625"
strconv..stmp_5 -> go:string."1136868377216160297393798828125"
strconv..stmp_5 -> go:string."5684341886080801486968994140625"
strconv..stmp_5 -> go:string."28421709430404007434844970703125"
strconv..stmp_5 -> go:string."142108547152020037174224853515625"
strconv..stmp_5 -> go:string."710542735760100185871124267578125"
strconv..stmp_5 -> go:string."3552713678800500929355621337890625"
strconv..stmp_5 -> go:string."17763568394002504646778106689453125"
strconv..stmp_5 -> go:string."88817841970012523233890533447265625"
strconv..stmp_5 -> go:string."444089209850062616169452667236328125"
strconv..stmp_5 -> go:string."2220446049250313080847263336181640625"
strconv..stmp_5 -> go:string."11102230246251565404236316680908203125"
strconv..stmp_5 -> go:string."55511151231257827021181583404541015625"
strconv..stmp_5 -> go:string."277555756156289135105907917022705078125"
strconv..stmp_5 -> go:string."1387778780781445675529539585113525390625"
strconv..stmp_5 -> go:string."6938893903907228377647697925567626953125"
strconv..stmp_5 -> go:string."34694469519536141888238489627838134765625"
strconv..stmp_5 -> go:string."173472347597680709441192448139190673828125"
strconv..stmp_5 -> go:string."867361737988403547205962240695953369140625"
 -> go:info.*strconv.decimal
 -> go:info.strconv.trim$abstract
 -> go:info.strconv.prefixIsLessThan$abstract
 -> go:info.strconv.shouldRoundUp$abstract
 -> go:info.strconv.(*decimal).RoundUp$abstract
 -> go:info.strconv.(*decimal).RoundDown$abstract
 -> go:info.*strconv.floatInfo
 -> go:info.strconv.decimalSlice
 -> go:info.math.Float32bits$abstract
 -> go:info.math.Float64bits$abstract
 -> go:info.strconv.lower$abstract
 -> go:info.*strconv.decimalSlice
 -> go:info.strconv.mulByLog2Log10$abstract
 -> go:info.strconv.divisibleByPower5$abstract
 -> go:info.strconv.computeBounds$abstract
 -> go:info.strconv.divmod1e9$abstract
 -> go:info.strconv.mulByLog10Log2$abstract
 -> go:info.[2]uint64
 -> go:info.[65]uint8
 -> go:info.strconv.isPowerOfTwo$abstract
 -> go:info.math/bits.TrailingZeros$abstract
 -> go:info.unicode/utf8.ValidRune$abstract
 -> go:info.strconv.isInGraphicList$abstract
 -> go:info.strconv.bsearch16$abstract
 -> go:info.strconv.bsearch32$abstract
unicode/utf8.DecodeRune -> unicode/utf8.first
unicode/utf8.DecodeRune -> unicode/utf8.acceptRanges
unicode/utf8.EncodeRune -> strconv.AppendQuoteRune.arginfo1
 -> go:info.[256]uint8
 -> go:info.[16]unicode/utf8.acceptRange
internal/fmtsort.Sort -> reflect.flag.panicNotMap
internal/fmtsort.Sort -> reflect.(*MapIter).Next
internal/fmtsort.Sort -> reflect.(*MapIter).Key
internal/fmtsort.Sort -> reflect.(*MapIter).Value
internal/fmtsort.Sort -> type:internal/fmtsort.SortedMap
internal/fmtsort.Sort -> go:itab.*internal/fmtsort.SortedMap,sort.Interface
internal/fmtsort.Sort -> sort.Stable
internal/fmtsort.Sort -> gclocals·yUTgI26mR2e8xJH2ncoWzg==
internal/fmtsort.Sort -> gclocals·/qYL/dS4VpWZB2dzqwAH8A==
internal/fmtsort.Sort -> internal/fmtsort.Sort.stkobj
sort.Stable -> sort.stable
sort.stable -> sort.insertionSort
sort.stable -> sort.symMerge
sort.symMerge -> sort.rotate
sort.symMerge -> sort.siftDown_func.arginfo1
sort.symMerge -> sort.symMerge.argliveinfo
 -> go:info.sort.Interface
 -> go:info.sort.swapRange$abstract
type:internal/fmtsort.SortedMap -> type:.namedata.*fmtsort.SortedMap.
type:internal/fmtsort.SortedMap -> type:*internal/fmtsort.SortedMap <UsedInIface>
type:internal/fmtsort.SortedMap -> type:.importpath.internal/fmtsort.
type:internal/fmtsort.SortedMap -> type:[]reflect.Value
type:internal/fmtsort.SortedMap -> type:.namedata.Value.
type:*internal/fmtsort.SortedMap <UsedInIface> -> type:internal/fmtsort.SortedMap <UsedInIface>
type:*internal/fmtsort.SortedMap <UsedInIface> -> type:.namedata.Less.
type:internal/fmtsort.SortedMap <UsedInIface> -> type:[]reflect.Value <UsedInIface>
 -> go:info.*reflect.MapIter
 -> go:info.[]reflect.Value
 -> go:info.reflect.Value.MapRange$abstract
 -> go:info.*os.File
reflect.Value.bytesSlow -> reflect..stmp_54
reflect.Value.bytesSlow -> go:string."reflect.Value.Bytes"
reflect.Value.bytesSlow -> runtime.panicunsafeslicenilptr
reflect.Value.bytesSlow -> reflect..stmp_56
reflect.Value.bytesSlow -> reflect..stmp_55
reflect.Value.Elem -> reflect.verifyNotInHeapPtr
reflect.Value.Elem -> internal/abi.(*Type).NumMethod
reflect.Value.Elem -> reflect..stmp_97
reflect.Value.Elem -> go:string."reflect.Value.Elem"
reflect.Value.Elem -> gclocals·vFm+xX2qj32wY9it0kFCsA==
reflect.Value.Field -> reflect..stmp_98
reflect.Value.Field -> go:string."reflect.Value.Field"
reflect.Value.Index -> reflect.uint8Type
reflect.Value.Index -> reflect..stmp_102
reflect.Value.Index -> go:string."reflect.Value.Index"
reflect.Value.Index -> reflect..stmp_20
reflect.Value.Index -> reflect..stmp_100
reflect.valueInterface -> go:string."Interface"
reflect.valueInterface -> reflect.makeMethodValue
reflect.valueInterface -> reflect.Value.NumMethod
reflect.valueInterface -> reflect.packEface
reflect.valueInterface -> reflect..stmp_103
reflect.valueInterface -> go:string."reflect.Value.Interface"
reflect.valueInterface -> strconv.AppendBool.arginfo1
reflect.makeMethodValue -> reflect.methodValueCall
reflect.makeMethodValue -> reflect.funcLayout
reflect.makeMethodValue -> type:reflect.methodValue
reflect.makeMethodValue -> reflect.methodReceiver
reflect.makeMethodValue -> type:reflect.Type
reflect.makeMethodValue -> runtime.panicdottypeI
reflect.makeMethodValue -> reflect..stmp_19
reflect.makeMethodValue -> gclocals·m+yuV0GxbjNSNVwqDXd+Pg==
reflect.makeMethodValue -> gclocals·WSkrldGX4MurakjEXaI/tA==
reflect.funcLayout -> reflect.layoutCache
reflect.funcLayout -> type:reflect.layoutKey <UsedInIface>
reflect.funcLayout -> sync.(*Map).Load
reflect.funcLayout -> type:reflect.layoutType <UsedInIface>
reflect.funcLayout -> reflect.newAbiDesc
reflect.funcLayout -> reflect.(*rtype).String
reflect.funcLayout -> go:string.")("
reflect.funcLayout -> go:string."methodargs("
reflect.funcLayout -> runtime.concatstring5
reflect.funcLayout -> go:string."funcargs("
reflect.funcLayout -> internal/abi.NewName
reflect.funcLayout -> reflect.addReflectOff
reflect.funcLayout -> type:sync.Pool
reflect.funcLayout -> type:noalg.struct { F uintptr; X0 *internal/abi.Type }
reflect.funcLayout -> reflect.funcLayout.func1
reflect.funcLayout -> sync.(*Map).LoadOrStore
reflect.funcLayout -> go:string."reflect: funcLayout with interface receiver "
reflect.funcLayout -> go:string."reflect: funcLayout of non-func type "
reflect.funcLayout -> gclocals·r8ND4j8nTKid7nQ36FX+4w==
reflect.funcLayout -> gclocals·CzLtgEaQbzLY/R8d304G2Q==
reflect.funcLayout -> reflect.funcLayout.stkobj
reflect.funcLayout -> reflect.newAbiDesc.arginfo1
reflect.funcLayout -> reflect.newAbiDesc.argliveinfo
reflect.newAbiDesc -> type:reflect.bitVector
reflect.newAbiDesc -> reflect.(*abiSeq).addRcvr
reflect.newAbiDesc -> reflect.(*abiSeq).addArg
reflect.newAbiDesc -> reflect.addTypeBits
reflect.newAbiDesc -> gclocals·321G0Ym/lDXeiBfRy1sRFg==
reflect.newAbiDesc -> gclocals·p4oBQzHhmQWoEEYL5SiUOQ==
reflect.newAbiDesc -> reflect.newAbiDesc.stkobj
reflect.(*abiSeq).addArg -> reflect.(*abiSeq).regAssign
reflect.(*abiSeq).addArg -> type:reflect.abiSeq
reflect.(*abiSeq).addArg -> type:reflect.abiStep
reflect.(*abiSeq).addArg -> gclocals·HQMy/1JM6rlUYY2s4XzMfg==
reflect.(*abiSeq).addArg -> gclocals·WhUsbJHQAFzb4M6MfKpK7w==
reflect.(*abiSeq).addRcvr -> reflect.(*abiSeq).assignIntN
reflect.(*abiSeq).regAssign -> reflect.(*abiSeq).regAssign.jump4
reflect.(*abiSeq).regAssign -> reflect.floatArgRegs
reflect.(*abiSeq).regAssign -> reflect.floatRegSize
reflect.(*abiSeq).regAssign -> go:string."t.Kind == "
reflect.(*abiSeq).regAssign -> reflect..stmp_6
reflect.(*abiSeq).regAssign -> gclocals·foM/pdm/hXseFZbhzZY8iA==
reflect.(*abiSeq).assignIntN -> reflect.intArgRegs
reflect.(*abiSeq).assignIntN -> reflect..stmp_9
reflect.(*abiSeq).assignIntN -> reflect..stmp_3
reflect.(*rtype).String -> reflect.resolveNameOff
reflect.funcLayout.func1 -> reflect.unsafe_New
reflect.addTypeBits -> gclocals·e4D0VkZrPb2A/sE/RDKuFA==
reflect.packEface -> reflect.typedmemmove
reflect.packEface -> reflect..stmp_52
reflect.packEface -> gclocals·goLww5ZhZIHL3mK3fNBItw==
reflect.methodReceiver -> reflect.resolveTypeOff
reflect.methodReceiver -> internal/abi.(*Type).ExportedMethods
reflect.methodReceiver -> reflect.resolveTextOff
reflect.methodReceiver -> go:string."reflect: "
reflect.methodReceiver -> go:string." of unexported method"
reflect.methodReceiver -> reflect..stmp_81
reflect.methodReceiver -> go:string." of method on nil interface value"
reflect.methodReceiver -> gclocals·tvlUN/ZKEir4drQW66JrTQ==
reflect.methodReceiver -> gclocals·9p37S1F04MUBIQrO5E7iBA==
reflect.methodReceiver -> io.ReadAtLeast.arginfo1
reflect.Value.lenNonSlice -> reflect.chanlen
reflect.Value.lenNonSlice -> reflect.maplen
reflect.Value.lenNonSlice -> go:string."reflect.Value.Len"
reflect.Value.lenNonSlice -> reflect..stmp_106
reflect.Value.lenNonSlice -> reflect..stmp_16
reflect.(*MapIter).Key -> reflect.mapiterkey
reflect.(*MapIter).Key -> reflect.copyVal
reflect.(*MapIter).Key -> reflect..stmp_111
reflect.(*MapIter).Key -> reflect..stmp_110
reflect.(*MapIter).Value -> reflect.mapiterelem
reflect.(*MapIter).Value -> reflect..stmp_115
reflect.(*MapIter).Value -> reflect..stmp_114
reflect.(*MapIter).Next -> reflect.mapiterinit
reflect.(*MapIter).Next -> reflect.mapiternext
reflect.(*MapIter).Next -> reflect..stmp_120
reflect.(*MapIter).Next -> reflect..stmp_118
reflect.flag.panicNotMap -> reflect.valueMethodName
reflect.valueMethodName -> type:[5]uintptr
reflect.valueMethodName -> type:runtime.Frames
reflect.valueMethodName -> runtime.(*Frames).Next
reflect.valueMethodName -> go:string."unknown method"
reflect.valueMethodName -> gclocals·jBHS+rSFmEtj8HNCeAOOGw==
reflect.Value.NumMethod -> reflect.(*rtype).NumMethod
reflect.Value.NumMethod -> go:string."reflect.Value.NumMethod"
reflect.(*rtype).NumMethod -> reflect.(*rtype).exportedMethods
reflect.(*rtype).exportedMethods -> reflect.(*rtype).exportedMethods.jump7
reflect.Value.typeSlow -> go:string."reflect.Value.Type"
reflect.Value.UnsafePointer -> go:string."reflect.Value.UnsafePointer"
reflect.Value.UnsafePointer -> reflect..stmp_146
type:reflect.Value <UsedInIface> -> type:.namedata.*reflect.Value.
type:reflect.Value <UsedInIface> -> type:*reflect.Value <UsedInIface>
type:reflect.Value <UsedInIface> -> type:.importpath.reflect.
type:reflect.Value <UsedInIface> -> type:.namedata.typ_-
type:reflect.Value <UsedInIface> -> type:.namedata.flag-.embedded
type:reflect.Value <UsedInIface> -> type:reflect.flag <UsedInIface>
type:reflect.Value <UsedInIface> -> type:.namedata.Bool.
type:reflect.Value <UsedInIface> -> type:.namedata.Call.
type:reflect.Value <UsedInIface> -> type:.namedata.CallSlice.
type:reflect.Value <UsedInIface> -> type:.namedata.CanAddr.
type:reflect.Value <UsedInIface> -> type:.namedata.CanComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.CanConvert.
type:reflect.Value <UsedInIface> -> type:.namedata.CanFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.CanInt.
type:reflect.Value <UsedInIface> -> type:.namedata.CanInterface.
type:reflect.Value <UsedInIface> -> type:.namedata.CanSet.
type:reflect.Value <UsedInIface> -> type:.namedata.CanUint.
type:reflect.Value <UsedInIface> -> type:.namedata.Cap.
type:reflect.Value <UsedInIface> -> type:.namedata.Clear.
type:reflect.Value <UsedInIface> -> type:.namedata.Close.
type:reflect.Value <UsedInIface> -> type:.namedata.Comparable.
type:reflect.Value <UsedInIface> -> type:.namedata.Complex.
type:reflect.Value <UsedInIface> -> type:.namedata.Convert.
type:reflect.Value <UsedInIface> -> type:.namedata.Field.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByIndexErr.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByName.
type:reflect.Value <UsedInIface> -> type:.namedata.FieldByNameFunc.
type:reflect.Value <UsedInIface> -> type:.namedata.Float.
type:reflect.Value <UsedInIface> -> type:.namedata.Grow.
type:reflect.Value <UsedInIface> -> type:.namedata.Index.
type:reflect.Value <UsedInIface> -> type:.namedata.Int.
type:reflect.Value <UsedInIface> -> type:.namedata.Interface.
type:reflect.Value <UsedInIface> -> type:.namedata.InterfaceData.
type:reflect.Value <UsedInIface> -> type:.namedata.IsNil.
type:reflect.Value <UsedInIface> -> type:.namedata.IsValid.
type:reflect.Value <UsedInIface> -> type:.namedata.IsZero.
type:reflect.Value <UsedInIface> -> type:.namedata.MapIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.MapKeys.
type:reflect.Value <UsedInIface> -> type:.namedata.MapRange.
type:reflect.Value <UsedInIface> -> type:.namedata.Method.
type:reflect.Value <UsedInIface> -> type:.namedata.MethodByName.
type:reflect.Value <UsedInIface> -> type:.namedata.NumField.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowInt.
type:reflect.Value <UsedInIface> -> type:.namedata.OverflowUint.
type:reflect.Value <UsedInIface> -> type:.namedata.Pointer.
type:reflect.Value <UsedInIface> -> type:.namedata.Recv.
type:reflect.Value <UsedInIface> -> type:.namedata.Send.
type:reflect.Value <UsedInIface> -> type:.namedata.SetBool.
type:reflect.Value <UsedInIface> -> type:.namedata.SetBytes.
type:reflect.Value <UsedInIface> -> type:.namedata.SetCap.
type:reflect.Value <UsedInIface> -> type:.namedata.SetComplex.
type:reflect.Value <UsedInIface> -> type:.namedata.SetFloat.
type:reflect.Value <UsedInIface> -> type:.namedata.SetInt.
type:reflect.Value <UsedInIface> -> type:.namedata.SetIterKey.
type:reflect.Value <UsedInIface> -> type:.namedata.SetIterValue.
type:reflect.Value <UsedInIface> -> type:.namedata.SetLen.
type:reflect.Value <UsedInIface> -> type:.namedata.SetMapIndex.
type:reflect.Value <UsedInIface> -> type:.namedata.SetPointer.
type:reflect.Value <UsedInIface> -> type:.namedata.SetString.
type:reflect.Value <UsedInIface> -> type:.namedata.SetUint.
type:reflect.Value <UsedInIface> -> type:.namedata.SetZero.
type:reflect.Value <UsedInIface> -> type:.namedata.Slice.
type:reflect.Value <UsedInIface> -> type:.namedata.Slice3.
type:reflect.Value <UsedInIface> -> type:.namedata.TryRecv.
type:reflect.Value <UsedInIface> -> type:.namedata.TrySend.
type:reflect.Value <UsedInIface> -> type:.namedata.Type.
type:reflect.Value <UsedInIface> -> type:.namedata.Uint.
type:reflect.Value <UsedInIface> -> type:.namedata.UnsafeAddr.
type:reflect.Value <UsedInIface> -> type:.namedata.UnsafePointer.
type:reflect.Value <UsedInIface> -> type:.namedata.assignTo-
type:reflect.Value <UsedInIface> -> type:.namedata.bytesSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.call-
type:reflect.Value <UsedInIface> -> type:.namedata.capNonSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.extendSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.grow-
type:reflect.Value <UsedInIface> -> type:.namedata.lenNonSlice-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBe-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeAssignable-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeAssignableSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeExported-
type:reflect.Value <UsedInIface> -> type:.namedata.mustBeExportedSlow-
type:reflect.Value <UsedInIface> -> type:.namedata.panicNotBool-
type:reflect.Value <UsedInIface> -> type:.namedata.panicNotMap-
type:reflect.Value <UsedInIface> -> type:.namedata.pointer-
type:reflect.Value <UsedInIface> -> type:.namedata.recv-
type:reflect.Value <UsedInIface> -> type:.namedata.ro-
type:reflect.Value <UsedInIface> -> type:.namedata.runes-
type:reflect.Value <UsedInIface> -> type:.namedata.send-
type:reflect.Value <UsedInIface> -> type:.namedata.setRunes-
type:reflect.Value <UsedInIface> -> type:.namedata.stringNonString-
type:reflect.Value <UsedInIface> -> type:.namedata.typeSlow-
type:reflect.flag <UsedInIface> -> type:.namedata.*reflect.flag-
type:reflect.flag <UsedInIface> -> type:*reflect.flag <UsedInIface>
type:reflect.Type -> type:.namedata.*reflect.Type.
type:reflect.Type -> type:*reflect.Type
type:reflect.Type -> type:func() int <UsedInIface>
type:reflect.Type -> type:.namedata.AssignableTo.
type:reflect.Type -> type:func(reflect.Type) bool <UsedInIface>
type:reflect.Type -> type:.namedata.Bits.
type:reflect.Type -> type:func() reflect.ChanDir
type:reflect.Type -> type:.namedata.ConvertibleTo.
type:reflect.Type -> type:func() reflect.Type <UsedInIface>
type:reflect.Type -> type:func(int) reflect.StructField
type:reflect.Type -> type:func([]int) reflect.StructField
type:reflect.Type -> type:func(string) (reflect.StructField, bool)
type:reflect.Type -> type:func(func(string) bool) (reflect.StructField, bool)
type:reflect.Type -> type:.namedata.Implements.
type:reflect.Type -> type:.namedata.In.
type:reflect.Type -> type:func(int) reflect.Type
type:reflect.Type -> type:.namedata.IsVariadic.
type:reflect.Type -> type:func() reflect.Kind <UsedInIface>
type:reflect.Type -> type:func(int) reflect.Method
type:reflect.Type -> type:func(string) (reflect.Method, bool)
type:reflect.Type -> type:.namedata.NumIn.
type:reflect.Type -> type:.namedata.NumOut.
type:reflect.Type -> type:.namedata.Out.
type:reflect.Type -> type:func() uintptr <UsedInIface>
type:reflect.Type -> type:.namedata.common-
type:reflect.Type -> type:func() *internal/abi.Type <UsedInIface>
type:reflect.Type -> type:.namedata.uncommon-
type:reflect.Type -> type:func() *internal/abi.UncommonType <UsedInIface>
type:reflect.abiStep -> type:.namedata.*reflect.abiStep-
type:reflect.abiStep -> type:*reflect.abiStep
type:reflect.abiStep -> type:reflect.abiStepKind
type:reflect.abiStep -> type:.namedata.stkOff-
type:reflect.abiStep -> type:.namedata.ireg-
type:reflect.abiStep -> type:.namedata.freg-
type:reflect.abiStepKind -> type:.namedata.*reflect.abiStepKind-
type:reflect.abiStepKind -> type:*reflect.abiStepKind
type:reflect.bitVector -> type:.namedata.*reflect.bitVector-
type:reflect.bitVector -> type:*reflect.bitVector
type:*reflect.bitVector -> type:.namedata.append-
type:reflect.layoutKey <UsedInIface> -> type:.namedata.*reflect.layoutKey-
type:reflect.layoutKey <UsedInIface> -> type:*reflect.layoutKey <UsedInIface>
type:reflect.layoutKey <UsedInIface> -> type:.namedata.ftyp-
type:reflect.layoutKey <UsedInIface> -> type:*internal/abi.FuncType <UsedInIface>
type:reflect.layoutKey <UsedInIface> -> type:.namedata.rcvr-
type:reflect.abiSeq -> type:.namedata.*reflect.abiSeq-
type:reflect.abiSeq -> type:*reflect.abiSeq
type:reflect.abiSeq -> type:.namedata.steps-
type:reflect.abiSeq -> type:[]reflect.abiStep
type:reflect.abiSeq -> type:.namedata.valueStart-
type:reflect.abiSeq -> type:.namedata.stackBytes-
type:reflect.abiSeq -> type:.namedata.iregs-
type:reflect.abiSeq -> type:.namedata.fregs-
type:*reflect.abiSeq -> type:.namedata.addArg-
type:*reflect.abiSeq -> type:.namedata.addRcvr-
type:*reflect.abiSeq -> type:.namedata.assignFloatN-
type:*reflect.abiSeq -> type:.namedata.assignIntN-
type:*reflect.abiSeq -> type:.namedata.dump-
type:*reflect.abiSeq -> type:.namedata.regAssign-
type:*reflect.abiSeq -> type:.namedata.stackAssign-
type:*reflect.abiSeq -> type:.namedata.stepsForValue-
type:reflect.layoutType <UsedInIface> -> runtime.gcbits.2748800000000000
type:reflect.layoutType <UsedInIface> -> type:.namedata.*reflect.layoutType-
type:reflect.layoutType <UsedInIface> -> type:*reflect.layoutType <UsedInIface>
type:reflect.layoutType <UsedInIface> -> type:.namedata.t-
type:reflect.layoutType <UsedInIface> -> type:.namedata.framePool-
type:reflect.layoutType <UsedInIface> -> type:*sync.Pool <UsedInIface>
type:reflect.layoutType <UsedInIface> -> type:.namedata.abid-
type:reflect.layoutType <UsedInIface> -> type:reflect.abiDesc <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> runtime.gcbits.0912200000000000
type:reflect.abiDesc <UsedInIface> -> type:.namedata.*reflect.abiDesc-
type:reflect.abiDesc <UsedInIface> -> type:*reflect.abiDesc <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:reflect.abiSeq <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:.namedata.stackCallArgsSize-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.retOffset-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.spill-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.stackPtrs-
type:reflect.abiDesc <UsedInIface> -> type:*reflect.bitVector <UsedInIface>
type:reflect.abiDesc <UsedInIface> -> type:.namedata.inRegPtrs-
type:reflect.abiDesc <UsedInIface> -> type:.namedata.outRegPtrs-
type:*reflect.bitVector <UsedInIface> -> type:reflect.bitVector <UsedInIface>
type:reflect.abiSeq <UsedInIface> -> type:*reflect.abiSeq <UsedInIface>
type:reflect.abiSeq <UsedInIface> -> type:[]reflect.abiStep <UsedInIface>
type:reflect.ValueError -> type:.eqfunc.reflect.ValueError
type:reflect.ValueError -> type:.namedata.*reflect.ValueError.
type:reflect.ValueError -> type:reflect.Kind
type:reflect.Kind -> type:.namedata.*reflect.Kind.
type:reflect.Kind -> type:*reflect.Kind
type:*reflect.ValueError <UsedInIface> -> type:reflect.ValueError <UsedInIface>
type:reflect.ValueError <UsedInIface> -> type:reflect.Kind <UsedInIface>
type:reflect.Kind <UsedInIface> -> type:*reflect.Kind <UsedInIface>
type:reflect.methodValue -> type:.eqfunc.reflect.methodValue
type:reflect.methodValue -> runtime.gcbits.6200000000000000
type:reflect.methodValue -> type:.namedata.*reflect.methodValue-
type:reflect.methodValue -> type:*reflect.methodValue
type:reflect.methodValue -> type:.namedata.makeFuncCtxt-.embedded
type:reflect.methodValue -> type:reflect.makeFuncCtxt
type:reflect.methodValue -> type:.namedata.method-
type:reflect.makeFuncCtxt -> type:.eqfunc.reflect.makeFuncCtxt
type:reflect.makeFuncCtxt -> type:.namedata.*reflect.makeFuncCtxt-
type:reflect.makeFuncCtxt -> type:*reflect.makeFuncCtxt
type:reflect.makeFuncCtxt -> type:.namedata.argLen-
type:reflect.makeFuncCtxt -> type:.namedata.regPtrs-
 -> go:info.sync.Map
 -> go:info.*reflect.abiSeq
 -> go:info.*reflect.abiStep
 -> go:info.reflect.abiSeq
 -> go:info.internal/abi.(*Type).Size$abstract
 -> go:info.internal/abi.(*Type).Align$abstract
 -> go:info.reflect.(*abiSeq).stackAssign$abstract
 -> go:info.reflect.align$abstract
 -> go:info.reflect.ifaceIndir$abstract
 -> go:info.internal/abi.(*Type).Pointers$abstract
 -> go:info.*reflect.structType
 -> go:info.reflect.(*abiSeq).assignFloatN$abstract
 -> go:info.reflect.abiStepKind
 -> go:info.reflect.abiDesc
 -> go:info.*reflect.bitVector
 -> go:info.internal/abi.IntArgRegBitmap
 -> go:info.reflect.abiStep
 -> go:info.reflect.(*bitVector).append$abstract
 -> go:info.reflect.(*abiSeq).stepsForValue$abstract
 -> go:info.internal/abi.(*IntArgRegBitmap).Set$abstract
 -> go:info.reflect.flag
 -> go:info.*reflect.methodValue
 -> go:info.reflect.methodValueCallCodePtr$abstract
 -> go:info.*reflect.rtype
 -> go:info.reflect.(*rtype).nameOff$abstract
 -> go:info.reflect.(*rtype).uncommon$abstract
 -> go:info.internal/abi.(*UncommonType).ExportedMethods$abstract
 -> go:info.*reflect.interfaceType
 -> go:info.reflect.(*rtype).Kind$abstract
 -> go:info.reflect.(*interfaceType).NumMethod$abstract
 -> go:info.*sync.Pool
 -> go:info.reflect.layoutKey
 -> go:info.reflect.layoutType
 -> go:info.reflect.stringFor$abstract
 -> go:info.reflect.newName$abstract
 -> go:info.reflect.resolveReflectName$abstract
 -> go:info.*[5]uintptr
 -> go:info.*runtime.Frames
 -> go:info.runtime.Frame
 -> go:info.runtime.Callers$abstract
 -> go:info.runtime.CallersFrames$abstract
 -> go:info.internal/abi.(*Type).Elem$abstract
 -> go:info.reflect.(*interfaceType).nameOff$abstract
 -> go:info.reflect.(*interfaceType).typeOff$abstract
 -> go:info.reflect.(*rtype).typeOff$abstract
 -> go:info.reflect.nameOffFor$abstract
 -> go:info.reflect.textOffFor$abstract
 -> go:info.reflect.(*rtype).textOff$abstract
 -> go:info.reflect.typeOffFor$abstract
 -> go:info.reflect.Kind
 -> go:info.reflect.flag.ro$abstract
 -> go:info.internal/abi.(*StructField).Embedded$abstract
 -> go:info.reflect.add$abstract
 -> go:info.reflect.arrayAt$abstract
 -> go:info.reflect.Value.pointer$abstract
 -> go:info.internal/abi.(*Type).Len$abstract
 -> go:info.reflect.(*hiter).initialized$abstract
 -> go:info.reflect.flag.mustBe$abstract
sync.(*Map).Load -> type:map[interface {}]*sync.entry
sync.(*Map).Load -> sync.(*Mutex).lockSlow
sync.(*Map).Load -> sync.(*Map).missLocked
sync.(*Map).Load -> sync.(*Mutex).unlockSlow
sync.(*Map).Load -> sync.expunged
sync.(*Map).Load -> gclocals·wl1vtBOUPMe6N1JPefYkhQ==
sync.(*Map).Load -> gclocals·jJ8ja1/jmWH9tDQl2RSkDQ==
sync.(*Map).Load -> reflect.(*visibleFieldsWalker).walk.stkobj
sync.(*Map).Load -> reflect.(*visibleFieldsWalker).walk.argliveinfo
sync.(*Map).LoadOrStore -> sync.(*entry).tryLoadOrStore
sync.(*Map).LoadOrStore -> sync/atomic.CompareAndSwapPointer
sync.(*Map).LoadOrStore -> sync.(*Map).dirtyLocked
sync.(*Map).LoadOrStore -> type:sync.readOnly
sync.(*Map).LoadOrStore -> sync/atomic.StorePointer
sync.(*Map).LoadOrStore -> type:sync.entry
sync.(*Map).LoadOrStore -> gclocals·HC21lmAga297N7vuzGHUDg==
sync.(*Map).LoadOrStore -> gclocals·DbWXrTdeWrUuY0ozKt2L1A==
sync.(*Map).dirtyLocked -> runtime.mapiterinit
sync.(*Map).dirtyLocked -> runtime.mapiternext
sync.(*Map).dirtyLocked -> sync.(*entry).tryExpungeLocked
sync.(*Map).dirtyLocked -> gclocals·0YkhjsCmC49K4GW90hRS7A==
sync.(*Map).dirtyLocked -> sync.(*Map).dirtyLocked.stkobj
sync.(*Mutex).lockSlow -> sync.runtime_canSpin
sync.(*Mutex).lockSlow -> go:string."sync: inconsistent mutex state"
sync.(*Mutex).lockSlow -> sync.throw
sync.(*Mutex).lockSlow -> sync.runtime_nanotime
sync.(*Mutex).lockSlow -> sync.runtime_SemacquireMutex
sync.(*Mutex).lockSlow -> sync.runtime_doSpin
sync.(*Mutex).unlockSlow -> go:string."sync: unlock of unlocked mutex"
sync.(*Mutex).unlockSlow -> sync.fatal
sync.(*Mutex).unlockSlow -> sync.runtime_Semrelease
sync.(*Pool).Put -> sync.(*Pool).pin
sync.(*Pool).Put -> sync.(*poolChain).pushHead
sync.(*Pool).Put -> sync.runtime_procUnpin
sync.(*Pool).Get -> sync.(*poolChain).popHead
sync.(*Pool).Get -> sync.(*Pool).getSlow
sync.(*Pool).getSlow -> sync.(*poolChain).popTail
sync.(*Pool).pin -> sync.runtime_procPin
sync.(*Pool).pin -> sync.(*Pool).pinSlow
sync.(*Pool).pin -> sync..stmp_4
sync.(*Pool).pinSlow -> sync.allPoolsMu
sync.(*Pool).pinSlow -> sync.(*Pool).pinSlow.deferwrap1
sync.(*Pool).pinSlow -> sync.allPools
sync.(*Pool).pinSlow -> runtime.GOMAXPROCS
sync.(*Pool).pinSlow -> type:sync.poolLocal
sync.(*Pool).pinSlow -> gclocals·JmGfyNPPelOiSzqL1jXHRA==
sync.(*Pool).pinSlow -> fmt.(*ss).Token.opendefer
sync.(*Pool).pinSlow.deferwrap1 -> sync.(*Mutex).Unlock.wrapinfo
sync.(*poolChain).pushHead -> type:sync.poolChainElt
sync.(*poolChain).pushHead -> type:sync.eface
sync.(*poolChain).pushHead -> sync.(*poolDequeue).pushHead
sync.(*poolChain).pushHead -> gclocals·mlqWOeCrrO7xsUuS1KsOLQ==
sync.(*poolDequeue).pushHead -> type:sync.dequeueNil <UsedInIface>
sync.(*poolChain).popHead -> sync.(*poolDequeue).popHead
sync.(*poolChain).popTail -> sync.(*poolDequeue).popTail
type:sync.dequeueNil <UsedInIface> -> type:.namedata.*sync.dequeueNil-
type:sync.dequeueNil <UsedInIface> -> type:struct {} <UsedInIface>
type:sync.dequeueNil <UsedInIface> -> type:.importpath.sync.
type:sync.eface -> type:.namedata.*sync.eface-
type:sync.eface -> type:*sync.eface
type:sync.poolChainElt -> runtime.gcbits.3200000000000000
type:sync.poolChainElt -> type:.namedata.*sync.poolChainElt-
type:sync.poolChainElt -> type:*sync.poolChainElt
type:sync.poolChainElt -> type:.namedata.poolDequeue-.embedded
type:sync.poolChainElt -> type:sync.poolDequeue
type:*sync.poolChainElt -> type:.namedata.pack-
type:*sync.poolChainElt -> type:.namedata.popHead-
type:*sync.poolChainElt -> type:.namedata.popTail-
type:*sync.poolChainElt -> type:.namedata.pushHead-
type:*sync.poolChainElt -> type:.namedata.unpack-
type:sync.poolDequeue -> type:.namedata.*sync.poolDequeue-
type:sync.poolDequeue -> type:*sync.poolDequeue
type:sync.poolDequeue -> type:.namedata.headTail-
type:sync.poolDequeue -> type:sync/atomic.Uint64
type:sync.poolDequeue -> type:.namedata.vals-
type:sync.poolDequeue -> type:[]sync.eface
type:sync.poolLocal -> type:.eqfunc.sync.poolLocal
type:sync.poolLocal -> type:.namedata.*sync.poolLocal-
type:sync.poolLocal -> type:*sync.poolLocal
type:sync.poolLocal -> type:.namedata.poolLocalInternal-.embedded
type:sync.poolLocal -> type:sync.poolLocalInternal
type:sync.poolLocal -> type:[96]uint8
type:sync.poolLocalInternal -> type:.eqfunc.sync.poolLocalInternal
type:sync.poolLocalInternal -> type:.namedata.*sync.poolLocalInternal-
type:sync.poolLocalInternal -> type:*sync.poolLocalInternal
type:sync.poolLocalInternal -> type:.namedata.private-
type:sync.poolLocalInternal -> type:.namedata.shared-
type:sync.poolLocalInternal -> type:sync.poolChain
type:sync.poolChain -> type:.namedata.*sync.poolChain-
type:sync.poolChain -> type:*sync.poolChain
type:sync.poolChain -> type:.namedata.tail-
type:sync.Pool -> type:.namedata.*sync.Pool.
type:sync.Pool -> type:sync.noCopy
type:sync.Pool -> type:.namedata.local-
type:sync.Pool -> type:.namedata.localSize-
type:sync.Pool -> type:.namedata.victim-
type:sync.Pool -> type:.namedata.victimSize-
type:sync.Pool -> type:.namedata.New.
type:sync.Pool -> type:func() interface {} <UsedInIface>
type:sync.noCopy -> type:.namedata.*sync.noCopy-
type:sync.noCopy -> type:*sync.noCopy
type:*sync.Pool <UsedInIface> -> type:sync.Pool <UsedInIface>
type:*sync.Pool <UsedInIface> -> type:.namedata.Put.
type:*sync.Pool <UsedInIface> -> type:.namedata.getSlow-
type:*sync.Pool <UsedInIface> -> type:.namedata.pin-
type:*sync.Pool <UsedInIface> -> type:.namedata.pinSlow-
type:sync.Pool <UsedInIface> -> type:sync.noCopy <UsedInIface>
type:sync.noCopy <UsedInIface> -> type:*sync.noCopy <UsedInIface>
type:sync.entry -> type:.eqfunc.sync.entry
type:sync.entry -> type:.namedata.*sync.entry-
type:sync.entry -> type:*sync.entry
type:sync.entry -> type:sync/atomic.Pointer[interface {}]
type:*sync.entry -> type:.namedata.delete-
type:*sync.entry -> type:.namedata.load-
type:*sync.entry -> type:.namedata.swapLocked-
type:*sync.entry -> type:.namedata.tryCompareAndSwap-
type:*sync.entry -> type:.namedata.tryExpungeLocked-
type:*sync.entry -> type:.namedata.tryLoadOrStore-
type:*sync.entry -> type:.namedata.trySwap-
type:*sync.entry -> type:.namedata.unexpungeLocked-
type:sync.readOnly -> type:.namedata.*sync.readOnly-
type:sync.readOnly -> type:*sync.readOnly
type:sync.readOnly -> type:.namedata.amended-
 -> go:info.*interface {}
 -> go:info.sync.Mutex
 -> go:info.[]*sync.Pool
 -> go:info.*sync.Map
 -> go:info.*sync.entry
 -> go:info.sync.readOnly
 -> go:info.sync.(*Map).loadReadOnly$abstract
 -> go:info.sync.(*Mutex).Lock$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Load$abstract
 -> go:info.sync.(*Mutex).Unlock$abstract
 -> go:info.sync.(*entry).load$abstract
 -> go:info.map[interface {}]*sync.entry
 -> go:info.sync.(*entry).unexpungeLocked$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract
 -> go:info.sync.newEntry$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).Store$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.interface {}]).Load$abstract
 -> go:info.*sync.Mutex
 -> go:info.*sync.poolLocal
 -> go:info.sync.indexLocal$abstract
 -> go:info.[]sync.poolLocal
 -> go:info.*sync.poolDequeue
 -> go:info.sync.(*poolDequeue).unpack$abstract
 -> go:info.sync/atomic.(*Uint64).Add$abstract
 -> go:info.sync.(*poolDequeue).pack$abstract
 -> go:info.sync/atomic.(*Uint64).CompareAndSwap$abstract
 -> go:info.*sync.poolChain
 -> go:info.*sync.poolChainElt
 -> go:info.sync.storePoolChainElt$abstract
 -> go:info.sync.loadPoolChainElt$abstract
demo/pkgb.Zoo -> math/rand.Int31n
demo/pkgb.Zoo -> demo/pkgb..stmp_0
 -> go:info.fmt.Println$abstract
runtime.GOMAXPROCS -> runtime.stopTheWorldGC
runtime.GOMAXPROCS -> runtime.startTheWorldGC
runtime.convTslice -> runtime.sliceType
runtime.typeAssert -> runtime.buildTypeAssertCache
runtime.typeAssert -> gclocals·7XBZTuTlonMHIcAyzzmwZw==
runtime.typeAssert -> gclocals·ePW95ktOFWGamzaSGhlW/g==
runtime.mapiternext -> go:string."concurrent map iteration and map write"
runtime.mapiternext -> runtime.mapaccessK
runtime.mapiternext -> gclocals·zRZBaN0Lhivk+9i/uk5tJg==
runtime.deferprocStack -> runtime.return0
runtime.deferprocStack -> go:string."defer on system stack"
runtime.stopTheWorldGC -> runtime.stopTheWorld
runtime.stopTheWorld -> runtime.stopTheWorld.func1
runtime.stopTheWorld -> runtime.stopTheWorldContext
runtime.startTheWorldGC -> runtime.startTheWorld
runtime.startTheWorld -> runtime.startTheWorld.func1
runtime.concatstring5 -> gclocals·xX7X77/6/gwCrnInbrSwQg==
runtime.concatstring5 -> gclocals·0XJawOT6f8RgJWfORwBNwg==
runtime.concatstring5 -> runtime.concatstring5.stkobj
runtime.concatstring5 -> runtime.concatstring5.arginfo1
runtime.concatstring5 -> runtime.concatstring5.argliveinfo
runtime.(*Frames).Next -> runtime.expandCgoFrames
runtime.(*Frames).Next -> type:runtime.Frame
runtime.(*Frames).Next -> runtime.(*Func).Entry
runtime.(*Frames).Next -> gclocals·91POOaJmbl2xpndDwSmh3g==
runtime.(*Frames).Next -> gclocals·B2oUFxyRBzOEjY0gjvIplQ==
runtime.(*Frames).Next -> runtime.(*Frames).Next.arginfo1
runtime.(*Frames).Next -> runtime.(*Frames).Next.argliveinfo
runtime.expandCgoFrames -> gclocals·3CgL1OMj4PK20UKKkS8Bfw==
runtime.expandCgoFrames -> gclocals·9+nlwXvPdXd+ayC10bSu/w==
runtime.expandCgoFrames -> runtime.expandCgoFrames.stkobj
runtime.panicunsafeslicenilptr -> runtime.panicunsafeslicenilptr1
runtime.panicunsafeslicenilptr1 -> go:string."unsafe.Slice: ptr is nil and len is not zero"
runtime.panicunsafeslicenilptr1 -> runtime..stmp_191
type:runtime.Frame -> type:.eqfunc.runtime.Frame
type:runtime.Frame -> os..stmp_5
type:runtime.Frame -> type:.namedata.*runtime.Frame.
type:runtime.Frame -> type:*runtime.Frame
type:runtime.Frame -> type:.namedata.PC.
type:runtime.Frame -> type:.namedata.Func.
type:runtime.Frame -> type:*runtime.Func
type:runtime.Frame -> type:.namedata.Function.
type:runtime.Frame -> type:.namedata.File.
type:runtime.Frame -> type:.namedata.Line.
type:runtime.Frame -> type:.namedata.startLine-
type:runtime.Frame -> type:.namedata.Entry.
type:runtime.Frame -> type:.namedata.funcInfo-
type:runtime.Frame -> type:runtime.funcInfo
type:runtime.funcInfo -> type:.namedata.*runtime.funcInfo-
type:runtime.funcInfo -> type:*runtime.funcInfo
type:runtime.funcInfo -> type:.namedata._func-.embedded
type:runtime.funcInfo -> type:*runtime._func
type:runtime.funcInfo -> type:.namedata.datap-
type:runtime.funcInfo -> type:.namedata._Func-
type:runtime.funcInfo -> type:.namedata.entry-
type:runtime.funcInfo -> type:.namedata.isInlined-
type:runtime.funcInfo -> type:.namedata.srcFunc-
type:runtime.funcInfo -> type:.namedata.valid-
type:*runtime._func -> type:.namedata.*runtime._func-
type:*runtime._func -> type:runtime._func
type:runtime._func -> type:.eqfunc.runtime._func
type:runtime._func -> type:.namedata.entryOff-
type:runtime._func -> type:.namedata.nameOff-
type:runtime._func -> type:.namedata.pcsp-
type:runtime._func -> type:.namedata.pcfile-
type:runtime._func -> type:.namedata.pcln-
type:runtime._func -> type:.namedata.npcdata-
type:runtime._func -> type:.namedata.funcID-
type:runtime._func -> type:internal/abi.FuncID
type:runtime._func -> type:.namedata.flag-
type:runtime._func -> type:internal/abi.FuncFlag
type:runtime._func -> type:[1]uint8
type:runtime._func -> type:.namedata.nfuncdata-
type:*runtime.Func -> type:.namedata.*runtime.Func.
type:*runtime.Func -> type:runtime.Func
type:*runtime.Func -> type:.namedata.FileLine.
type:*runtime.Func -> type:.namedata.raw-
type:runtime.Func -> type:.namedata.opaque-
 -> go:info.internal/abi.TypeAssertCache
type:runtime.Frames -> runtime.gcbits.89052c0000000000
type:runtime.Frames -> type:.namedata.*runtime.Frames.
type:runtime.Frames -> type:*runtime.Frames
type:runtime.Frames -> type:.namedata.callers-
type:runtime.Frames -> type:.namedata.frames-
type:runtime.Frames -> type:[]runtime.Frame
type:runtime.Frames -> type:.namedata.frameStore-
type:runtime.Frames -> type:[2]runtime.Frame
 -> go:info.runtime.panicdottypeE$abstract
 -> go:info.*internal/abi.TypeAssert
 -> go:info.*internal/abi.TypeAssertCache
 -> go:info.[]internal/abi.TypeAssertCacheEntry
 -> go:info.runtime.buildTypeAssertCache.func1$abstract
 -> go:info.*runtime.hiter
 -> go:info.*runtime.Func
 -> go:info.[]runtime.Frame
 -> go:info.*runtime._func
 -> go:info.*runtime.funcinl
 -> go:info.runtime.(*_func).isInlined$abstract
 -> go:info.runtime.(*_func).funcInfo$abstract
type:sync/atomic.Uint64 -> type:.eqfunc.sync/atomic.Uint64
type:sync/atomic.Uint64 -> type:*sync/atomic.Uint64
type:sync/atomic.Uint64 -> type:.importpath.sync/atomic.
type:sync/atomic.Uint64 -> type:sync/atomic.noCopy
type:sync/atomic.Uint64 -> type:sync/atomic.align64
type:sync/atomic.Uint64 -> type:.namedata.v-
type:sync/atomic.noCopy -> type:*sync/atomic.noCopy
type:sync/atomic.align64 -> type:*sync/atomic.align64
internal/abi.(*Type).ExportedMethods -> internal/abi.(*Type).ExportedMethods.jump7
internal/abi.NewName -> go:string."abi.NewName: tag too long: "
internal/abi.NewName -> go:string."abi.NewName: name too long: "
internal/abi.NewName -> gclocals·TvPEz2KMfo+ULBIyE3rwXg==
internal/abi.NewName -> gclocals·zshnMFzKa7rpeOD7D+TwQg==
internal/abi.NewName -> reflect.newName.arginfo1
type:*internal/abi.FuncType <UsedInIface> -> type:.namedata.*abi.FuncType.
type:*internal/abi.FuncType <UsedInIface> -> type:internal/abi.FuncType <UsedInIface>
type:*internal/abi.FuncType <UsedInIface> -> type:.namedata.InSlice.
type:*internal/abi.FuncType <UsedInIface> -> type:.namedata.OutSlice.
type:internal/abi.FuncType <UsedInIface> -> type:.namedata.InCount.
type:internal/abi.FuncType <UsedInIface> -> type:.namedata.OutCount.
type:internal/abi.FuncFlag -> type:.namedata.*abi.FuncFlag.
type:internal/abi.FuncFlag -> type:*internal/abi.FuncFlag
type:internal/abi.FuncID -> type:.namedata.*abi.FuncID.
type:internal/abi.FuncID -> type:*internal/abi.FuncID
 -> go:info.internal/abi.(*InterfaceType).NumMethod$abstract
 -> go:info.[10]uint8
 -> go:info.internal/abi.writeVarint$abstract
math/rand.Int31n -> math/rand.globalRand
math/rand.Int31n -> math/rand.(*Rand).Int31n
math/rand.(*Rand).Int31n -> math/rand..stmp_2
math/rand.globalRand -> math/rand.globalRandGenerator
math/rand.globalRand -> math/rand.randautoseed
math/rand.globalRand -> internal/godebug.(*Setting).Value
math/rand.globalRand -> internal/godebug.(*Setting).IncNonDefault
math/rand.globalRand -> type:math/rand.lockedSource
math/rand.globalRand -> go:itab.*math/rand.lockedSource,math/rand.Source
math/rand.globalRand -> math/rand..typeAssert.1
math/rand.globalRand -> type:math/rand.runtimeSource
math/rand.globalRand -> type:math/rand.Rand
math/rand.globalRand -> go:itab.*math/rand.runtimeSource,math/rand.Source
math/rand.globalRand -> go:itab.*math/rand.runtimeSource,math/rand.Source64
math/rand.globalRand -> math/rand.(*Rand).Seed
math/rand.globalRand -> gclocals·y2myd90gcz6n6i1artuXJQ==
math/rand.(*Rand).Seed -> math/rand.(*lockedSource).seedPos
math/rand.(*lockedSource).seedPos -> math/rand.(*lockedSource).seed
math/rand.(*lockedSource).seed -> math/rand.(*rngSource).Seed
math/rand.(*lockedSource).seed -> type:math/rand.rngSource
math/rand.(*rngSource).Seed -> math/rand.rngCooked
type:math/rand.rngSource -> type:.eqfunc4872
type:math/rand.rngSource -> type:.namedata.*rand.rngSource-
type:math/rand.rngSource -> type:*math/rand.rngSource
type:math/rand.rngSource -> type:.importpath.math/rand.
type:math/rand.rngSource -> type:.namedata.tap-
type:math/rand.rngSource -> type:.namedata.feed-
type:math/rand.rngSource -> type:.namedata.vec-
type:math/rand.rngSource -> type:[607]int64
type:*math/rand.rngSource -> type:.namedata.Int63.
type:*math/rand.rngSource -> type:.namedata.Seed.
type:*math/rand.rngSource -> type:.namedata.Uint64.
type:math/rand.lockedSource -> type:.namedata.*rand.lockedSource-
type:math/rand.lockedSource -> type:*math/rand.lockedSource <UsedInIface>
type:math/rand.lockedSource -> type:.namedata.lk-
type:math/rand.lockedSource -> type:sync.Mutex
type:sync.Mutex -> type:.namedata.*sync.Mutex.
type:sync.Mutex -> type:*sync.Mutex
type:sync.Mutex -> type:.namedata.sema-
type:*sync.Mutex -> type:.namedata.TryLock.
type:*sync.Mutex -> type:.namedata.lockSlow-
type:*sync.Mutex -> type:.namedata.unlockSlow-
type:*math/rand.lockedSource <UsedInIface> -> type:math/rand.lockedSource <UsedInIface>
type:*math/rand.lockedSource <UsedInIface> -> type:.namedata.read-
type:*math/rand.lockedSource <UsedInIface> -> type:.namedata.seedPos-
type:math/rand.lockedSource <UsedInIface> -> type:sync.Mutex <UsedInIface>
type:math/rand.lockedSource <UsedInIface> -> type:*math/rand.rngSource <UsedInIface>
type:sync.Mutex <UsedInIface> -> type:*sync.Mutex <UsedInIface>
type:*math/rand.rngSource <UsedInIface> -> type:math/rand.rngSource <UsedInIface>
type:math/rand.rngSource <UsedInIface> -> type:[607]int64 <UsedInIface>
type:math/rand.runtimeSource -> type:.namedata.*rand.runtimeSource-
type:math/rand.runtimeSource -> type:*math/rand.runtimeSource <UsedInIface>
type:math/rand.runtimeSource -> type:.namedata.mu-
type:*math/rand.runtimeSource <UsedInIface> -> type:math/rand.runtimeSource <UsedInIface>
type:math/rand.Rand -> type:.eqfunc.math/rand.Rand
type:math/rand.Rand -> type:.namedata.*rand.Rand.
type:math/rand.Rand -> type:*math/rand.Rand
type:math/rand.Rand -> type:.namedata.src-
type:math/rand.Rand -> type:math/rand.Source
type:math/rand.Rand -> type:.namedata.s64-
type:math/rand.Rand -> type:math/rand.Source64
type:math/rand.Rand -> type:.namedata.readVal-
type:math/rand.Rand -> type:.namedata.readPos-
type:math/rand.Source -> type:.namedata.*rand.Source.
type:math/rand.Source -> type:*math/rand.Source
type:math/rand.Source -> type:func() int64 <UsedInIface>
type:math/rand.Source -> type:func(int64) <UsedInIface>
type:math/rand.Source64 -> type:.namedata.*rand.Source64.
type:math/rand.Source64 -> type:*math/rand.Source64
type:math/rand.Source64 -> type:func() uint64 <UsedInIface>
type:*math/rand.Rand -> type:.namedata.ExpFloat64.
type:*math/rand.Rand -> type:.namedata.Float32.
type:*math/rand.Rand -> type:.namedata.Float64.
type:*math/rand.Rand -> type:.namedata.Int31.
type:*math/rand.Rand -> type:.namedata.Int31n.
type:*math/rand.Rand -> type:.namedata.Int63n.
type:*math/rand.Rand -> type:.namedata.Intn.
type:*math/rand.Rand -> type:.namedata.NormFloat64.
type:*math/rand.Rand -> type:.namedata.Perm.
type:*math/rand.Rand -> type:.namedata.Read.
type:*math/rand.Rand -> type:.namedata.Shuffle.
type:*math/rand.Rand -> type:.namedata.Uint32.
type:*math/rand.Rand -> type:.namedata.int31n-
 -> go:info.sync/atomic.Pointer[math/rand.Rand]
math/rand.randautoseed -> math/rand..stmp_0
 -> go:info.*internal/godebug.Setting
 -> go:info.[607]int64
math/rand..stmp_0 -> go:string."randautoseed"
 -> go:info.*math/rand.Rand
 -> go:info.math/rand.(*Rand).Int31$abstract
 -> go:info.math/rand.(*Rand).Int63$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }]).Load$abstract
 -> go:info.math/rand.New$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }]).CompareAndSwap$abstract
 -> go:info.*math/rand.lockedSource
 -> go:info.*int8
 -> go:info.*math/rand.rngSource
 -> go:info.math/rand.newSource$abstract
 -> go:info.math/rand.seedrand$abstract
internal/godebug.(*Setting).IncNonDefault -> internal/godebug.(*Setting).register-fm
internal/godebug.(*Setting).IncNonDefault -> sync.(*Once).doSlow
sync.(*Once).doSlow -> sync.(*Once).doSlow.deferwrap1
sync.(*Once).doSlow -> sync.(*Once).doSlow.deferwrap2
sync.(*Once).doSlow -> gclocals·h/pkaeCJVtF61d0LtRKFIw==
sync.(*Once).doSlow -> sync.(*Once).doSlow.stkobj
sync.(*Once).doSlow -> sync.(*Once).doSlow.opendefer
sync.(*Once).doSlow.deferwrap2 -> sync/atomic.(*Uint32).Store.wrapinfo
 -> go:info.*sync.Once
 -> go:info.sync/atomic.(*Uint32).Load$abstract
 -> go:info.sync/atomic.(*Uint32).Store$abstract
internal/godebug.(*Setting).Value -> internal/godebug.(*Setting).Value.func1
internal/godebug.(*Setting).Value -> go:itab.*internal/godebug.runtimeStderr,internal/bisect.Writer
internal/godebug.(*Setting).Value -> internal/godebug.stderr
internal/godebug.(*Setting).Value -> internal/bisect.(*Matcher).stack
internal/godebug.(*Setting).Value.func1 -> internal/godebug.lookup
internal/godebug.(*Setting).Value.func1 -> go:string."godebug: Value of name not listed in godebugs.All: "
internal/godebug.lookup -> internal/godebug.cache
internal/godebug.lookup -> type:internal/godebug.setting
internal/godebug.lookup -> internal/godebugs.All
internal/godebug.lookup -> type:*internal/godebug.setting <UsedInIface>
internal/godebug.lookup -> runtime.cmpstring
internal/godebug.lookup -> internal/godebug.empty
internal/godebug.lookup -> gclocals·rcqNgN2Sp1HgoM4S/4ArVQ==
internal/godebug.lookup -> gclocals·mr1CJip7CuoFvtViow0/xw==
internal/godebugs.All -> internal/godebugs..stmp_0
 -> go:info.[]internal/godebugs.Info
internal/godebugs..stmp_0 -> go:string."execerrdot"
internal/godebugs..stmp_0 -> go:string."os/exec"
internal/godebugs..stmp_0 -> go:string."gocachehash"
internal/godebugs..stmp_0 -> go:string."cmd/go"
internal/godebugs..stmp_0 -> go:string."gocachetest"
internal/godebugs..stmp_0 -> go:string."gocacheverify"
internal/godebugs..stmp_0 -> go:string."gotypesalias"
internal/godebugs..stmp_0 -> go:string."go/types"
internal/godebugs..stmp_0 -> go:string."http2client"
internal/godebugs..stmp_0 -> go:string."net/http"
internal/godebugs..stmp_0 -> go:string."http2debug"
internal/godebugs..stmp_0 -> go:string."http2server"
internal/godebugs..stmp_0 -> go:string."httplaxcontentlength"
internal/godebugs..stmp_0 -> go:string."1"
internal/godebugs..stmp_0 -> go:string."httpmuxgo121"
internal/godebugs..stmp_0 -> go:string."installgoroot"
internal/godebugs..stmp_0 -> go:string."go/build"
internal/godebugs..stmp_0 -> go:string."jstmpllitinterp"
internal/godebugs..stmp_0 -> go:string."html/template"
internal/godebugs..stmp_0 -> go:string."multipartmaxheaders"
internal/godebugs..stmp_0 -> go:string."mime/multipart"
internal/godebugs..stmp_0 -> go:string."multipartmaxparts"
internal/godebugs..stmp_0 -> go:string."multipathtcp"
internal/godebugs..stmp_0 -> go:string."net"
internal/godebugs..stmp_0 -> go:string."netdns"
internal/godebugs..stmp_0 -> go:string."runtime"
internal/godebugs..stmp_0 -> go:string."math/rand"
internal/godebugs..stmp_0 -> go:string."tarinsecurepath"
internal/godebugs..stmp_0 -> go:string."archive/tar"
internal/godebugs..stmp_0 -> go:string."tls10server"
internal/godebugs..stmp_0 -> go:string."crypto/tls"
internal/godebugs..stmp_0 -> go:string."tlsmaxrsasize"
internal/godebugs..stmp_0 -> go:string."tlsrsakex"
internal/godebugs..stmp_0 -> go:string."tlsunsafeekm"
internal/godebugs..stmp_0 -> go:string."x509sha1"
internal/godebugs..stmp_0 -> go:string."crypto/x509"
internal/godebugs..stmp_0 -> go:string."x509usefallbackroots"
internal/godebugs..stmp_0 -> go:string."x509usepolicies"
internal/godebugs..stmp_0 -> go:string."zipinsecurepath"
internal/godebugs..stmp_0 -> go:string."archive/zip"
type:*internal/godebug.setting <UsedInIface> -> type:.namedata.*godebug.setting-
type:*internal/godebug.setting <UsedInIface> -> type:internal/godebug.setting <UsedInIface>
type:internal/godebug.setting <UsedInIface> -> type:.eqfunc.internal/godebug.setting
type:internal/godebug.setting <UsedInIface> -> type:.importpath.internal/godebug.
type:internal/godebug.setting <UsedInIface> -> type:sync/atomic.Pointer[internal/godebug.value] <UsedInIface>
type:internal/godebug.setting <UsedInIface> -> type:.namedata.nonDefaultOnce-
type:internal/godebug.setting <UsedInIface> -> type:sync.Once <UsedInIface>
type:internal/godebug.setting <UsedInIface> -> type:.namedata.nonDefault-
type:internal/godebug.setting <UsedInIface> -> type:sync/atomic.Uint64 <UsedInIface>
type:internal/godebug.setting <UsedInIface> -> type:.namedata.info-
type:internal/godebug.setting <UsedInIface> -> type:*internal/godebugs.Info <UsedInIface>
type:sync.Once <UsedInIface> -> type:.eqfunc.sync.Once
type:sync.Once <UsedInIface> -> type:.namedata.*sync.Once.
type:sync.Once <UsedInIface> -> type:*sync.Once <UsedInIface>
type:sync.Once <UsedInIface> -> type:.namedata.done-
type:sync.Once <UsedInIface> -> type:sync/atomic.Uint32 <UsedInIface>
type:*sync.Once <UsedInIface> -> type:.namedata.Do.
type:*sync.Once <UsedInIface> -> type:.namedata.doSlow-
type:sync/atomic.Uint32 <UsedInIface> -> type:.eqfunc.sync/atomic.Uint32
type:sync/atomic.Uint32 <UsedInIface> -> type:*sync/atomic.Uint32 <UsedInIface>
type:sync/atomic.Uint32 <UsedInIface> -> type:sync/atomic.noCopy <UsedInIface>
type:sync/atomic.noCopy <UsedInIface> -> type:*sync/atomic.noCopy <UsedInIface>
type:sync/atomic.Uint64 <UsedInIface> -> type:*sync/atomic.Uint64 <UsedInIface>
type:sync/atomic.Uint64 <UsedInIface> -> type:sync/atomic.align64 <UsedInIface>
type:sync/atomic.align64 <UsedInIface> -> type:*sync/atomic.align64 <UsedInIface>
type:*internal/godebugs.Info <UsedInIface> -> type:.namedata.*godebugs.Info.
type:*internal/godebugs.Info <UsedInIface> -> type:internal/godebugs.Info <UsedInIface>
type:internal/godebugs.Info <UsedInIface> -> type:.eqfunc.internal/godebugs.Info
type:internal/godebugs.Info <UsedInIface> -> runtime.gcbits.2500000000000000
type:internal/godebugs.Info <UsedInIface> -> type:.importpath.internal/godebugs.
type:internal/godebugs.Info <UsedInIface> -> type:.namedata.Package.
type:internal/godebugs.Info <UsedInIface> -> type:.namedata.Changed.
type:internal/godebugs.Info <UsedInIface> -> type:.namedata.Old.
type:internal/godebugs.Info <UsedInIface> -> type:.namedata.Opaque.
 -> go:info.internal/godebug.value
 -> go:info.internal/godebug.runtimeStderr
 -> go:info.sync.(*Once).Do$abstract
 -> go:info.internal/bisect.(*Matcher).Stack$abstract
 -> go:info.internal/godebug.(*Setting).Name$abstract
 -> go:info.internal/godebug.(*Setting).Undocumented$abstract
 -> go:info.*internal/godebug.setting
 -> go:info.internal/godebugs.Lookup$abstract
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { internal/godebug.text string; internal/godebug.bisect *internal/bisect.Matcher }]).Store$abstract
internal/bisect.(*Matcher).stack -> type:[16]uintptr
internal/bisect.(*Matcher).stack -> internal/bisect.Hash
internal/bisect.(*Matcher).stack -> type:internal/bisect.dedup
internal/bisect.(*Matcher).stack -> internal/bisect.(*dedup).seen
internal/bisect.(*Matcher).stack -> internal/bisect.(*dedup).seenLossy
internal/bisect.(*Matcher).stack -> internal/bisect.PrintMarker
internal/bisect.(*Matcher).stack -> internal/bisect.printStack
internal/bisect.(*Matcher).stack -> gclocals·/F6ez5fePMdkil3LHbzwiA==
internal/bisect.(*Matcher).stack -> gclocals·htpvdvIX/aDTVqULOMrXmA==
internal/bisect.(*Matcher).stack -> internal/bisect.(*Matcher).stack.stkobj
internal/bisect.PrintMarker -> type:[50]uint8
internal/bisect.printStack -> runtime.(*Func).Name
internal/bisect.printStack -> gclocals·n4M8o3P7Iln70lpYeIFxTA==
internal/bisect.printStack -> gclocals·fuiJwkOXdeKh8YS73Fx3/Q==
internal/bisect.printStack -> internal/bisect.printStack.arginfo1
 -> go:info.runtime.(*Func).funcInfo$abstract
internal/bisect.Hash -> internal/bisect.Hash.jump10
internal/bisect.Hash -> type:[]uint
internal/bisect.Hash -> type:[]int64
internal/bisect.Hash -> internal/bisect..stmp_0
internal/bisect.(*dedup).seen -> runtime.makemap_small
internal/bisect.(*dedup).seen -> type:map[uint64]bool
internal/bisect.(*dedup).seen -> runtime.mapaccess1_fast64
internal/bisect.(*dedup).seen -> runtime.mapassign_fast64
runtime.mapassign_fast64 -> runtime.growWork_fast64
runtime.growWork_fast64 -> runtime.evacuate_fast64
type:internal/bisect.dedup -> runtime.gcbits.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000
type:internal/bisect.dedup -> type:.namedata.*bisect.dedup-
type:internal/bisect.dedup -> type:*internal/bisect.dedup
type:internal/bisect.dedup -> type:.importpath.internal/bisect.
type:internal/bisect.dedup -> type:.namedata.recent-
type:internal/bisect.dedup -> type:[128][4]uint64
type:*internal/bisect.dedup -> type:.namedata.seen-
type:*internal/bisect.dedup -> type:.namedata.seenLossy-
 -> go:info.*internal/bisect.Matcher
 -> go:info.internal/bisect.Writer
 -> go:info.*[16]uintptr
 -> go:info.*internal/bisect.dedup
 -> go:info.internal/bisect.(*Matcher).ShouldPrint$abstract
 -> go:info.internal/bisect.(*Matcher).matchResult$abstract
 -> go:info.internal/bisect.(*Matcher).ShouldEnable$abstract
 -> go:info.internal/bisect.(*atomicPointerDedup).Load$abstract
 -> go:info.internal/bisect.(*atomicPointerDedup).CompareAndSwap$abstract
 -> go:info.internal/bisect.(*Matcher).MarkerOnly$abstract
 -> go:info.*[50]uint8
 -> go:info.internal/bisect.AppendMarker$abstract
 -> go:info.internal/bisect.appendFileLine$abstract
 -> go:info.[]int
 -> go:info.[]uint
 -> go:info.[]int32
 -> go:info.[]int64
 -> go:info.internal/bisect.fnvUint64$abstract
 -> go:info.internal/bisect.fnvString$abstract
 -> go:info.internal/bisect.fnvUint32$abstract
 -> go:info.internal/bisect.fnv$abstract
 -> go:info.*[4]uint64
go:itab.*os.File,io.Writer -> type:io.Writer
go:itab.*os.File,io.Writer -> type:*os.File <UsedInIface>
type:io.Writer -> type:.namedata.*io.Writer.
type:io.Writer -> type:*io.Writer
type:io.Writer -> type:.importpath.io.
type:io.Writer -> type:func([]uint8) (int, error) <UsedInIface>
type:*os.File <UsedInIface> -> type:.namedata.*os.File.
type:*os.File <UsedInIface> -> type:os.File <UsedInIface>
type:*os.File <UsedInIface> -> type:.importpath.os.
type:*os.File <UsedInIface> -> type:.namedata.Chdir.
type:*os.File <UsedInIface> -> type:.namedata.Chmod.
type:*os.File <UsedInIface> -> type:.namedata.Chown.
type:*os.File <UsedInIface> -> type:.namedata.Fd.
type:*os.File <UsedInIface> -> type:.namedata.ReadAt.
type:*os.File <UsedInIface> -> type:.namedata.ReadDir.
type:*os.File <UsedInIface> -> type:.namedata.ReadFrom.
type:*os.File <UsedInIface> -> type:.namedata.Readdir.
type:*os.File <UsedInIface> -> type:.namedata.Readdirnames.
type:*os.File <UsedInIface> -> type:.namedata.Seek.
type:*os.File <UsedInIface> -> type:.namedata.SetDeadline.
type:*os.File <UsedInIface> -> type:.namedata.SetReadDeadline.
type:*os.File <UsedInIface> -> type:.namedata.SetWriteDeadline.
type:*os.File <UsedInIface> -> type:.namedata.Stat.
type:*os.File <UsedInIface> -> type:.namedata.Sync.
type:*os.File <UsedInIface> -> type:.namedata.SyscallConn.
type:*os.File <UsedInIface> -> type:.namedata.Truncate.
type:*os.File <UsedInIface> -> type:.namedata.WriteAt.
type:*os.File <UsedInIface> -> type:.namedata.WriteTo.
type:*os.File <UsedInIface> -> type:.namedata.checkValid-
type:*os.File <UsedInIface> -> type:.namedata.chmod-
type:*os.File <UsedInIface> -> type:.namedata.close-
type:*os.File <UsedInIface> -> type:.namedata.pread-
type:*os.File <UsedInIface> -> type:.namedata.pwrite-
type:*os.File <UsedInIface> -> type:.namedata.readFrom-
type:*os.File <UsedInIface> -> type:.namedata.readdir-
type:*os.File <UsedInIface> -> type:.namedata.seek-
type:*os.File <UsedInIface> -> type:.namedata.setDeadline-
type:*os.File <UsedInIface> -> type:.namedata.setReadDeadline-
type:*os.File <UsedInIface> -> type:.namedata.setWriteDeadline-
type:*os.File <UsedInIface> -> type:.namedata.wrapErr-
type:*os.File <UsedInIface> -> type:.namedata.writeTo-
type:os.File <UsedInIface> -> type:.namedata.file-.embedded
type:os.File <UsedInIface> -> type:*os.file <UsedInIface>
type:*os.file <UsedInIface> -> type:.namedata.*os.file-
type:*os.file <UsedInIface> -> type:os.file <UsedInIface>
type:os.file <UsedInIface> -> type:.eqfunc.os.file
type:os.file <UsedInIface> -> runtime.gcbits.8802000000000000
type:os.file <UsedInIface> -> type:.namedata.pfd-
type:os.file <UsedInIface> -> type:internal/poll.FD <UsedInIface>
type:os.file <UsedInIface> -> type:.namedata.dirinfo-
type:os.file <UsedInIface> -> type:*os.dirInfo <UsedInIface>
type:os.file <UsedInIface> -> type:.namedata.nonblock-
type:os.file <UsedInIface> -> type:.namedata.stdoutOrErr-
type:os.file <UsedInIface> -> type:.namedata.appendMode-
type:*os.dirInfo <UsedInIface> -> type:.namedata.*os.dirInfo-
type:*os.dirInfo <UsedInIface> -> type:os.dirInfo <UsedInIface>
type:os.dirInfo <UsedInIface> -> type:.namedata.dir-
type:internal/poll.FD <UsedInIface> -> type:.eqfunc.internal/poll.FD
type:internal/poll.FD <UsedInIface> -> type:.namedata.*poll.FD.
type:internal/poll.FD <UsedInIface> -> type:*internal/poll.FD <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.importpath.internal/poll.
type:internal/poll.FD <UsedInIface> -> type:.namedata.fdmu-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.fdMutex <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.Sysfd.
type:internal/poll.FD <UsedInIface> -> type:.namedata.SysFile..embedded
type:internal/poll.FD <UsedInIface> -> type:internal/poll.SysFile <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.pd-
type:internal/poll.FD <UsedInIface> -> type:internal/poll.pollDesc <UsedInIface>
type:internal/poll.FD <UsedInIface> -> type:.namedata.csema-
type:internal/poll.FD <UsedInIface> -> type:.namedata.isBlocking-
type:internal/poll.FD <UsedInIface> -> type:.namedata.IsStream.
type:internal/poll.FD <UsedInIface> -> type:.namedata.ZeroReadIsEOF.
type:internal/poll.FD <UsedInIface> -> type:.namedata.isFile-
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.*poll.fdMutex-
type:internal/poll.fdMutex <UsedInIface> -> type:*internal/poll.fdMutex <UsedInIface>
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.rsema-
type:internal/poll.fdMutex <UsedInIface> -> type:.namedata.wsema-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.decref-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.incref-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.increfAndClose-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.rwlock-
type:*internal/poll.fdMutex <UsedInIface> -> type:.namedata.rwunlock-
type:internal/poll.SysFile <UsedInIface> -> type:.namedata.*poll.SysFile.
type:internal/poll.SysFile <UsedInIface> -> type:*internal/poll.SysFile <UsedInIface>
type:internal/poll.SysFile <UsedInIface> -> type:.namedata.iovecs-
type:internal/poll.SysFile <UsedInIface> -> type:*[]syscall.Iovec <UsedInIface>
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Accept.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Dup.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchdir.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchmod.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fchown.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fstat.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Fsync.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Ftruncate.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.GetsockoptInt.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.OpenDir.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Pread.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Pwrite.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawControl.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawRead.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.RawWrite.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadDirent.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadFromInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadFromInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsg.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsgInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.ReadMsgInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetBlocking.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptByte.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptIPMreq.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptIPv6Mreq.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptInet4Addr.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptInt.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.SetsockoptLinger.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Shutdown.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WaitWrite.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsg.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsgInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteMsgInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteOnce.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteToInet4.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.WriteToInet6.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.Writev.
type:*internal/poll.FD <UsedInIface> -> type:.namedata.eofError-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.readLock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.readUnlock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.writeLock-
type:*internal/poll.FD <UsedInIface> -> type:.namedata.writeUnlock-
type:internal/poll.pollDesc <UsedInIface> -> type:.namedata.*poll.pollDesc-
type:internal/poll.pollDesc <UsedInIface> -> type:*internal/poll.pollDesc <UsedInIface>
type:internal/poll.pollDesc <UsedInIface> -> type:.namedata.runtimeCtx-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.evict-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.pollable-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepare-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepareRead-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.prepareWrite-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.wait-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitCanceled-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitRead-
type:*internal/poll.pollDesc <UsedInIface> -> type:.namedata.waitWrite-
go:itab.*fmt.pp,fmt.State -> type:fmt.State
type:fmt.State -> type:.namedata.*fmt.State.
type:fmt.State -> type:*fmt.State
type:fmt.State -> type:func(int) bool <UsedInIface>
type:fmt.State -> type:func() (int, bool) <UsedInIface>
go:itab.*reflect.rtype,reflect.Type -> type:*reflect.rtype <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:.namedata.*reflect.rtype-
type:*reflect.rtype <UsedInIface> -> type:reflect.rtype <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func() reflect.ChanDir <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.StructField <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func([]int) reflect.StructField <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(string) (reflect.StructField, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.Type <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(int) reflect.Method <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:func(string) (reflect.Method, bool) <UsedInIface>
type:*reflect.rtype <UsedInIface> -> type:.namedata.exportedMethods-
type:*reflect.rtype <UsedInIface> -> type:.namedata.gcSlice-
type:*reflect.rtype <UsedInIface> -> type:.namedata.ptrTo-
type:*reflect.rtype <UsedInIface> -> type:.namedata.typeOff-
fmt..stmp_3 -> go:string."fmt: unknown base; can't happen"
type:func([]uint8) (int, error) <UsedInIface> -> type:.namedata.*func([]uint8) (int, error)-
type:func([]uint8) (int, error) <UsedInIface> -> type:error <UsedInIface>
type:error <UsedInIface> -> type:*error <UsedInIface>
type:func() (int, bool) <UsedInIface> -> type:.namedata.*func() (int, bool)-
type:func(int) bool <UsedInIface> -> type:.namedata.*func(int) bool-
type:.eqfunc.fmt.fmt -> type:.eq.fmt.fmt
type:[68]uint8 <UsedInIface> -> type:.eqfunc68
type:[68]uint8 <UsedInIface> -> type:.namedata.*[68]uint8-
go:info.fmt.(*fmt).init$abstract -> go:info.*fmt.buffer
go:info.reflect.TypeOf$abstract -> go:info.reflect.emptyInterface
go:info.reflect.unpackEface$abstract -> go:info.*reflect.emptyInterface
type:func(fmt.State, int32) -> type:.namedata.*func(fmt.State, int32)-
fmt.init.func1·f -> fmt.init.func1
type:func() int <UsedInIface> -> type:.namedata.*func() int-
type:func() uint64 <UsedInIface> -> type:.namedata.*func() uint64-
strconv..stmp_12 -> go:string."strconv: illegal AppendFloat/FormatFloat bitSize"
strconv..stmp_13 -> go:string."ryuFtoaFixed32 called with negative prec"
strconv..stmp_14 -> go:string."ryuFtoaFixed32 called with prec > 9"
strconv..stmp_15 -> go:string."not enough significant bits after mult64bitPow10"
strconv..stmp_16 -> go:string."ryuFtoaFixed64 called with prec > 18"
strconv..stmp_17 -> go:string."not enough significant bits after mult128bitPow10"
strconv..stmp_19 -> go:string."mult64bitPow10: power of 10 is out of range"
strconv..stmp_20 -> go:string."mult128bitPow10: power of 10 is out of range"
strconv..stmp_21 -> go:string."strconv: illegal AppendInt/FormatInt base"
go:itab.*internal/fmtsort.SortedMap,sort.Interface -> type:sort.Interface
type:sort.Interface -> type:.namedata.*sort.Interface.
type:sort.Interface -> type:*sort.Interface
type:sort.Interface -> type:.importpath.sort.
type:sort.Interface -> type:func(int, int) bool <UsedInIface>
type:sort.Interface -> type:func(int, int) <UsedInIface>
type:func(int, int) bool <UsedInIface> -> type:.namedata.*func(int, int) bool-
type:func(int, int) <UsedInIface> -> type:.namedata.*func(int, int)-
internal/fmtsort.Sort.stkobj -> runtime.gcbits.fb07000000000000
type:[]reflect.Value <UsedInIface> -> type:.namedata.*[]reflect.Value-
sync.(*Mutex).Unlock.wrapinfo -> sync.(*Mutex).Unlock
go:info.sync/atomic.(*Uint32).Load$abstract -> go:info.*sync/atomic.Uint32
type:func() int64 <UsedInIface> -> type:.namedata.*func() int64-
type:func() interface {} <UsedInIface> -> type:.namedata.*func() interface {}-
type:.eqfunc.os.file -> type:.eq.os.file
type:.eq.os.file -> type:.eq.internal/poll.FD
 -> go:info.*os.file
 -> go:info.*internal/poll.FD
type:func() uintptr <UsedInIface> -> type:.namedata.*func() uintptr-
reflect..stmp_3 -> go:string."invalid n"
reflect..stmp_6 -> go:string."unknown type kind"
reflect..stmp_9 -> go:string."non-empty pointer map passed for non-pointer-size values"
reflect..stmp_16 -> go:string."can't call pointer on a non-pointer Value"
reflect..stmp_19 -> go:string."reflect: internal error: invalid use of makeMethodValue"
reflect..stmp_20 -> go:string."reflect: slice index out of range"
reflect..stmp_52 -> go:string."bad indir"
reflect..stmp_54 -> go:string."reflect.Value.Bytes of non-byte slice"
reflect..stmp_55 -> go:string."reflect.Value.Bytes of non-byte array"
reflect..stmp_56 -> go:string."reflect.Value.Bytes of unaddressable byte array"
reflect..stmp_81 -> go:string."reflect: internal error: invalid method index"
reflect..stmp_97 -> go:string."reflect: reflect.Value.Elem on an invalid notinheap pointer"
reflect..stmp_98 -> go:string."reflect: Field index out of range"
reflect..stmp_100 -> go:string."reflect: array index out of range"
reflect..stmp_102 -> go:string."reflect: string index out of range"
reflect..stmp_103 -> go:string."reflect.Value.Interface: cannot return value obtained from unexported field or method"
reflect..stmp_106 -> go:string."reflect: call of reflect.Value.Len on ptr to non-array Value"
reflect..stmp_110 -> go:string."MapIter.Key called before Next"
reflect..stmp_111 -> go:string."MapIter.Key called on exhausted iterator"
reflect..stmp_114 -> go:string."MapIter.Value called before Next"
reflect..stmp_115 -> go:string."MapIter.Value called on exhausted iterator"
reflect..stmp_118 -> go:string."MapIter.Next called on an iterator that does not have an associated map Value"
reflect..stmp_120 -> go:string."MapIter.Next called on exhausted iterator"
reflect..stmp_146 -> go:string."reflect: reflect.Value.UnsafePointer on an invalid notinheap pointer"
type:func(reflect.Type) bool <UsedInIface> -> type:.namedata.*func(reflect.Type) bool-
type:func(reflect.Type) bool <UsedInIface> -> type:reflect.Type <UsedInIface>
type:reflect.Type <UsedInIface> -> type:*reflect.Type <UsedInIface>
type:func() reflect.ChanDir <UsedInIface> -> type:.namedata.*func() reflect.ChanDir-
type:func() reflect.ChanDir <UsedInIface> -> type:reflect.ChanDir <UsedInIface>
type:reflect.ChanDir <UsedInIface> -> type:.namedata.*reflect.ChanDir.
type:reflect.ChanDir <UsedInIface> -> type:*reflect.ChanDir <UsedInIface>
type:func() reflect.Type <UsedInIface> -> type:.namedata.*func() reflect.Type-
type:func(int) reflect.StructField <UsedInIface> -> type:.namedata.*func(int) reflect.StructField-
type:func(int) reflect.StructField <UsedInIface> -> type:reflect.StructField <UsedInIface>
type:reflect.StructField <UsedInIface> -> runtime.gcbits.6502000000000000
type:reflect.StructField <UsedInIface> -> type:.namedata.*reflect.StructField.
type:reflect.StructField <UsedInIface> -> type:*reflect.StructField <UsedInIface>
type:reflect.StructField <UsedInIface> -> type:reflect.StructTag <UsedInIface>
type:reflect.StructField <UsedInIface> -> type:.namedata.Offset.
type:reflect.StructField <UsedInIface> -> type:.namedata.Anonymous.
type:reflect.StructTag <UsedInIface> -> type:.namedata.*reflect.StructTag.
type:reflect.StructTag <UsedInIface> -> type:*reflect.StructTag <UsedInIface>
type:reflect.StructTag <UsedInIface> -> type:.namedata.Lookup.
type:func([]int) reflect.StructField <UsedInIface> -> type:.namedata.*func([]int) reflect.StructField-
type:func(string) (reflect.StructField, bool) <UsedInIface> -> type:.namedata.*func(string) (reflect.StructField, bool)-
type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface> -> type:.namedata.*func(func(string) bool) (reflect.StructField, bool)-
type:func(func(string) bool) (reflect.StructField, bool) <UsedInIface> -> type:func(string) bool <UsedInIface>
type:func(string) bool <UsedInIface> -> type:.namedata.*func(string) bool-
type:func(int) reflect.Type <UsedInIface> -> type:.namedata.*func(int) reflect.Type-
type:func() reflect.Kind <UsedInIface> -> type:.namedata.*func() reflect.Kind-
type:func(int64) <UsedInIface> -> type:.namedata.*func(int64)-
type:func() *internal/abi.Type <UsedInIface> -> type:.namedata.*func() *abi.Type-
type:func(int) reflect.Method <UsedInIface> -> type:.namedata.*func(int) reflect.Method-
type:func(int) reflect.Method <UsedInIface> -> type:reflect.Method <UsedInIface>
type:reflect.Method <UsedInIface> -> type:.eqfunc.reflect.Method
type:reflect.Method <UsedInIface> -> runtime.gcbits.e500000000000000
type:reflect.Method <UsedInIface> -> type:.namedata.*reflect.Method.
type:reflect.Method <UsedInIface> -> type:*reflect.Method <UsedInIface>
type:.eqfunc.reflect.Method -> type:.eq.reflect.Method
 -> go:info.*reflect.Method
type:func(string) (reflect.Method, bool) <UsedInIface> -> type:.namedata.*func(string) (reflect.Method, bool)-
type:func() *internal/abi.UncommonType <UsedInIface> -> type:.namedata.*func() *abi.UncommonType-
type:func() *internal/abi.UncommonType <UsedInIface> -> type:*internal/abi.UncommonType <UsedInIface>
type:*internal/abi.UncommonType <UsedInIface> -> type:.namedata.*abi.UncommonType.
type:*internal/abi.UncommonType <UsedInIface> -> type:internal/abi.UncommonType <UsedInIface>
type:internal/abi.UncommonType <UsedInIface> -> type:.eqfunc.internal/abi.UncommonType
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Mcount.
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Xcount.
type:internal/abi.UncommonType <UsedInIface> -> type:.namedata.Moff.
go:info.internal/abi.(*IntArgRegBitmap).Set$abstract -> go:info.*internal/abi.IntArgRegBitmap
go:info.internal/abi.(*StructField).Embedded$abstract -> go:info.*internal/abi.StructField
go:info.reflect.(*hiter).initialized$abstract -> go:info.*reflect.hiter
go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract -> go:info.*sync/atomic.Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]
go:info.sync/atomic.(*Pointer[go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }]).Store$abstract -> go:info.*go.shape.struct { sync.m map[interface {}]*sync.entry; sync.amended bool }
go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract -> go:info.*sync/atomic.Pointer[go.shape.interface {}]
go:info.sync/atomic.(*Pointer[go.shape.interface {}]).CompareAndSwap$abstract -> go:info.*go.shape.interface {}
type:[]reflect.abiStep <UsedInIface> -> type:.namedata.*[]reflect.abiStep-
type:[]reflect.abiStep <UsedInIface> -> type:reflect.abiStep <UsedInIface>
type:reflect.abiStep <UsedInIface> -> type:*reflect.abiStep <UsedInIface>
type:reflect.abiStep <UsedInIface> -> type:reflect.abiStepKind <UsedInIface>
type:reflect.abiStepKind <UsedInIface> -> type:*reflect.abiStepKind <UsedInIface>
type:.eqfunc.reflect.ValueError -> type:.eq.reflect.ValueError
 -> go:info.*reflect.ValueError
type:.eqfunc.reflect.makeFuncCtxt -> type:.eq.reflect.makeFuncCtxt
 -> go:info.*reflect.makeFuncCtxt
type:.eqfunc.reflect.methodValue -> type:.eq.reflect.methodValue
type:sync/atomic.Pointer[interface {}] -> type:.eqfunc.sync/atomic.Pointer[interface {}]
type:sync/atomic.Pointer[interface {}] -> type:.namedata.*atomic.Pointer[interface {}].
type:sync/atomic.Pointer[interface {}] -> type:*sync/atomic.Pointer[interface {}]
type:sync/atomic.Pointer[interface {}] -> type:[0]*interface {}
type:.eqfunc.sync/atomic.Pointer[interface {}] -> type:.eq.sync/atomic.Pointer[interface {}]
type:.eq.sync/atomic.Pointer[interface {}] -> cmp.isNaN[go.shape.float64].arginfo1
 -> go:info.*sync/atomic.Pointer[interface {}]
type:[0]*interface {} -> type:.namedata.*[0]*interface {}-
type:[0]*interface {} -> type:*interface {}
type:[0]*interface {} -> type:[]*interface {}
type:[]*interface {} -> type:.namedata.*[]*interface {}-
type:[16]uintptr -> type:.eqfunc128
type:[16]uintptr -> type:.namedata.*[16]uintptr-
type:[5]uintptr -> type:.namedata.*[5]uintptr-
type:map[interface {}]*sync.entry -> type:.namedata.*map[interface {}]*sync.entry-
type:map[interface {}]*sync.entry -> type:noalg.map.bucket[interface {}]*sync.entry
type:map[interface {}]*sync.entry -> runtime.nilinterhash·f
type:noalg.map.bucket[interface {}]*sync.entry -> runtime.gcbits.5455ff0300000000
type:noalg.map.bucket[interface {}]*sync.entry -> type:.namedata.*map.bucket[interface {}]*sync.entry-
type:noalg.map.bucket[interface {}]*sync.entry -> type:noalg.[8]interface {}
type:noalg.map.bucket[interface {}]*sync.entry -> type:noalg.[8]*sync.entry
type:noalg.[8]interface {} -> runtime.gcbits.aaaa000000000000
type:noalg.[8]interface {} -> type:.namedata.*[8]interface {}-
type:noalg.[8]interface {} -> type:[]interface {}
type:noalg.[8]*sync.entry -> type:.namedata.*[8]*sync.entry-
type:noalg.[8]*sync.entry -> type:[]*sync.entry
type:[]*sync.entry -> type:.namedata.*[]*sync.entry-
runtime.nilinterhash·f -> runtime.nilinterhash
runtime.nilinterhash -> runtime.typehash
runtime.typehash -> runtime.typehash.jump14
runtime.typehash -> runtime.f32hash
runtime.typehash -> runtime.f64hash
runtime.typehash -> runtime.c64hash
runtime.typehash -> runtime.c128hash
runtime.typehash -> runtime.interhash
runtime.typehash -> runtime.memhash64
 -> go:info.*[2]float32
 -> go:info.*[2]float64
type:noalg.struct { F uintptr; X0 *internal/abi.Type } -> type:.namedata.*struct { F uintptr; X0 *abi.Type }-
reflect.methodValueCall -> runtime.spillArgs
reflect.methodValueCall -> reflect.moveMakeFuncArgPtrs
reflect.methodValueCall -> reflect.callMethod
reflect.methodValueCall -> runtime.unspillArgs
reflect.methodValueCall -> reflect.methodValueCall.args_stackmap
reflect.methodValueCall -> reflect.methodValueCall.arginfo0
reflect.moveMakeFuncArgPtrs -> reflect.moveMakeFuncArgPtrs
 -> go:info.*internal/abi.RegArgs
 -> go:info.internal/abi.(*IntArgRegBitmap).Get$abstract
reflect.callMethod -> reflect.callMethod
reflect.callMethod -> gclocals·br8UsANEGWp75kzr7DNKRQ==
reflect.callMethod -> type:*reflect.methodValue <UsedInIface>
reflect.callMethod -> go:string."call"
reflect.callMethod -> runtime.reflectcall
reflect.callMethod -> reflect.memmove
reflect.callMethod -> reflect.typedmemclr
reflect.callMethod -> reflect..stmp_89
reflect.callMethod -> reflect..stmp_90
reflect.callMethod -> reflect.intFromReg
reflect.callMethod -> reflect..stmp_14
reflect.callMethod -> reflect..stmp_84
reflect.callMethod -> reflect.intToReg
reflect.callMethod -> reflect..stmp_87
reflect.callMethod -> reflect..stmp_65
reflect.callMethod -> gclocals·DaWUIiwQKc54MZvP96jE8Q==
reflect.callMethod -> gclocals·dFt04l8s7m5QvL9tcW7YUA==
reflect.callMethod -> reflect.callMethod.stkobj
reflect.intFromReg -> reflect..stmp_12
type:*reflect.methodValue <UsedInIface> -> type:reflect.methodValue <UsedInIface>
type:reflect.methodValue <UsedInIface> -> type:reflect.makeFuncCtxt <UsedInIface>
type:reflect.makeFuncCtxt <UsedInIface> -> type:*reflect.makeFuncCtxt <UsedInIface>
 -> go:info.internal/abi.(*RegArgs).IntRegArgAddr$abstract
 -> go:info.internal/abi.RegArgs
 -> go:info.[]reflect.abiStep
 -> go:info.reflect.storeRcvr$abstract
 -> go:info.reflect.floatFromReg$abstract
 -> go:info.reflect.floatToReg$abstract
 -> go:info.reflect.archFloat32ToReg$abstract
reflect..stmp_12 -> go:string."invalid argSize"
reflect..stmp_14 -> go:string."bad argSize"
reflect..stmp_65 -> go:string."unknown ABI parameter kind"
reflect..stmp_84 -> go:string."method ABI and value ABI do not align"
reflect..stmp_87 -> go:string."unexpected method step"
reflect..stmp_89 -> go:string."unexpected value step"
reflect..stmp_90 -> go:string."method ABI and value ABI don't align"
go:info.reflect.storeRcvr$abstract -> go:info.*reflect.nonEmptyInterface
sync..stmp_4 -> go:string."nil Pool"
sync/atomic.(*Uint32).Store.wrapinfo -> sync/atomic.(*Uint32).Store
go:info.sync.(*Map).loadReadOnly$abstract -> go:info.*sync.readOnly
go:info.sync/atomic.(*Uint64).Add$abstract -> go:info.*sync/atomic.Uint64
go:info.sync.storePoolChainElt$abstract -> go:info.**sync.poolChainElt
type:[]sync.eface -> type:.namedata.*[]sync.eface-
type:.eqfunc.sync.poolLocal -> type:.eq.sync.poolLocal
type:.eqfunc.sync.poolLocalInternal -> type:.eq.sync.poolLocalInternal
 -> go:info.*sync.poolLocalInternal
type:[96]uint8 -> type:.eqfunc96
type:[96]uint8 -> type:.namedata.*[96]uint8-
type:.eqfunc.sync.entry -> type:.eq.sync.entry
type:.eqfunc.sync.Once -> type:.eq.sync.Once
demo/pkgb..stmp_0 -> go:string."Zoo in pkgb"
runtime.cmpstring -> cmpbody
runtime.concatstring5.stkobj -> runtime.gcbits.5501000000000000
sync/atomic.StorePointer -> sync/atomic.StoreUintptr
sync/atomic.CompareAndSwapPointer -> sync/atomic.CompareAndSwapUintptr
sync/atomic.CompareAndSwapPointer -> gclocals·tVhvz7HlUKBn8J23aTqunQ==
sync/atomic.CompareAndSwapPointer -> sync/atomic.CompareAndSwapPointer.stkobj
 -> go:info.reflect.typedmemmove$abstract
 -> go:info.runtime.procPin$abstract
 -> go:info.runtime.procUnpin$abstract
reflect.addReflectOff -> type:map[unsafe.Pointer]int32
reflect.addReflectOff -> runtime.mapaccess2_fast64
reflect.addReflectOff -> runtime.mapassign_fast64ptr
runtime.mapassign_fast64ptr -> gclocals·zfYCW1nhxEKRQBaE7Wlk4A==
runtime.mapassign_fast64ptr -> runtime.mapassign_fast32ptr.stkobj
runtime.reflectcall -> runtime.reflectcall
runtime.reflectcall -> gclocals·q6+J+w85bFSUcmRTeNlJUg==
runtime.reflectcall -> runtime.reflectcall.arginfo1
type:[]int64 -> type:.namedata.*[]int64-
type:[]int <UsedInIface> -> type:.namedata.*[]int-
type:[]uint -> type:.namedata.*[]uint-
type:[]interface {} -> type:.namedata.*[]interface {}-
type:.eqfunc.runtime.Frame -> type:.eq.runtime.Frame
 -> go:info.*runtime.Frame
type:.eqfunc.runtime._func -> type:.eq.runtime._func
type:[1]uint8 -> type:.namedata.*[1]uint8-
type:map[unsafe.Pointer]int32 -> type:.namedata.*map[unsafe.Pointer]int32-
type:map[unsafe.Pointer]int32 -> type:noalg.map.bucket[unsafe.Pointer]int32
type:map[unsafe.Pointer]int32 -> runtime.memhash64·f
type:noalg.map.bucket[unsafe.Pointer]int32 -> runtime.gcbits.fe21000000000000
type:noalg.map.bucket[unsafe.Pointer]int32 -> type:.namedata.*map.bucket[unsafe.Pointer]int32-
type:[]runtime.Frame -> type:.namedata.*[]runtime.Frame-
type:[2]runtime.Frame -> type:.eqfunc.[2]runtime.Frame
type:[2]runtime.Frame -> runtime.gcbits.16b0000000000000
type:[2]runtime.Frame -> type:.namedata.*[2]runtime.Frame-
type:.eqfunc.[2]runtime.Frame -> type:.eq.[2]runtime.Frame
 -> go:info.*[2]runtime.Frame
runtime.(*scavengerState).init.func1·f -> runtime.(*scavengerState).init.func1
runtime.(*scavengerState).init.func2·f -> runtime.(*scavengerState).init.func2
runtime.(*scavengerState).init.func3·f -> runtime.(*scavengerState).init.func3
runtime.(*scavengerState).init.func4·f -> runtime.(*scavengerState).init.func4
runtime.chanparkcommit·f -> runtime.chanparkcommit
runtime.main.func1·f -> runtime.main.func1
runtime.main.func1 -> runtime.sysmon·f
runtime.runExitHooks.func1·f -> runtime.runExitHooks.func1
runtime.runExitHooks.func1 -> runtime.runExitHooks.func1.1
runtime.sysmon·f -> runtime.sysmon
runtime.sysmon -> runtime.retake
runtime.sysmon -> runtime.forcegc
 -> go:info.runtime.forcegcstate
runtime.templateThread·f -> runtime.templateThread
runtime.spillArgs -> runtime.spillArgs.args_stackmap
runtime.spillArgs -> runtime.spillArgs.arginfo0
runtime.unspillArgs -> runtime.unspillArgs.args_stackmap
runtime.unspillArgs -> runtime.unspillArgs.arginfo0
runtime.reflectcall -> runtime.call16
runtime.reflectcall -> runtime.call32
runtime.reflectcall -> runtime.call64
runtime.reflectcall -> runtime.call128
runtime.reflectcall -> runtime.call256
runtime.reflectcall -> runtime.call512
runtime.reflectcall -> runtime.call1024
runtime.reflectcall -> runtime.call2048
runtime.reflectcall -> runtime.call4096
runtime.reflectcall -> runtime.call8192
runtime.reflectcall -> runtime.call16384
runtime.reflectcall -> runtime.call32768
runtime.reflectcall -> runtime.call65536
runtime.reflectcall -> runtime.call131072
runtime.reflectcall -> runtime.call262144
runtime.reflectcall -> runtime.call524288
runtime.reflectcall -> runtime.call1048576
runtime.reflectcall -> runtime.call2097152
runtime.reflectcall -> runtime.call4194304
runtime.reflectcall -> runtime.call8388608
runtime.reflectcall -> runtime.call16777216
runtime.reflectcall -> runtime.call33554432
runtime.reflectcall -> runtime.call67108864
runtime.reflectcall -> runtime.call134217728
runtime.reflectcall -> runtime.call268435456
runtime.reflectcall -> runtime.call536870912
runtime.reflectcall -> runtime.call1073741824
runtime.reflectcall -> runtime.badreflectcall
runtime.reflectcall -> runtime.reflectcall.args_stackmap
runtime.reflectcall -> runtime.reflectcall.arginfo0
runtime.badreflectcall -> runtime.badreflectcall
runtime.badreflectcall -> runtime..stmp_141
runtime..stmp_141 -> go:string."arg size to reflect.call more than 1GB"
runtime.call16 -> callRet
runtime.call16 -> runtime.call16.args_stackmap
runtime.call16 -> runtime.call16.arginfo0
callRet -> runtime.reflectcallmove
runtime.reflectcallmove -> runtime.reflectcallmove
runtime.reflectcallmove -> gclocals·+Pa54BXDTbaf5Zry1YmUeA==
runtime.reflectcallmove -> gclocals·xXgYqS+aH7A9q33Q83oSxA==
runtime.reflectcallmove -> runtime.reflectcallmove.argliveinfo
runtime.call32 -> runtime.call32.args_stackmap
runtime.call32 -> runtime.call32.arginfo0
runtime.call64 -> runtime.call64.args_stackmap
runtime.call64 -> runtime.call64.arginfo0
runtime.call128 -> runtime.call128.args_stackmap
runtime.call128 -> runtime.call128.arginfo0
runtime.call256 -> runtime.call256.args_stackmap
runtime.call256 -> runtime.call256.arginfo0
runtime.call512 -> runtime.call512.args_stackmap
runtime.call512 -> runtime.call512.arginfo0
runtime.call1024 -> runtime.call1024.args_stackmap
runtime.call1024 -> runtime.call1024.arginfo0
runtime.call2048 -> runtime.call2048.args_stackmap
runtime.call2048 -> runtime.call2048.arginfo0
runtime.call4096 -> runtime.call4096.args_stackmap
runtime.call4096 -> runtime.call4096.arginfo0
runtime.call8192 -> runtime.call8192.args_stackmap
runtime.call8192 -> runtime.call8192.arginfo0
runtime.call16384 -> runtime.call16384.args_stackmap
runtime.call16384 -> runtime.call16384.arginfo0
runtime.call32768 -> runtime.call32768.args_stackmap
runtime.call32768 -> runtime.call32768.arginfo0
runtime.call65536 -> runtime.call65536.args_stackmap
runtime.call65536 -> runtime.call65536.arginfo0
runtime.call131072 -> runtime.call131072.args_stackmap
runtime.call131072 -> runtime.call131072.arginfo0
runtime.call262144 -> runtime.call262144.args_stackmap
runtime.call262144 -> runtime.call262144.arginfo0
runtime.call524288 -> runtime.call524288.args_stackmap
runtime.call524288 -> runtime.call524288.arginfo0
runtime.call1048576 -> runtime.call1048576.args_stackmap
runtime.call1048576 -> runtime.call1048576.arginfo0
runtime.call2097152 -> runtime.call2097152.args_stackmap
runtime.call2097152 -> runtime.call2097152.arginfo0
runtime.call4194304 -> runtime.call4194304.args_stackmap
runtime.call4194304 -> runtime.call4194304.arginfo0
runtime.call8388608 -> runtime.call8388608.args_stackmap
runtime.call8388608 -> runtime.call8388608.arginfo0
runtime.call16777216 -> runtime.call16777216.args_stackmap
runtime.call16777216 -> runtime.call16777216.arginfo0
runtime.call33554432 -> runtime.call33554432.args_stackmap
runtime.call33554432 -> runtime.call33554432.arginfo0
runtime.call67108864 -> runtime.call67108864.args_stackmap
runtime.call67108864 -> runtime.call67108864.arginfo0
runtime.call134217728 -> runtime.call134217728.args_stackmap
runtime.call134217728 -> runtime.call134217728.arginfo0
runtime.call268435456 -> runtime.call268435456.args_stackmap
runtime.call268435456 -> runtime.call268435456.arginfo0
runtime.call536870912 -> runtime.call536870912.args_stackmap
runtime.call536870912 -> runtime.call536870912.arginfo0
runtime.call1073741824 -> runtime.call1073741824.args_stackmap
runtime.call1073741824 -> runtime.call1073741824.arginfo0
runtime.memhash64 -> runtime.memhash64Fallback
runtime.return0 -> runtime.return0.args_stackmap
runtime.return0 -> runtime.return0.arginfo0
runtime.exit_trampoline -> libc_exit
runtime.exit_trampoline -> runtime.exit_trampoline.args_stackmap
runtime.exit_trampoline -> runtime.exit_trampoline.arginfo0
runtime.open_trampoline -> libc_open
runtime.open_trampoline -> runtime.open_trampoline.args_stackmap
runtime.open_trampoline -> runtime.open_trampoline.arginfo0
runtime.close_trampoline -> libc_close
runtime.close_trampoline -> runtime.close_trampoline.args_stackmap
runtime.close_trampoline -> runtime.close_trampoline.arginfo0
runtime.read_trampoline -> libc_read
runtime.read_trampoline -> libc_error
runtime.read_trampoline -> runtime.read_trampoline.args_stackmap
runtime.read_trampoline -> runtime.read_trampoline.arginfo0
runtime.write_trampoline -> libc_write
runtime.write_trampoline -> runtime.write_trampoline.args_stackmap
runtime.write_trampoline -> runtime.write_trampoline.arginfo0
runtime.pipe_trampoline -> libc_pipe
runtime.pipe_trampoline -> runtime.pipe_trampoline.args_stackmap
runtime.pipe_trampoline -> runtime.pipe_trampoline.arginfo0
runtime.madvise_trampoline -> libc_madvise
runtime.madvise_trampoline -> runtime.madvise_trampoline.args_stackmap
runtime.madvise_trampoline -> runtime.madvise_trampoline.arginfo0
runtime.nanotime_trampoline -> libc_mach_absolute_time
runtime.nanotime_trampoline -> timebase
runtime.nanotime_trampoline -> libc_mach_timebase_info
runtime.nanotime_trampoline -> runtime.nanotime_trampoline.args_stackmap
runtime.nanotime_trampoline -> runtime.nanotime_trampoline.arginfo0
runtime.walltime_trampoline -> libc_clock_gettime
runtime.walltime_trampoline -> runtime.walltime_trampoline.args_stackmap
runtime.walltime_trampoline -> runtime.walltime_trampoline.arginfo0
runtime.sigaction_trampoline -> libc_sigaction
runtime.sigaction_trampoline -> runtime.sigaction_trampoline.args_stackmap
runtime.sigaction_trampoline -> runtime.sigaction_trampoline.arginfo0
runtime.sigprocmask_trampoline -> libc_pthread_sigmask
runtime.sigprocmask_trampoline -> runtime.sigprocmask_trampoline.args_stackmap
runtime.sigprocmask_trampoline -> runtime.sigprocmask_trampoline.arginfo0
runtime.sigaltstack_trampoline -> libc_sigaltstack
runtime.sigaltstack_trampoline -> runtime.sigaltstack_trampoline.args_stackmap
runtime.sigaltstack_trampoline -> runtime.sigaltstack_trampoline.arginfo0
runtime.raiseproc_trampoline -> libc_getpid
runtime.raiseproc_trampoline -> libc_kill
runtime.raiseproc_trampoline -> runtime.raiseproc_trampoline.args_stackmap
runtime.raiseproc_trampoline -> runtime.raiseproc_trampoline.arginfo0
runtime.sigtramp -> runtime.sigtrampgo
runtime.sigtramp -> runtime.sigtramp.args_stackmap
runtime.sigtramp -> runtime.sigtramp.arginfo0
runtime.sigtrampgo -> runtime.sigfwdgo
runtime.sigtrampgo -> runtime.setg
runtime.sigtrampgo -> runtime.adjustSignalStack
runtime.sigtrampgo -> runtime.signalDuringFork
runtime.sigtrampgo -> runtime.(*sigctxt).fixsigcode
runtime.sigtrampgo -> runtime.badsignal
runtime.sigtrampgo -> runtime.sigprofNonGoPC
runtime.sigtrampgo -> gclocals·KL0IOvpdMCv2ZgQ/WqY8JA==
runtime.sigtrampgo -> gclocals·tfr+eL+FMFZvqXIoy4WIrg==
runtime.sigprofNonGoPC -> runtime.(*cpuProfile).addNonGo
runtime.adjustSignalStack -> runtime.needm
runtime.adjustSignalStack -> runtime.noSignalStack
runtime.adjustSignalStack -> runtime.sigNotOnStack
runtime.adjustSignalStack -> runtime.dropm
runtime.adjustSignalStack -> gclocals·3FslS1NYuf3hQ1ZjkKFGrA==
runtime.adjustSignalStack -> gclocals·uaaVa9qnnwQRZ9f1GooTEw==
runtime.adjustSignalStack -> runtime.adjustSignalStack.stkobj
runtime.adjustSignalStack -> runtime.int32Hash.argliveinfo
runtime.needm -> go:string."fatal error: cgo callback before cgo call\n"
runtime.needm -> runtime.getExtraM
runtime.needm -> runtime.callbackUpdateSystemStack
runtime.needm -> runtime.traceLocker.GoCreateSyscall
runtime.callbackUpdateSystemStack -> go:string."M "
runtime.callbackUpdateSystemStack -> go:string." procid "
runtime.callbackUpdateSystemStack -> go:string." runtime: cgocallback with sp="
runtime.callbackUpdateSystemStack -> go:string." out of bounds ["
runtime.callbackUpdateSystemStack -> _cgo_getstackbound
runtime.callbackUpdateSystemStack -> runtime.callbackUpdateSystemStack.argliveinfo
runtime.dropm -> runtime.traceLocker.GoDestroySyscall
runtime.noSignalStack -> go:string."signal "
runtime.noSignalStack -> go:string." received on thread with no signal stack\n"
runtime.noSignalStack -> go:string."non-Go code disabled sigaltstack"
runtime.sigNotOnStack -> go:string." received but handler not on signal stack\n"
runtime.sigNotOnStack -> go:string."mp.gsignal stack ["
runtime.sigNotOnStack -> go:string."], "
runtime.sigNotOnStack -> go:string."mp.g0 stack ["
runtime.sigNotOnStack -> go:string."non-Go code set up signal handler without SA_ONSTACK flag"
runtime.signalDuringFork -> go:string." received during fork\n"
runtime.signalDuringFork -> go:string."signal received during fork"
runtime.badsignal -> go:string."fatal: bad g in signal handler\n"
runtime.badsignal -> runtime.raisebadsignal
runtime.sigfwdgo -> runtime.sigfwd
 -> go:info.runtime.putExtraM$abstract
 -> go:info.runtime.msigrestore$abstract
 -> go:info.*[2]uint8
 -> go:info.runtime.(*sigctxt).set_sigcode$abstract
 -> go:info.runtime.(*sigctxt).set_sigaddr$abstract
 -> go:info.runtime.gsignalStack
 -> go:info.runtime.sigFetchG$abstract
runtime.setg -> runtime.setg.args_stackmap
runtime.setg -> runtime.setg.arginfo0
runtime.sigfwd -> runtime.sigfwd.args_stackmap
runtime.sigfwd -> runtime.sigfwd.arginfo0
runtime.cgoSigtramp -> _cgo_callers
runtime.cgoSigtramp -> runtime.sigprofCallersUse
runtime.cgoSigtramp -> runtime.sigprofCallers
runtime.cgoSigtramp -> runtime.sigprofNonGoWrapper
runtime.cgoSigtramp -> runtime.cgoSigtramp.args_stackmap
runtime.cgoSigtramp -> runtime.cgoSigtramp.arginfo0
runtime.sigprofNonGoWrapper -> runtime.sigprofNonGo
runtime.sigprofNonGoWrapper -> runtime.sigprofNonGoWrapper.args_stackmap
runtime.sigprofNonGoWrapper -> runtime.sigprofNonGoWrapper.arginfo0
runtime.sigprofNonGo -> runtime.sigprofNonGo
runtime.mmap_trampoline -> libc_mmap
runtime.mmap_trampoline -> runtime.mmap_trampoline.args_stackmap
runtime.mmap_trampoline -> runtime.mmap_trampoline.arginfo0
runtime.munmap_trampoline -> libc_munmap
runtime.munmap_trampoline -> runtime.munmap_trampoline.args_stackmap
runtime.munmap_trampoline -> runtime.munmap_trampoline.arginfo0
runtime.usleep_trampoline -> libc_usleep
runtime.usleep_trampoline -> runtime.usleep_trampoline.args_stackmap
runtime.usleep_trampoline -> runtime.usleep_trampoline.arginfo0
runtime.settls -> runtime.settls.args_stackmap
runtime.settls -> runtime.settls.arginfo0
runtime.sysctl_trampoline -> libc_sysctl
runtime.sysctl_trampoline -> runtime.sysctl_trampoline.args_stackmap
runtime.sysctl_trampoline -> runtime.sysctl_trampoline.arginfo0
runtime.kqueue_trampoline -> libc_kqueue
runtime.kqueue_trampoline -> runtime.kqueue_trampoline.args_stackmap
runtime.kqueue_trampoline -> runtime.kqueue_trampoline.arginfo0
runtime.kevent_trampoline -> libc_kevent
runtime.kevent_trampoline -> runtime.kevent_trampoline.args_stackmap
runtime.kevent_trampoline -> runtime.kevent_trampoline.arginfo0
runtime.fcntl_trampoline -> libc_fcntl
runtime.fcntl_trampoline -> runtime.fcntl_trampoline.args_stackmap
runtime.fcntl_trampoline -> runtime.fcntl_trampoline.arginfo0
runtime.mstart_stub -> runtime.mstart_stub.args_stackmap
runtime.mstart_stub -> runtime.mstart_stub.arginfo0
runtime.pthread_attr_init_trampoline -> libc_pthread_attr_init
runtime.pthread_attr_init_trampoline -> runtime.pthread_attr_init_trampoline.args_stackmap
runtime.pthread_attr_init_trampoline -> runtime.pthread_attr_init_trampoline.arginfo0
runtime.pthread_attr_getstacksize_trampoline -> libc_pthread_attr_getstacksize
runtime.pthread_attr_getstacksize_trampoline -> runtime.pthread_attr_getstacksize_trampoline.args_stackmap
runtime.pthread_attr_getstacksize_trampoline -> runtime.pthread_attr_getstacksize_trampoline.arginfo0
runtime.pthread_attr_setdetachstate_trampoline -> libc_pthread_attr_setdetachstate
runtime.pthread_attr_setdetachstate_trampoline -> runtime.pthread_attr_setdetachstate_trampoline.args_stackmap
runtime.pthread_attr_setdetachstate_trampoline -> runtime.pthread_attr_setdetachstate_trampoline.arginfo0
runtime.pthread_create_trampoline -> libc_pthread_create
runtime.pthread_create_trampoline -> runtime.pthread_create_trampoline.args_stackmap
runtime.pthread_create_trampoline -> runtime.pthread_create_trampoline.arginfo0
runtime.raise_trampoline -> libc_raise
runtime.raise_trampoline -> runtime.raise_trampoline.args_stackmap
runtime.raise_trampoline -> runtime.raise_trampoline.arginfo0
runtime.pthread_mutex_init_trampoline -> libc_pthread_mutex_init
runtime.pthread_mutex_init_trampoline -> runtime.pthread_mutex_init_trampoline.args_stackmap
runtime.pthread_mutex_init_trampoline -> runtime.pthread_mutex_init_trampoline.arginfo0
runtime.pthread_mutex_lock_trampoline -> libc_pthread_mutex_lock
runtime.pthread_mutex_lock_trampoline -> runtime.pthread_mutex_lock_trampoline.args_stackmap
runtime.pthread_mutex_lock_trampoline -> runtime.pthread_mutex_lock_trampoline.arginfo0
runtime.pthread_mutex_unlock_trampoline -> libc_pthread_mutex_unlock
runtime.pthread_mutex_unlock_trampoline -> runtime.pthread_mutex_unlock_trampoline.args_stackmap
runtime.pthread_mutex_unlock_trampoline -> runtime.pthread_mutex_unlock_trampoline.arginfo0
runtime.pthread_cond_init_trampoline -> libc_pthread_cond_init
runtime.pthread_cond_init_trampoline -> runtime.pthread_cond_init_trampoline.args_stackmap
runtime.pthread_cond_init_trampoline -> runtime.pthread_cond_init_trampoline.arginfo0
runtime.pthread_cond_wait_trampoline -> libc_pthread_cond_wait
runtime.pthread_cond_wait_trampoline -> runtime.pthread_cond_wait_trampoline.args_stackmap
runtime.pthread_cond_wait_trampoline -> runtime.pthread_cond_wait_trampoline.arginfo0
runtime.pthread_cond_timedwait_relative_np_trampoline -> libc_pthread_cond_timedwait_relative_np
runtime.pthread_cond_timedwait_relative_np_trampoline -> runtime.pthread_cond_timedwait_relative_np_trampoline.args_stackmap
runtime.pthread_cond_timedwait_relative_np_trampoline -> runtime.pthread_cond_timedwait_relative_np_trampoline.arginfo0
runtime.pthread_cond_signal_trampoline -> libc_pthread_cond_signal
runtime.pthread_cond_signal_trampoline -> runtime.pthread_cond_signal_trampoline.args_stackmap
runtime.pthread_cond_signal_trampoline -> runtime.pthread_cond_signal_trampoline.arginfo0
runtime.pthread_self_trampoline -> libc_pthread_self
runtime.pthread_self_trampoline -> runtime.pthread_self_trampoline.args_stackmap
runtime.pthread_self_trampoline -> runtime.pthread_self_trampoline.arginfo0
runtime.pthread_kill_trampoline -> libc_pthread_kill
runtime.pthread_kill_trampoline -> runtime.pthread_kill_trampoline.args_stackmap
runtime.pthread_kill_trampoline -> runtime.pthread_kill_trampoline.arginfo0
runtime.osinit_hack_trampoline -> libc_notify_is_valid_token
runtime.osinit_hack_trampoline -> libc_xpc_date_create_from_current
runtime.osinit_hack_trampoline -> runtime.osinit_hack_trampoline.args_stackmap
runtime.osinit_hack_trampoline -> runtime.osinit_hack_trampoline.arginfo0
runtime.issetugid_trampoline -> libc_issetugid
runtime.issetugid_trampoline -> runtime.issetugid_trampoline.args_stackmap
runtime.issetugid_trampoline -> runtime.issetugid_trampoline.arginfo0
type:*[]syscall.Iovec <UsedInIface> -> type:.namedata.*[]syscall.Iovec-
type:*[]syscall.Iovec <UsedInIface> -> type:[]syscall.Iovec <UsedInIface>
type:[]syscall.Iovec <UsedInIface> -> type:syscall.Iovec <UsedInIface>
type:syscall.Iovec <UsedInIface> -> type:.namedata.*syscall.Iovec.
type:syscall.Iovec <UsedInIface> -> type:*syscall.Iovec <UsedInIface>
type:syscall.Iovec <UsedInIface> -> type:.namedata.Base.
type:.eqfunc.sync/atomic.Uint32 -> type:.eq.sync/atomic.Uint32
type:.eqfunc.sync/atomic.Uint64 -> type:.eq.sync/atomic.Uint64
type:[]internal/abi.Imethod -> type:.namedata.*[]abi.Imethod-
type:[]internal/abi.Imethod -> type:internal/abi.Imethod
type:internal/abi.Imethod -> type:.namedata.*abi.Imethod.
type:internal/abi.Imethod -> type:*internal/abi.Imethod
type:internal/abi.Imethod -> type:.namedata.Typ.
type:.eqfunc.internal/abi.UncommonType -> type:.eq.internal/abi.UncommonType
type:.eqfunc.internal/abi.RegArgs -> type:.eq.internal/abi.RegArgs
type:[15]uint64 <UsedInIface> -> type:.eqfunc120
type:[15]uint64 <UsedInIface> -> type:.namedata.*[15]uint64-
type:[9]unsafe.Pointer <UsedInIface> -> runtime.gcbits.ff01000000000000
type:[9]unsafe.Pointer <UsedInIface> -> type:.namedata.*[9]unsafe.Pointer-
type:[9]unsafe.Pointer <UsedInIface> -> type:[]unsafe.Pointer <UsedInIface>
type:.eqfunc.internal/cpu.option -> type:.eq.internal/cpu.option
 -> go:info.*internal/cpu.option
type:[6]internal/cpu.option -> type:.eqfunc.[6]internal/cpu.option
type:[6]internal/cpu.option -> runtime.gcbits.5555550000000000
type:[6]internal/cpu.option -> type:.namedata.*[6]cpu.option-
type:[6]internal/cpu.option -> type:[]internal/cpu.option
type:[]internal/cpu.option -> type:.namedata.*[]cpu.option-
type:.eqfunc.[6]internal/cpu.option -> type:.eq.[6]internal/cpu.option
 -> go:info.*[6]internal/cpu.option
internal/cpu.cpuid -> internal/cpu.cpuid.args_stackmap
internal/cpu.cpuid -> internal/cpu.cpuid.arginfo0
internal/cpu.xgetbv -> internal/cpu.xgetbv.args_stackmap
internal/cpu.xgetbv -> internal/cpu.xgetbv.arginfo0
internal/cpu.getGOAMD64level -> internal/cpu.getGOAMD64level.args_stackmap
internal/cpu.getGOAMD64level -> internal/cpu.getGOAMD64level.arginfo0
math/rand..stmp_2 -> go:string."invalid argument to Int31n"
type:[607]int64 <UsedInIface> -> type:.eqfunc4856
type:[607]int64 <UsedInIface> -> type:.namedata.*[607]int64-
type:[607]int64 <UsedInIface> -> type:[]int64 <UsedInIface>
go:info.math/rand.newSource$abstract -> go:info.math/rand.rngSource
go:info.sync/atomic.(*Pointer[go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }]).Load$abstract -> go:info.*sync/atomic.Pointer[go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }]
go:info.math/rand.New$abstract -> go:info.math/rand.Source
go:info.math/rand.New$abstract -> go:info.math/rand.Source64
go:info.sync/atomic.(*Pointer[go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }]).CompareAndSwap$abstract -> go:info.*go.shape.struct { math/rand.src math/rand.Source; math/rand.s64 math/rand.Source64; math/rand.readVal int64; math/rand.readPos int8 }
go:info.sync/atomic.(*Pointer[go.shape.struct { internal/godebug.text string; internal/godebug.bisect *internal/bisect.Matcher }]).Store$abstract -> go:info.*sync/atomic.Pointer[go.shape.struct { internal/godebug.text string; internal/godebug.bisect *internal/bisect.Matcher }]
go:info.sync/atomic.(*Pointer[go.shape.struct { internal/godebug.text string; internal/godebug.bisect *internal/bisect.Matcher }]).Store$abstract -> go:info.*go.shape.struct { internal/godebug.text string; internal/godebug.bisect *internal/bisect.Matcher }
type:.eqfunc.math/rand.Rand -> type:.eq.math/rand.Rand
type:sync/atomic.Pointer[internal/godebug.value] <UsedInIface> -> type:.eqfunc.sync/atomic.Pointer[internal/godebug.value]
type:sync/atomic.Pointer[internal/godebug.value] <UsedInIface> -> type:.namedata.*atomic.Pointer[internal/godebug.value].
type:sync/atomic.Pointer[internal/godebug.value] <UsedInIface> -> type:*sync/atomic.Pointer[internal/godebug.value] <UsedInIface>
type:sync/atomic.Pointer[internal/godebug.value] <UsedInIface> -> type:[0]*internal/godebug.value <UsedInIface>
type:.eqfunc.sync/atomic.Pointer[internal/godebug.value] -> type:.eq.sync/atomic.Pointer[internal/godebug.value]
 -> go:info.*sync/atomic.Pointer[internal/godebug.value]
type:[0]*internal/godebug.value <UsedInIface> -> type:.namedata.*[0]*godebug.value-
type:[0]*internal/godebug.value <UsedInIface> -> type:*internal/godebug.value <UsedInIface>
type:[0]*internal/godebug.value <UsedInIface> -> type:[]*internal/godebug.value <UsedInIface>
type:*internal/godebug.value <UsedInIface> -> type:.namedata.*godebug.value-
type:*internal/godebug.value <UsedInIface> -> type:internal/godebug.value <UsedInIface>
type:internal/godebug.value <UsedInIface> -> type:.eqfunc.internal/godebug.value
type:internal/godebug.value <UsedInIface> -> type:.namedata.bisect-
type:internal/godebug.value <UsedInIface> -> type:*internal/bisect.Matcher <UsedInIface>
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.*bisect.Matcher.
type:*internal/bisect.Matcher <UsedInIface> -> type:internal/bisect.Matcher <UsedInIface>
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.MarkerOnly.
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.ShouldEnable.
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.ShouldPrint.
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.Stack.
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.fileLine-
type:*internal/bisect.Matcher <UsedInIface> -> type:.namedata.matchResult-
type:internal/bisect.Matcher <UsedInIface> -> type:.namedata.verbose-
type:internal/bisect.Matcher <UsedInIface> -> type:.namedata.quiet-
type:internal/bisect.Matcher <UsedInIface> -> type:.namedata.enable-
type:internal/bisect.Matcher <UsedInIface> -> type:[]internal/bisect.cond <UsedInIface>
type:internal/bisect.Matcher <UsedInIface> -> type:.namedata.dedup-
type:internal/bisect.Matcher <UsedInIface> -> type:internal/bisect.atomicPointerDedup <UsedInIface>
type:internal/bisect.atomicPointerDedup <UsedInIface> -> type:.namedata.*bisect.atomicPointerDedup-
type:internal/bisect.atomicPointerDedup <UsedInIface> -> type:*internal/bisect.atomicPointerDedup <UsedInIface>
type:[]*internal/godebug.value <UsedInIface> -> type:.namedata.*[]*godebug.value-
type:.eqfunc.runtime/internal/atomic.Int64 -> type:.eq.runtime/internal/atomic.Int64
type:.eqfunc.runtime/internal/atomic.Uint64 -> type:.eq.runtime/internal/atomic.Uint64
type:.eqfunc.runtime/internal/sys.NotInHeap -> type:.eq.runtime/internal/sys.NotInHeap
 -> go:info.*runtime/internal/sys.NotInHeap
type:.eqfunc.internal/godebugs.Info -> type:.eq.internal/godebugs.Info
 -> go:info.*internal/godebugs.Info
type:[32]uint64 <UsedInIface> -> type:.namedata.*[32]uint64-
type:.eqfunc.internal/chacha8rand.State -> type:.eq.internal/chacha8rand.State
go:itab.*internal/godebug.runtimeStderr,internal/bisect.Writer -> type:internal/bisect.Writer
go:itab.*internal/godebug.runtimeStderr,internal/bisect.Writer -> type:*internal/godebug.runtimeStderr <UsedInIface>
type:*internal/godebug.runtimeStderr <UsedInIface> -> type:.namedata.*godebug.runtimeStderr-
type:*internal/godebug.runtimeStderr <UsedInIface> -> type:internal/godebug.runtimeStderr <UsedInIface>
type:internal/bisect.Writer -> type:.namedata.*bisect.Writer.
type:internal/bisect.Writer -> type:*internal/bisect.Writer
internal/godebug.(*Setting).register-fm -> internal/godebug.(*Setting).register
internal/godebug.(*Setting).register -> type:noalg.struct { F uintptr; R *sync/atomic.Uint64 }
internal/godebug.(*Setting).register -> sync/atomic.(*Uint64).Load-fm
internal/godebug.(*Setting).register -> go:string."/godebug/non-default-behavior/"
internal/godebug.(*Setting).register -> go:string.":events"
internal/godebug.(*Setting).register -> internal/godebug.registerMetric
internal/godebug.(*Setting).register -> go:string."godebug: unexpected IncNonDefault of "
internal/godebug.registerMetric -> runtime.metricsSema
internal/godebug.registerMetric -> runtime.initMetrics
internal/godebug.registerMetric -> runtime.metrics
internal/godebug.registerMetric -> type:map[string]runtime.metricData
internal/godebug.registerMetric -> runtime.mapaccess2_faststr
internal/godebug.registerMetric -> type:noalg.struct { F uintptr; R runtime.metricReader }
internal/godebug.registerMetric -> runtime.metricReader.compute-fm
internal/godebug.registerMetric -> go:string."runtime: unexpected metric registration for "
internal/godebug.registerMetric -> gclocals·NkFz9ob8NrrpGtxjexQc5A==
runtime.initMetrics -> runtime.metricsInit
runtime.initMetrics -> runtime.sizeClassBuckets
runtime.initMetrics -> $f64.7ff0000000000000
runtime.initMetrics -> runtime.timeHistogramMetricsBuckets
runtime.initMetrics -> runtime.timeHistBuckets
runtime.initMetrics -> go:string."/cgo/go-to-c-calls:calls"
runtime.initMetrics -> runtime.initMetrics.func1·f
runtime.initMetrics -> go:string."/cpu/classes/gc/mark/assist:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func2·f
runtime.initMetrics -> go:string."/cpu/classes/gc/mark/dedicated:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func3·f
runtime.initMetrics -> go:string."/cpu/classes/gc/mark/idle:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func4·f
runtime.initMetrics -> go:string."/cpu/classes/gc/pause:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func5·f
runtime.initMetrics -> go:string."/cpu/classes/gc/total:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func6·f
runtime.initMetrics -> go:string."/cpu/classes/idle:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func7·f
runtime.initMetrics -> go:string."/cpu/classes/scavenge/assist:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func8·f
runtime.initMetrics -> go:string."/cpu/classes/scavenge/background:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func9·f
runtime.initMetrics -> go:string."/cpu/classes/scavenge/total:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func10·f
runtime.initMetrics -> go:string."/cpu/classes/total:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func11·f
runtime.initMetrics -> go:string."/cpu/classes/user:cpu-seconds"
runtime.initMetrics -> runtime.initMetrics.func12·f
runtime.initMetrics -> go:string."/gc/cycles/automatic:gc-cycles"
runtime.initMetrics -> runtime.initMetrics.func13·f
runtime.initMetrics -> go:string."/gc/cycles/forced:gc-cycles"
runtime.initMetrics -> runtime.initMetrics.func14·f
runtime.initMetrics -> go:string."/gc/cycles/total:gc-cycles"
runtime.initMetrics -> runtime.initMetrics.func15·f
runtime.initMetrics -> go:string."/gc/scan/globals:bytes"
runtime.initMetrics -> runtime.initMetrics.func16·f
runtime.initMetrics -> go:string."/gc/scan/heap:bytes"
runtime.initMetrics -> runtime.initMetrics.func17·f
runtime.initMetrics -> go:string."/gc/scan/stack:bytes"
runtime.initMetrics -> runtime.initMetrics.func18·f
runtime.initMetrics -> go:string."/gc/scan/total:bytes"
runtime.initMetrics -> runtime.initMetrics.func19·f
runtime.initMetrics -> go:string."/gc/heap/allocs-by-size:bytes"
runtime.initMetrics -> runtime.initMetrics.func20·f
runtime.initMetrics -> go:string."/gc/heap/allocs:bytes"
runtime.initMetrics -> runtime.initMetrics.func21·f
runtime.initMetrics -> go:string."/gc/heap/allocs:objects"
runtime.initMetrics -> runtime.initMetrics.func22·f
runtime.initMetrics -> go:string."/gc/heap/frees-by-size:bytes"
runtime.initMetrics -> runtime.initMetrics.func23·f
runtime.initMetrics -> go:string."/gc/heap/frees:bytes"
runtime.initMetrics -> runtime.initMetrics.func24·f
runtime.initMetrics -> go:string."/gc/heap/frees:objects"
runtime.initMetrics -> runtime.initMetrics.func25·f
runtime.initMetrics -> go:string."/gc/heap/goal:bytes"
runtime.initMetrics -> runtime.initMetrics.func26·f
runtime.initMetrics -> go:string."/gc/gomemlimit:bytes"
runtime.initMetrics -> runtime.initMetrics.func27·f
runtime.initMetrics -> go:string."/gc/gogc:percent"
runtime.initMetrics -> runtime.initMetrics.func28·f
runtime.initMetrics -> go:string."/gc/heap/live:bytes"
runtime.initMetrics -> runtime.initMetrics.func29·f
runtime.initMetrics -> go:string."/gc/heap/objects:objects"
runtime.initMetrics -> runtime.initMetrics.func30·f
runtime.initMetrics -> go:string."/gc/heap/tiny/allocs:objects"
runtime.initMetrics -> runtime.initMetrics.func31·f
runtime.initMetrics -> go:string."/gc/limiter/last-enabled:gc-cycle"
runtime.initMetrics -> runtime.initMetrics.func32·f
runtime.initMetrics -> go:string."/gc/pauses:seconds"
runtime.initMetrics -> runtime.initMetrics.func33·f
runtime.initMetrics -> go:string."/gc/stack/starting-size:bytes"
runtime.initMetrics -> runtime.initMetrics.func34·f
runtime.initMetrics -> go:string."/memory/classes/heap/free:bytes"
runtime.initMetrics -> runtime.initMetrics.func35·f
runtime.initMetrics -> go:string."/memory/classes/heap/objects:bytes"
runtime.initMetrics -> runtime.initMetrics.func36·f
runtime.initMetrics -> go:string."/memory/classes/heap/released:bytes"
runtime.initMetrics -> runtime.initMetrics.func37·f
runtime.initMetrics -> go:string."/memory/classes/heap/stacks:bytes"
runtime.initMetrics -> runtime.initMetrics.func38·f
runtime.initMetrics -> go:string."/memory/classes/heap/unused:bytes"
runtime.initMetrics -> runtime.initMetrics.func39·f
runtime.initMetrics -> go:string."/memory/classes/metadata/mcache/free:bytes"
runtime.initMetrics -> runtime.initMetrics.func40·f
runtime.initMetrics -> go:string."/memory/classes/metadata/mcache/inuse:bytes"
runtime.initMetrics -> runtime.initMetrics.func41·f
runtime.initMetrics -> go:string."/memory/classes/metadata/mspan/free:bytes"
runtime.initMetrics -> runtime.initMetrics.func42·f
runtime.initMetrics -> go:string."/memory/classes/metadata/mspan/inuse:bytes"
runtime.initMetrics -> runtime.initMetrics.func43·f
runtime.initMetrics -> go:string."/memory/classes/metadata/other:bytes"
runtime.initMetrics -> runtime.initMetrics.func44·f
runtime.initMetrics -> go:string."/memory/classes/os-stacks:bytes"
runtime.initMetrics -> runtime.initMetrics.func45·f
runtime.initMetrics -> go:string."/memory/classes/other:bytes"
runtime.initMetrics -> runtime.initMetrics.func46·f
runtime.initMetrics -> go:string."/memory/classes/profiling/buckets:bytes"
runtime.initMetrics -> runtime.initMetrics.func47·f
runtime.initMetrics -> go:string."/memory/classes/total:bytes"
runtime.initMetrics -> runtime.initMetrics.func48·f
runtime.initMetrics -> go:string."/sched/gomaxprocs:threads"
runtime.initMetrics -> runtime.initMetrics.func49·f
runtime.initMetrics -> go:string."/sched/goroutines:goroutines"
runtime.initMetrics -> runtime.initMetrics.func50·f
runtime.initMetrics -> go:string."/sched/latencies:seconds"
runtime.initMetrics -> runtime.initMetrics.func51·f
runtime.initMetrics -> go:string."/sched/pauses/stopping/gc:seconds"
runtime.initMetrics -> runtime.initMetrics.func52·f
runtime.initMetrics -> go:string."/sched/pauses/stopping/other:seconds"
runtime.initMetrics -> runtime.initMetrics.func53·f
runtime.initMetrics -> go:string."/sched/pauses/total/gc:seconds"
runtime.initMetrics -> runtime.initMetrics.func54·f
runtime.initMetrics -> go:string."/sched/pauses/total/other:seconds"
runtime.initMetrics -> runtime.initMetrics.func55·f
runtime.initMetrics -> go:string."/sync/mutex/wait/total:seconds"
runtime.initMetrics -> runtime.initMetrics.func56·f
runtime.initMetrics -> runtime.compute0·f
runtime.initMetrics -> gclocals·5+63DFtY/vRgh6W2Yo4+yA==
runtime.timeHistogramMetricsBuckets -> $f64.fff0000000000000
runtime.timeHistogramMetricsBuckets -> $f64.41cdcd6500000000
runtime.timeHistogramMetricsBuckets -> $f64.41012e0be826d695
 -> go:info.map[string]runtime.metricData
 -> go:info.[]float64
 -> go:info.internal/godebugs.Info
 -> go:info.runtime.makeStatDepSet$abstract
 -> go:info.func() uint64
 -> go:info.runtime.metricData
 -> go:info.runtime.metricsLock$abstract
 -> go:info.runtime.metricsUnlock$abstract
 -> go:info.*runtime.statAggregate
 -> go:info.*runtime.metricValue
 -> go:info.runtime.metricReader.compute$abstract
go:info.runtime.makeStatDepSet$abstract -> go:info.[]runtime.statDep
go:info.runtime.makeStatDepSet$abstract -> go:info.runtime.statDepSet
go:info.runtime.makeStatDepSet$abstract -> go:info.runtime.statDep
go:info.runtime.metricReader.compute$abstract -> go:info.runtime.metricReader
type:map[string]runtime.metricData -> type:.namedata.*map[string]runtime.metricData-
type:map[string]runtime.metricData -> type:runtime.metricData
type:map[string]runtime.metricData -> type:noalg.map.bucket[string]runtime.metricData
type:runtime.metricData -> type:.namedata.*runtime.metricData-
type:runtime.metricData -> type:*runtime.metricData
type:runtime.metricData -> type:.namedata.deps-
type:runtime.metricData -> type:runtime.statDepSet
type:runtime.metricData -> type:.namedata.compute-
type:runtime.metricData -> type:func(*runtime.statAggregate, *runtime.metricValue)
type:runtime.statDepSet -> type:.namedata.*runtime.statDepSet-
type:runtime.statDepSet -> type:*runtime.statDepSet
type:runtime.statDepSet -> type:.namedata.difference-
type:runtime.statDepSet -> type:.namedata.union-
type:*runtime.statDepSet -> type:.namedata.has-
type:func(*runtime.statAggregate, *runtime.metricValue) -> type:.namedata.*func(*runtime.statAggregate, *runtime.metricValue)-
type:func(*runtime.statAggregate, *runtime.metricValue) -> type:*runtime.statAggregate
type:func(*runtime.statAggregate, *runtime.metricValue) -> type:*runtime.metricValue
type:*runtime.statAggregate -> type:.namedata.*runtime.statAggregate-
type:*runtime.statAggregate -> type:runtime.statAggregate
type:*runtime.statAggregate -> type:.namedata.ensure-
type:runtime.statAggregate -> type:.eqfunc1440
type:runtime.statAggregate -> type:.namedata.ensured-
type:runtime.statAggregate -> type:.namedata.heapStats-
type:runtime.statAggregate -> type:runtime.heapStatsAggregate
type:runtime.statAggregate -> type:.namedata.sysStats-
type:runtime.statAggregate -> type:runtime.sysStatsAggregate
type:runtime.statAggregate -> type:.namedata.cpuStats-
type:runtime.statAggregate -> type:runtime.cpuStatsAggregate
type:runtime.statAggregate -> type:.namedata.gcStats-
type:runtime.statAggregate -> type:runtime.gcStatsAggregate
type:runtime.heapStatsAggregate -> type:.eqfunc1224
type:runtime.heapStatsAggregate -> type:.namedata.*runtime.heapStatsAggregate-
type:runtime.heapStatsAggregate -> type:*runtime.heapStatsAggregate
type:runtime.heapStatsAggregate -> type:.namedata.heapStatsDelta-.embedded
type:runtime.heapStatsAggregate -> type:runtime.heapStatsDelta
type:runtime.heapStatsAggregate -> type:.namedata.inObjects-
type:runtime.heapStatsAggregate -> type:.namedata.numObjects-
type:runtime.heapStatsAggregate -> type:.namedata.totalAllocated-
type:runtime.heapStatsAggregate -> type:.namedata.totalFreed-
type:runtime.heapStatsAggregate -> type:.namedata.totalAllocs-
type:runtime.heapStatsAggregate -> type:.namedata.totalFrees-
type:runtime.heapStatsDelta -> type:.eqfunc1176
type:runtime.heapStatsDelta -> type:.namedata.*runtime.heapStatsDelta-
type:runtime.heapStatsDelta -> type:*runtime.heapStatsDelta
type:runtime.heapStatsDelta -> type:.namedata.committed-
type:runtime.heapStatsDelta -> type:.namedata.released-
type:runtime.heapStatsDelta -> type:.namedata.inHeap-
type:runtime.heapStatsDelta -> type:.namedata.inStacks-
type:runtime.heapStatsDelta -> type:.namedata.inWorkBufs-
type:runtime.heapStatsDelta -> type:.namedata.inPtrScalarBits-
type:runtime.heapStatsDelta -> type:.namedata.tinyAllocCount-
type:runtime.heapStatsDelta -> type:.namedata.largeAlloc-
type:runtime.heapStatsDelta -> type:.namedata.largeAllocCount-
type:runtime.heapStatsDelta -> type:.namedata.smallAllocCount-
type:runtime.heapStatsDelta -> type:[68]uint64
type:runtime.heapStatsDelta -> type:.namedata.largeFree-
type:runtime.heapStatsDelta -> type:.namedata.largeFreeCount-
type:runtime.heapStatsDelta -> type:.namedata.smallFreeCount-
type:*runtime.heapStatsDelta -> type:.namedata.merge-
type:runtime.sysStatsAggregate -> type:.namedata.*runtime.sysStatsAggregate-
type:runtime.sysStatsAggregate -> type:*runtime.sysStatsAggregate
type:runtime.sysStatsAggregate -> type:.namedata.stacksSys-
type:runtime.sysStatsAggregate -> type:.namedata.mSpanSys-
type:runtime.sysStatsAggregate -> type:.namedata.mSpanInUse-
type:runtime.sysStatsAggregate -> type:.namedata.mCacheSys-
type:runtime.sysStatsAggregate -> type:.namedata.mCacheInUse-
type:runtime.sysStatsAggregate -> type:.namedata.buckHashSys-
type:runtime.sysStatsAggregate -> type:.namedata.gcMiscSys-
type:runtime.sysStatsAggregate -> type:.namedata.otherSys-
type:runtime.sysStatsAggregate -> type:.namedata.heapGoal-
type:runtime.sysStatsAggregate -> type:.namedata.gcCyclesDone-
type:runtime.sysStatsAggregate -> type:.namedata.gcCyclesForced-
type:runtime.cpuStatsAggregate -> type:.namedata.*runtime.cpuStatsAggregate-
type:runtime.cpuStatsAggregate -> type:*runtime.cpuStatsAggregate
type:runtime.cpuStatsAggregate -> type:.namedata.cpuStats-.embedded
type:runtime.cpuStatsAggregate -> type:runtime.cpuStats
type:*runtime.cpuStatsAggregate -> type:.namedata.accumulate-
type:runtime.cpuStats -> type:.namedata.*runtime.cpuStats-
type:runtime.cpuStats -> type:*runtime.cpuStats
type:runtime.cpuStats -> type:.namedata.gcDedicatedTime-
type:runtime.cpuStats -> type:.namedata.gcIdleTime-
type:runtime.cpuStats -> type:.namedata.gcPauseTime-
type:runtime.cpuStats -> type:.namedata.gcTotalTime-
type:runtime.cpuStats -> type:.namedata.scavengeAssistTime-
type:runtime.cpuStats -> type:.namedata.scavengeBgTime-
type:runtime.cpuStats -> type:.namedata.scavengeTotalTime-
type:runtime.cpuStats -> type:.namedata.idleTime-
type:runtime.cpuStats -> type:.namedata.userTime-
type:runtime.cpuStats -> type:.namedata.totalTime-
type:runtime.gcStatsAggregate -> type:.namedata.*runtime.gcStatsAggregate-
type:runtime.gcStatsAggregate -> type:*runtime.gcStatsAggregate
type:runtime.gcStatsAggregate -> type:.namedata.heapScan-
type:runtime.gcStatsAggregate -> type:.namedata.stackScan-
type:runtime.gcStatsAggregate -> type:.namedata.globalsScan-
type:runtime.gcStatsAggregate -> type:.namedata.totalScan-
type:*runtime.metricValue -> type:.namedata.*runtime.metricValue-
type:*runtime.metricValue -> type:runtime.metricValue
type:*runtime.metricValue -> type:.namedata.float64HistOrInit-
type:runtime.metricValue -> type:runtime.metricKind
type:runtime.metricValue -> type:.namedata.scalar-
type:runtime.metricKind -> type:.namedata.*runtime.metricKind-
type:runtime.metricKind -> type:*runtime.metricKind
type:[68]uint64 -> type:.eqfunc544
type:[68]uint64 -> type:.namedata.*[68]uint64-
type:noalg.map.bucket[string]runtime.metricData -> runtime.gcbits.aaaa545503000000
type:noalg.map.bucket[string]runtime.metricData -> type:.namedata.*map.bucket[string]runtime.metricData-
type:noalg.map.bucket[string]runtime.metricData -> type:noalg.[8]runtime.metricData
type:noalg.[8]runtime.metricData -> type:.namedata.*[8]runtime.metricData-
type:noalg.[8]runtime.metricData -> type:[]runtime.metricData
type:[]runtime.metricData -> type:.namedata.*[]runtime.metricData-
type:noalg.struct { F uintptr; R runtime.metricReader } -> type:.namedata.*struct { F uintptr; R runtime.metricReader }-
type:noalg.struct { F uintptr; R runtime.metricReader } -> type:.namedata.R.
type:noalg.struct { F uintptr; R runtime.metricReader } -> type:runtime.metricReader
type:runtime.metricReader -> type:.namedata.*runtime.metricReader-
type:runtime.metricReader -> type:*runtime.metricReader
runtime.compute0·f -> runtime.compute0
runtime.initMetrics.func1·f -> runtime.initMetrics.func1
 -> go:info.runtime.NumCgoCall$abstract
runtime.initMetrics.func10·f -> runtime.initMetrics.func10
 -> go:info.runtime.nsToSec$abstract
runtime.initMetrics.func11·f -> runtime.initMetrics.func11
runtime.initMetrics.func12·f -> runtime.initMetrics.func12
runtime.initMetrics.func13·f -> runtime.initMetrics.func13
runtime.initMetrics.func14·f -> runtime.initMetrics.func14
runtime.initMetrics.func15·f -> runtime.initMetrics.func15
runtime.initMetrics.func16·f -> runtime.initMetrics.func16
runtime.initMetrics.func17·f -> runtime.initMetrics.func17
runtime.initMetrics.func18·f -> runtime.initMetrics.func18
runtime.initMetrics.func19·f -> runtime.initMetrics.func19
runtime.initMetrics.func2·f -> runtime.initMetrics.func2
runtime.initMetrics.func20·f -> runtime.initMetrics.func20
runtime.initMetrics.func20 -> type:runtime.metricFloat64Histogram
type:runtime.metricFloat64Histogram -> type:.namedata.*runtime.metricFloat64Histogram-
type:runtime.metricFloat64Histogram -> type:*runtime.metricFloat64Histogram
type:runtime.metricFloat64Histogram -> type:.namedata.counts-
type:runtime.metricFloat64Histogram -> type:[]float64
 -> go:info.*runtime.metricFloat64Histogram
 -> go:info.runtime.(*metricValue).float64HistOrInit$abstract
type:[]float64 -> type:.namedata.*[]float64-
runtime.initMetrics.func21·f -> runtime.initMetrics.func21
runtime.initMetrics.func22·f -> runtime.initMetrics.func22
runtime.initMetrics.func23·f -> runtime.initMetrics.func23
runtime.initMetrics.func24·f -> runtime.initMetrics.func24
runtime.initMetrics.func25·f -> runtime.initMetrics.func25
runtime.initMetrics.func26·f -> runtime.initMetrics.func26
runtime.initMetrics.func27·f -> runtime.initMetrics.func27
runtime.initMetrics.func28·f -> runtime.initMetrics.func28
runtime.initMetrics.func29·f -> runtime.initMetrics.func29
runtime.initMetrics.func3·f -> runtime.initMetrics.func3
runtime.initMetrics.func30·f -> runtime.initMetrics.func30
runtime.initMetrics.func31·f -> runtime.initMetrics.func31
runtime.initMetrics.func32·f -> runtime.initMetrics.func32
runtime.initMetrics.func33·f -> runtime.initMetrics.func33
runtime.initMetrics.func33 -> runtime.(*timeHistogram).write
runtime.initMetrics.func34·f -> runtime.initMetrics.func34
runtime.initMetrics.func35·f -> runtime.initMetrics.func35
runtime.initMetrics.func36·f -> runtime.initMetrics.func36
runtime.initMetrics.func37·f -> runtime.initMetrics.func37
runtime.initMetrics.func38·f -> runtime.initMetrics.func38
runtime.initMetrics.func39·f -> runtime.initMetrics.func39
runtime.initMetrics.func4·f -> runtime.initMetrics.func4
runtime.initMetrics.func40·f -> runtime.initMetrics.func40
runtime.initMetrics.func41·f -> runtime.initMetrics.func41
runtime.initMetrics.func42·f -> runtime.initMetrics.func42
runtime.initMetrics.func43·f -> runtime.initMetrics.func43
runtime.initMetrics.func44·f -> runtime.initMetrics.func44
runtime.initMetrics.func45·f -> runtime.initMetrics.func45
runtime.initMetrics.func46·f -> runtime.initMetrics.func46
runtime.initMetrics.func47·f -> runtime.initMetrics.func47
runtime.initMetrics.func48·f -> runtime.initMetrics.func48
runtime.initMetrics.func49·f -> runtime.initMetrics.func49
runtime.initMetrics.func5·f -> runtime.initMetrics.func5
runtime.initMetrics.func50·f -> runtime.initMetrics.func50
 -> go:info.runtime.gcount$abstract
runtime.initMetrics.func51·f -> runtime.initMetrics.func51
runtime.initMetrics.func52·f -> runtime.initMetrics.func52
runtime.initMetrics.func53·f -> runtime.initMetrics.func53
runtime.initMetrics.func54·f -> runtime.initMetrics.func54
runtime.initMetrics.func55·f -> runtime.initMetrics.func55
runtime.initMetrics.func56·f -> runtime.initMetrics.func56
 -> go:info.runtime.totalMutexWaitTimeNanos$abstract
runtime.initMetrics.func6·f -> runtime.initMetrics.func6
runtime.initMetrics.func7·f -> runtime.initMetrics.func7
runtime.initMetrics.func8·f -> runtime.initMetrics.func8
runtime.initMetrics.func9·f -> runtime.initMetrics.func9
 -> go:info.sync/atomic.(*Uint64).Load$abstract
type:.eqfunc.internal/godebug.setting -> type:.eq.internal/godebug.setting
type:.eqfunc.internal/godebug.value -> type:.eq.internal/godebug.value
 -> go:info.*internal/godebug.value
type:noalg.struct { F uintptr; R *sync/atomic.Uint64 } -> type:.namedata.*struct { F uintptr; R *atomic.Uint64 }-
internal/bisect..stmp_0 -> go:string."bisect.Hash: unexpected argument type"
go:info.internal/bisect.(*Matcher).matchResult$abstract -> go:info.*internal/bisect.cond
go:info.internal/bisect.AppendMarker$abstract -> go:info.[33]uint8
go:info.internal/bisect.(*atomicPointerDedup).Load$abstract -> go:info.*internal/bisect.atomicPointerDedup
type:[]internal/bisect.cond <UsedInIface> -> type:.namedata.*[]bisect.cond-
type:[]internal/bisect.cond <UsedInIface> -> type:internal/bisect.cond <UsedInIface>
type:internal/bisect.cond <UsedInIface> -> type:.eqfunc.internal/bisect.cond
type:internal/bisect.cond <UsedInIface> -> type:.namedata.*bisect.cond-
type:internal/bisect.cond <UsedInIface> -> type:*internal/bisect.cond <UsedInIface>
type:internal/bisect.cond <UsedInIface> -> type:.namedata.mask-
type:internal/bisect.cond <UsedInIface> -> type:.namedata.bits-
type:internal/bisect.cond <UsedInIface> -> type:.namedata.result-
type:.eqfunc.internal/bisect.cond -> type:.eq.internal/bisect.cond
type:[128][4]uint64 -> type:.namedata.*[128][4]uint64-
type:[128][4]uint64 -> type:[][4]uint64
type:[][4]uint64 -> type:.namedata.*[][4]uint64-
type:map[uint64]bool -> type:.namedata.*map[uint64]bool-
type:map[uint64]bool -> type:noalg.map.bucket[uint64]bool
type:noalg.map.bucket[uint64]bool -> type:.namedata.*map.bucket[uint64]bool-
type:noalg.map.bucket[uint64]bool -> type:noalg.[8]uint64
type:noalg.[8]uint64 -> type:.namedata.*[8]uint64-
type:[50]uint8 -> type:.eqfunc50
type:[50]uint8 -> type:.namedata.*[50]uint8-
go:main.inittasks -> internal/bytealg..inittask
go:main.inittasks -> math..inittask
go:main.inittasks -> runtime..inittask
go:main.inittasks -> errors..inittask
go:main.inittasks -> sync..inittask
go:main.inittasks -> internal/godebug..inittask
go:main.inittasks -> syscall..inittask
go:main.inittasks -> time..inittask
go:main.inittasks -> io/fs..inittask
go:main.inittasks -> os..inittask
go:main.inittasks -> unicode..inittask
go:main.inittasks -> reflect..inittask
errors..inittask -> errors.init
errors.init -> go:itab.internal/reflectlite.rtype,internal/reflectlite.Type
errors.init -> errors.errorType
 -> go:info.internal/reflectlite.Type
 -> go:info.internal/reflectlite.TypeOf$abstract
 -> go:info.internal/reflectlite.toType$abstract
os..inittask -> os.init
os..inittask -> os.init.0
os.init -> io/fs.ErrInvalid
os.init -> os.ErrInvalid
os.init -> io/fs.ErrPermission
os.init -> os.ErrPermission
os.init -> io/fs.ErrExist
os.init -> os.ErrExist
os.init -> io/fs.ErrNotExist
os.init -> os.ErrNotExist
os.init -> io/fs.ErrClosed
os.init -> os.ErrClosed
os.init -> internal/poll.ErrNoDeadline
os.init -> os.ErrNoDeadline
os.init -> internal/poll.ErrDeadlineExceeded
os.init -> os.ErrDeadlineExceeded
os.init -> syscall.Stdin
os.init -> go:string."/dev/stdin"
os.init -> os.NewFile
os.init -> os.Stdin
os.init -> syscall.Stdout
os.init -> go:string."/dev/stdout"
os.init -> syscall.Stderr
os.init -> go:string."/dev/stderr"
os.init -> os.Stderr
os.init -> os.Getwd
os.init -> os.initCwd
os.init -> os.initCwdErr
os.NewFile -> internal/syscall/unix.Fcntl
os.NewFile -> os.newFile
os.newFile -> syscall.SetNonblock
os.newFile -> go:string."file"
os.newFile -> internal/poll.(*FD).Init
os.newFile -> type:func(*os.file) error <UsedInIface>
os.newFile -> os.(*file).close·f
os.newFile -> runtime.SetFinalizer
os.newFile -> syscall.Fstat
os.newFile -> go:itab.syscall.Errno,error
os.newFile -> gclocals·TiGXBTFBYtQ3/ac6Hp0oWQ==
os.Getwd -> go:string."."
os.Getwd -> os.statNolog
os.Getwd -> go:string."PWD"
os.Getwd -> os.Getenv
os.Getwd -> go:itab.*os.fileStat,io/fs.FileInfo
os.Getwd -> syscall.Getwd
os.Getwd -> type:os.SyscallError
os.Getwd -> go:string."getwd"
os.Getwd -> go:itab.*os.SyscallError,error
os.Getwd -> gclocals·qQWCyKEUQLxG00FY18/lUg==
os.Getenv -> internal/testlog.Getenv
os.Getenv -> syscall.Getenv
os.init.0 -> os.runtime_args
os.init.0 -> os.Args
os.statNolog -> type:os.fileStat
os.statNolog -> syscall.Stat
os.statNolog -> type:io/fs.PathError
os.statNolog -> go:string."stat"
os.statNolog -> go:itab.*io/fs.PathError,error
os.statNolog -> os.fillFileStatFromSys
os.statNolog -> gclocals·zLPNfXlJUn7t8jGzBzeHcg==
os.fillFileStatFromSys -> time.Local
type:os.fileStat -> type:.eqfunc.os.fileStat
type:os.fileStat -> runtime.gcbits.4100000000000000
type:os.fileStat -> type:.namedata.*os.fileStat-
type:os.fileStat -> type:*os.fileStat <UsedInIface>
type:os.fileStat -> type:.namedata.mode-
type:os.fileStat -> type:io/fs.FileMode
type:os.fileStat -> type:.namedata.modTime-
type:os.fileStat -> type:time.Time
type:os.fileStat -> type:.namedata.sys-
type:os.fileStat -> type:syscall.Stat_t
type:*os.fileStat <UsedInIface> -> type:os.fileStat <UsedInIface>
type:*os.fileStat <UsedInIface> -> type:.namedata.IsDir.
type:*os.fileStat <UsedInIface> -> type:.namedata.ModTime.
type:*os.fileStat <UsedInIface> -> type:.namedata.Mode.
type:*os.fileStat <UsedInIface> -> type:.namedata.Sys.
type:os.fileStat <UsedInIface> -> type:io/fs.FileMode <UsedInIface>
type:os.fileStat <UsedInIface> -> type:time.Time <UsedInIface>
type:os.fileStat <UsedInIface> -> type:syscall.Stat_t <UsedInIface>
type:os.SyscallError -> type:.eqfunc.os.SyscallError
type:os.SyscallError -> type:.namedata.*os.SyscallError.
type:os.SyscallError -> type:*os.SyscallError <UsedInIface>
type:os.SyscallError -> type:.namedata.Syscall.
type:os.SyscallError -> type:.namedata.Err.
type:*os.SyscallError <UsedInIface> -> type:os.SyscallError <UsedInIface>
type:*os.SyscallError <UsedInIface> -> type:.namedata.Timeout.
type:*os.SyscallError <UsedInIface> -> type:.namedata.Unwrap.
 -> go:info.os.newFileKind
 -> go:info.internal/syscall/unix.HasNonblockFlag$abstract
 -> go:info.syscall.Stat_t
 -> go:info.os.ignoringEINTR$abstract
 -> go:info.os.newFile.func1$abstract
 -> go:info.io/fs.FileInfo
 -> go:info.os.SameFile$abstract
 -> go:info.os.sameFile$abstract
 -> go:info.os.NewSyscallError$abstract
 -> go:info.*os.fileStat
 -> go:info.os.basename$abstract
 -> go:info.syscall.(*Timespec).Unix$abstract
 -> go:info.time.Unix$abstract
 -> go:info.time.unixTime$abstract
 -> go:info.os.statNolog.func1$abstract
reflect..inittask -> reflect.init
reflect.init -> reflect..stmp_2
reflect.init -> reflect.stringType
reflect.init -> gclocals·/ydTHfVJHvKeH/UP4dRKSQ==
reflect.init -> reflect.init.stkobj
 -> go:info.reflect.rtypeOf$abstract
sync..inittask -> sync.init
sync..inittask -> sync.init.0
sync..inittask -> sync.init.1
sync.init.0 -> sync.poolCleanup·f
sync.init.0 -> sync.runtime_registerPoolCleanup
sync.init.1 -> sync.runtime_notifyListCheck
math..inittask -> math.init
math.init -> math.useFMA
internal/bytealg..inittask -> internal/bytealg.init.0
internal/bytealg.init.0 -> internal/bytealg.MaxLen
type:io/fs.FileMode <UsedInIface> -> type:.namedata.*fs.FileMode.
type:io/fs.FileMode <UsedInIface> -> type:*io/fs.FileMode <UsedInIface>
type:io/fs.FileMode <UsedInIface> -> type:.importpath.io/fs.
type:io/fs.FileMode <UsedInIface> -> type:.namedata.IsRegular.
type:io/fs.PathError -> type:.eqfunc.io/fs.PathError
type:io/fs.PathError -> type:.namedata.*fs.PathError.
type:io/fs.PathError -> type:*io/fs.PathError <UsedInIface>
type:io/fs.PathError -> type:.namedata.Op.
type:io/fs.PathError -> type:.namedata.Path.
type:*io/fs.PathError <UsedInIface> -> type:io/fs.PathError <UsedInIface>
io/fs..inittask -> io/fs.init
io/fs.init -> internal/oserror.ErrInvalid
io/fs.init -> internal/oserror.ErrPermission
io/fs.init -> internal/oserror.ErrExist
io/fs.init -> internal/oserror.ErrNotExist
io/fs.init -> internal/oserror.ErrClosed
runtime.SetFinalizer -> runtime.SetFinalizer.jump137
runtime.SetFinalizer -> runtime.SetFinalizer.func1
runtime.SetFinalizer -> runtime.createfing
runtime.SetFinalizer -> runtime.SetFinalizer.func2
runtime.SetFinalizer -> go:string." to finalizer "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: cannot pass "
runtime.SetFinalizer -> runtime.concatstring4
runtime.SetFinalizer -> go:string." because dotdotdot"
runtime.SetFinalizer -> go:string.", not a function"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: second argument is "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: pointer not at beginning of allocated block"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: pointer not in allocated block"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument was allocated into an arena"
runtime.SetFinalizer -> go:string."nil elem type!"
runtime.SetFinalizer -> go:string.", not pointer"
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument is "
runtime.SetFinalizer -> go:string."runtime.SetFinalizer: first argument is nil"
runtime.SetFinalizer -> gclocals·sPiy/NR6R8+sHHDr88aLSQ==
runtime.SetFinalizer -> gclocals·PQuuxZIkU8lIJf1xt/boTA==
runtime.SetFinalizer -> runtime.SetFinalizer.stkobj
runtime.SetFinalizer -> errors.Is.arginfo1
runtime.createfing -> runtime.runfinq·f
runtime.SetFinalizer.func2 -> runtime.addfinalizer
runtime.SetFinalizer.func2 -> go:string."runtime.SetFinalizer: finalizer already set"
runtime.SetFinalizer.func1 -> runtime.removefinalizer
runtime.addfinalizer -> gclocals·VBaJumnFu59aNGfEoL8NYQ==
runtime.addfinalizer -> gclocals·HsjFlllpLIcdLNjNFrk/qw==
runtime.removefinalizer -> runtime.removespecial
runtime.removespecial -> go:string."removespecial on invalid pointer"
runtime.concatstring4 -> gclocals·vXi8VFVnn6c0AV6oT7spEA==
runtime.concatstring4 -> gclocals·Hy98/6xEkdIEkxCdiINBiA==
runtime.concatstring4 -> runtime.concatstring4.stkobj
runtime.concatstring4 -> runtime.concatstring4.arginfo1
runtime..inittask -> runtime.init
runtime..inittask -> runtime.init.0
runtime..inittask -> runtime.init.1
runtime..inittask -> runtime.init.4
runtime..inittask -> runtime.init.5
runtime..inittask -> runtime.init.6
runtime.init -> runtime.inf
runtime.init -> runtime.uint16Eface
runtime.init -> runtime.uint16Type
runtime.init -> runtime.uint32Eface
runtime.init -> runtime.uint32Type
runtime.init -> runtime.uint64Eface
runtime.init -> runtime.uint64Type
runtime.init -> runtime.stringEface
runtime.init -> runtime.sliceEface
runtime.init -> runtime.pdEface
runtime.init -> runtime.pdType
runtime.init -> runtime.chansendpc
runtime.init -> runtime.chanrecvpc
runtime.init.0 -> go:string."user arena chunk size is not a multiple of the physical page size"
runtime.init.5 -> go:string."runtime: asyncPreemptStack="
runtime.init.5 -> go:string."async stack too large"
runtime.init.6 -> runtime.forcegchelper·f
runtime.uint16Eface -> type:runtime.uint16InterfacePtr <UsedInIface>
runtime.uint16Eface -> runtime..stmp_0
type:runtime.uint16InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint16InterfacePtr-
type:runtime.uint16InterfacePtr <UsedInIface> -> type:*runtime.uint16InterfacePtr <UsedInIface>
runtime.uint32Eface -> type:runtime.uint32InterfacePtr <UsedInIface>
runtime.uint32Eface -> runtime..stmp_1
type:runtime.uint32InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint32InterfacePtr-
type:runtime.uint32InterfacePtr <UsedInIface> -> type:*runtime.uint32InterfacePtr <UsedInIface>
runtime.uint64Eface -> type:runtime.uint64InterfacePtr <UsedInIface>
runtime.uint64Eface -> runtime..stmp_2
type:runtime.uint64InterfacePtr <UsedInIface> -> type:.namedata.*runtime.uint64InterfacePtr-
type:runtime.uint64InterfacePtr <UsedInIface> -> type:*runtime.uint64InterfacePtr <UsedInIface>
runtime.stringEface -> type:runtime.stringInterfacePtr <UsedInIface>
runtime.stringEface -> runtime..stmp_3
type:runtime.stringInterfacePtr <UsedInIface> -> type:.namedata.*runtime.stringInterfacePtr-
type:runtime.stringInterfacePtr <UsedInIface> -> type:*runtime.stringInterfacePtr <UsedInIface>
runtime.sliceEface -> type:runtime.sliceInterfacePtr <UsedInIface>
runtime.sliceEface -> runtime..stmp_4
type:runtime.sliceInterfacePtr <UsedInIface> -> type:.namedata.*runtime.sliceInterfacePtr-
type:runtime.sliceInterfacePtr <UsedInIface> -> type:*runtime.sliceInterfacePtr <UsedInIface>
runtime.pdEface -> type:*runtime.pollDesc <UsedInIface>
runtime.pdEface -> runtime..stmp_62
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.*runtime.pollDesc-
type:*runtime.pollDesc <UsedInIface> -> type:runtime.pollDesc <UsedInIface>
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.makeArg-
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.publishInfo-
type:*runtime.pollDesc <UsedInIface> -> type:.namedata.setEventErr-
type:runtime.pollDesc <UsedInIface> -> runtime.gcbits.0050800200000000
type:runtime.pollDesc <UsedInIface> -> type:.namedata.fd-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.fdseq-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.atomicInfo-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rg-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wg-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.closing-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.user-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rseq-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rt-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.rd-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wseq-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wt-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.wd-
type:runtime.pollDesc <UsedInIface> -> type:.namedata.self-
 -> go:info.runtime.init.func2$abstract
 -> go:info.runtime.isGoPointerWithoutSpan$abstract
 -> go:info.internal/abi.(*FuncType).IsVariadic$abstract
 -> go:info.runtime.assertE2I2$abstract
syscall.Getenv -> syscall.envOnce
syscall.Getenv -> syscall.copyenv·f
syscall.Getenv -> syscall.envLock
syscall.Getenv -> sync.runtime_SemacquireRWMutexR
syscall.Getenv -> syscall.Getenv.deferwrap1
syscall.Getenv -> syscall.env
syscall.Getenv -> type:map[string]int
syscall.Getenv -> syscall.envs
syscall.Getenv -> gclocals·0hv/RmXAtDdNsAx7W5h4BA==
syscall.Getenv.deferwrap1 -> sync.(*RWMutex).rUnlockSlow
syscall.Getenv.deferwrap1 -> sync.(*RWMutex).RUnlock.wrapinfo
sync.(*RWMutex).rUnlockSlow -> go:string."sync: RUnlock of unlocked RWMutex"
 -> go:info.*sync.RWMutex
 -> go:info.sync/atomic.(*Int32).Add$abstract
syscall.SetNonblock -> syscall.fcntl
syscall.Getwd -> syscall.getcwd
syscall.Getwd -> internal/bytealg.IndexByte
syscall.fcntl -> syscall.libc_fcntl_trampoline
syscall.fcntl -> syscall.syscall
syscall.fcntl -> syscall.errENOENT
syscall.fcntl -> syscall.errEINVAL
syscall.fcntl -> syscall.errEAGAIN
syscall.fcntl -> runtime.convT64
syscall.getcwd -> syscall._zero
syscall.getcwd -> syscall.libc_getcwd_trampoline
syscall.Fstat -> syscall.libc_fstat64_trampoline
syscall.Stat -> syscall.ByteSliceFromString
syscall.Stat -> syscall.libc_stat64_trampoline
syscall.Stat -> gclocals·bdRGhTu3N4Ox9FV5PE/puw==
syscall.Stat -> gclocals·u4npXzpczARmfYWrcF1twA==
syscall..inittask -> syscall.init
syscall..inittask -> syscall.init.0
syscall..inittask -> syscall.init.1
syscall.init -> syscall.runtime_envs
syscall.init -> syscall.libc_dup2_trampoline
syscall.init -> syscall.dupTrampoline
syscall.init -> syscall..stmp_3
syscall.init -> syscall.minRoutingSockaddrLen
syscall.init.0 -> type:syscall.Rlimit
syscall.init.0 -> syscall.Getrlimit
syscall.init.0 -> syscall.origRlimitNofile
syscall.init.0 -> syscall.adjustFileLimit
syscall.init.0 -> syscall.setrlimit
syscall.adjustFileLimit -> go:string."kern.maxfilesperproc"
syscall.adjustFileLimit -> syscall.SysctlUint32
syscall.SysctlUint32 -> syscall.nametomib
syscall.SysctlUint32 -> syscall.sysctl
syscall.nametomib -> type:[14]syscall._C_int
syscall.init.1 -> syscall.execveDarwin
syscall.init.1 -> syscall.execve·f
syscall.Getrlimit -> syscall.libc_getrlimit_trampoline
syscall.Getrlimit -> syscall.rawSyscall
syscall.setrlimit -> syscall.libc_setrlimit_trampoline
syscall.sysctl -> syscall.libc_sysctl_trampoline
syscall.sysctl -> syscall.syscall6
syscall.sysctl -> gclocals·90V1RNS5Md4xmnoYJTFCBw==
syscall.sysctl -> syscall.Select.stkobj
syscall.sysctl -> syscall.sysctl.arginfo1
type:syscall.Rlimit -> type:.namedata.*syscall.Rlimit.
type:syscall.Rlimit -> type:*syscall.Rlimit
type:syscall.Rlimit -> type:.namedata.Cur.
type:syscall.Rlimit -> type:.namedata.Max.
type:syscall.Stat_t <UsedInIface> -> type:.eqfunc144
type:syscall.Stat_t <UsedInIface> -> type:.namedata.*syscall.Stat_t.
type:syscall.Stat_t <UsedInIface> -> type:*syscall.Stat_t <UsedInIface>
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Dev.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Nlink.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Ino.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Uid.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Gid.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Rdev.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Pad_cgo_0.
type:syscall.Stat_t <UsedInIface> -> type:[4]uint8 <UsedInIface>
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Atimespec.
type:syscall.Stat_t <UsedInIface> -> type:syscall.Timespec <UsedInIface>
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Mtimespec.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Ctimespec.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Birthtimespec.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Blocks.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Blksize.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Flags.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Gen.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Lspare.
type:syscall.Stat_t <UsedInIface> -> type:.namedata.Qspare.
type:syscall.Stat_t <UsedInIface> -> type:[2]int64 <UsedInIface>
type:syscall.Timespec <UsedInIface> -> type:.namedata.*syscall.Timespec.
type:syscall.Timespec <UsedInIface> -> type:*syscall.Timespec <UsedInIface>
type:syscall.Timespec <UsedInIface> -> type:.namedata.Sec.
type:syscall.Timespec <UsedInIface> -> type:.namedata.Nsec.
type:*syscall.Timespec <UsedInIface> -> type:.namedata.Nano.
type:*syscall.Timespec <UsedInIface> -> type:.namedata.Unix.
 -> go:info.sync.Once
 -> go:info.sync.RWMutex
 -> go:info.map[string]int
 -> go:info.func(*uint8, **uint8, **uint8) error
 -> go:info.sync/atomic.Pointer[syscall.Rlimit]
syscall.errEAGAIN -> syscall..stmp_0
syscall.errEINVAL -> syscall..stmp_1
syscall.errENOENT -> syscall..stmp_2
syscall..stmp_3 -> syscall.mmap·f
syscall..stmp_3 -> syscall.munmap·f
 -> go:info.sync.(*RWMutex).RLock$abstract
 -> go:info.sync.(*RWMutex).RUnlock$abstract
 -> go:info.*syscall.Rlimit
 -> go:info.syscall.Rlimit
 -> go:info.sync/atomic.(*Pointer[go.shape.struct { Cur uint64; Max uint64 }]).Store$abstract
 -> go:info.syscall.clen$abstract
 -> go:info.[]syscall._C_int
 -> go:info.*[14]syscall._C_int
 -> go:info.syscall.Errno
 -> go:info.syscall.errnoErr$abstract
 -> go:info.*syscall.Stat_t
 -> go:info.syscall.BytePtrFromString$abstract
internal/testlog.Getenv -> internal/testlog.logger
internal/testlog.Getenv -> sync/atomic.firstStoreInProgress
internal/testlog.Getenv -> type:*internal/testlog.Interface
type:*internal/testlog.Interface -> type:.namedata.*testlog.Interface.
type:*internal/testlog.Interface -> type:internal/testlog.Interface
type:internal/testlog.Interface -> type:.importpath.internal/testlog.
type:internal/testlog.Interface -> type:func(string) <UsedInIface>
type:internal/testlog.Interface -> type:.namedata.Getenv.
type:internal/testlog.Interface -> type:.namedata.Open.
 -> go:info.sync/atomic.Value
 -> go:info.internal/testlog.Interface
 -> go:info.internal/testlog.Logger$abstract
 -> go:info.sync/atomic.(*Value).Load$abstract
internal/poll.(*FD).Init -> internal/poll.(*pollDesc).init
internal/poll.(*FD).Init -> fmt.(*ss).consume.arginfo1
internal/poll.(*pollDesc).init -> internal/poll.serverInit
internal/poll.(*pollDesc).init -> internal/poll.runtime_pollServerInit·f
internal/poll.(*pollDesc).init -> internal/poll.runtime_pollOpen
internal/poll.(*pollDesc).init -> internal/poll.errENOENT
internal/poll.(*pollDesc).init -> internal/poll.errEINVAL
internal/poll.(*pollDesc).init -> internal/poll.errEAGAIN
internal/poll.errEAGAIN -> internal/poll..stmp_0
internal/poll.errEINVAL -> internal/poll..stmp_1
internal/poll.errENOENT -> internal/poll..stmp_2
internal/poll.ErrNoDeadline -> go:itab.*errors.errorString,error
internal/poll.ErrNoDeadline -> internal/poll..stmp_4
internal/poll.ErrDeadlineExceeded -> go:itab.*internal/poll.DeadlineExceededError,error
internal/poll.ErrDeadlineExceeded -> internal/poll..stmp_5
internal/poll..stmp_4 -> go:string."file type does not support deadline"
 -> go:info.*internal/poll.pollDesc
 -> go:info.internal/poll.errnoErr$abstract
time..inittask -> time.init
time.init -> runtime.nanotime
time.init -> time.startNano
type:time.Time <UsedInIface> -> type:.namedata.*time.Time.
type:time.Time <UsedInIface> -> type:*time.Time <UsedInIface>
type:time.Time <UsedInIface> -> type:.importpath.time.
type:time.Time <UsedInIface> -> type:.namedata.wall-
type:time.Time <UsedInIface> -> type:.namedata.ext-
type:time.Time <UsedInIface> -> type:.namedata.loc-
type:time.Time <UsedInIface> -> type:*time.Location <UsedInIface>
type:time.Time <UsedInIface> -> type:.namedata.AddDate.
type:time.Time <UsedInIface> -> type:.namedata.After.
type:time.Time <UsedInIface> -> type:.namedata.AppendFormat.
type:time.Time <UsedInIface> -> type:.namedata.Before.
type:time.Time <UsedInIface> -> type:.namedata.Clock.
type:time.Time <UsedInIface> -> type:.namedata.Compare.
type:time.Time <UsedInIface> -> type:.namedata.Date.
type:time.Time <UsedInIface> -> type:.namedata.Day.
type:time.Time <UsedInIface> -> type:.namedata.GobEncode.
type:time.Time <UsedInIface> -> type:.namedata.Hour.
type:time.Time <UsedInIface> -> type:.namedata.ISOWeek.
type:time.Time <UsedInIface> -> type:.namedata.IsDST.
type:time.Time <UsedInIface> -> type:.namedata.Local.
type:time.Time <UsedInIface> -> type:.namedata.Location.
type:time.Time <UsedInIface> -> type:.namedata.MarshalBinary.
type:time.Time <UsedInIface> -> type:.namedata.MarshalJSON.
type:time.Time <UsedInIface> -> type:.namedata.MarshalText.
type:time.Time <UsedInIface> -> type:.namedata.Minute.
type:time.Time <UsedInIface> -> type:.namedata.Month.
type:time.Time <UsedInIface> -> type:.namedata.Nanosecond.
type:time.Time <UsedInIface> -> type:.namedata.Round.
type:time.Time <UsedInIface> -> type:.namedata.Second.
type:time.Time <UsedInIface> -> type:.namedata.Sub.
type:time.Time <UsedInIface> -> type:.namedata.UTC.
type:time.Time <UsedInIface> -> type:.namedata.UnixMicro.
type:time.Time <UsedInIface> -> type:.namedata.UnixMilli.
type:time.Time <UsedInIface> -> type:.namedata.UnixNano.
type:time.Time <UsedInIface> -> type:.namedata.Weekday.
type:time.Time <UsedInIface> -> type:.namedata.Year.
type:time.Time <UsedInIface> -> type:.namedata.YearDay.
type:time.Time <UsedInIface> -> type:.namedata.Zone.
type:time.Time <UsedInIface> -> type:.namedata.ZoneBounds.
type:time.Time <UsedInIface> -> type:.namedata.abs-
type:time.Time <UsedInIface> -> type:.namedata.appendFormat-
type:time.Time <UsedInIface> -> type:.namedata.appendFormatRFC3339-
type:time.Time <UsedInIface> -> type:.namedata.appendStrictRFC3339-
type:time.Time <UsedInIface> -> type:.namedata.date-
type:time.Time <UsedInIface> -> type:.namedata.locabs-
type:*time.Location <UsedInIface> -> type:.namedata.*time.Location.
type:*time.Location <UsedInIface> -> type:time.Location <UsedInIface>
type:*time.Location <UsedInIface> -> type:.namedata.firstZoneUsed-
type:*time.Location <UsedInIface> -> type:.namedata.lookup-
type:*time.Location <UsedInIface> -> type:.namedata.lookupFirstZone-
type:*time.Location <UsedInIface> -> type:.namedata.lookupName-
type:time.Location <UsedInIface> -> runtime.gcbits.2511000000000000
type:time.Location <UsedInIface> -> type:.namedata.zone-
type:time.Location <UsedInIface> -> type:[]time.zone <UsedInIface>
type:time.Location <UsedInIface> -> type:.namedata.tx-
type:time.Location <UsedInIface> -> type:[]time.zoneTrans <UsedInIface>
type:time.Location <UsedInIface> -> type:.namedata.extend-
type:time.Location <UsedInIface> -> type:.namedata.cacheStart-
type:time.Location <UsedInIface> -> type:.namedata.cacheEnd-
type:time.Location <UsedInIface> -> type:.namedata.cacheZone-
type:time.Location <UsedInIface> -> type:*time.zone <UsedInIface>
type:*time.zone <UsedInIface> -> type:.namedata.*time.zone-
type:*time.zone <UsedInIface> -> type:time.zone <UsedInIface>
type:time.zone <UsedInIface> -> type:.eqfunc.time.zone
type:time.zone <UsedInIface> -> type:.namedata.isDST-
type:*time.Time <UsedInIface> -> type:.namedata.GobDecode.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalBinary.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalJSON.
type:*time.Time <UsedInIface> -> type:.namedata.UnmarshalText.
type:*time.Time <UsedInIface> -> type:.namedata.addSec-
type:*time.Time <UsedInIface> -> type:.namedata.mono-
type:*time.Time <UsedInIface> -> type:.namedata.nsec-
type:*time.Time <UsedInIface> -> type:.namedata.sec-
type:*time.Time <UsedInIface> -> type:.namedata.setLoc-
type:*time.Time <UsedInIface> -> type:.namedata.setMono-
type:*time.Time <UsedInIface> -> type:.namedata.stripMono-
type:*time.Time <UsedInIface> -> type:.namedata.unixSec-
time.Local -> time.localLoc
 -> go:info.*time.Location
 -> go:info.time.Location
internal/syscall/unix.Fcntl -> runtime.fcntl
unicode..inittask -> unicode.init
unicode.init -> go:string."L"
unicode.init -> type:map[string]*unicode.RangeTable
unicode.init -> unicode.foldL
unicode.init -> go:string."Ll"
unicode.init -> unicode.foldLl
unicode.init -> go:string."Lt"
unicode.init -> unicode.foldLt
unicode.init -> go:string."Lu"
unicode.init -> unicode.foldLu
unicode.init -> go:string."M"
unicode.init -> unicode.foldM
unicode.init -> go:string."Mn"
unicode.init -> unicode.foldMn
unicode.init -> unicode.FoldCategory
unicode.init -> go:string."Common"
unicode.init -> unicode.foldCommon
unicode.init -> go:string."Greek"
unicode.init -> unicode.foldGreek
unicode.init -> go:string."Inherited"
unicode.init -> unicode.foldInherited
unicode.init -> unicode.FoldScript
unicode.init -> gclocals·HDED++1ZcAEHe1hn57Yo0A==
 -> go:info.map[string]*unicode.RangeTable
unicode.foldL -> unicode..stmp_623
 -> go:info.*unicode.RangeTable
unicode.foldLl -> unicode..stmp_625
unicode.foldLt -> unicode..stmp_628
unicode.foldLu -> unicode..stmp_630
unicode.foldM -> unicode..stmp_633
unicode.foldMn -> unicode..stmp_635
unicode.foldCommon -> unicode..stmp_637
unicode.foldGreek -> unicode..stmp_639
unicode.foldInherited -> unicode..stmp_641
unicode..stmp_623 -> unicode..stmp_624
unicode..stmp_625 -> unicode..stmp_626
unicode..stmp_625 -> unicode..stmp_627
unicode..stmp_628 -> unicode..stmp_629
unicode..stmp_630 -> unicode..stmp_631
unicode..stmp_630 -> unicode..stmp_632
unicode..stmp_633 -> unicode..stmp_634
unicode..stmp_635 -> unicode..stmp_636
unicode..stmp_637 -> unicode..stmp_638
unicode..stmp_639 -> unicode..stmp_640
unicode..stmp_641 -> unicode..stmp_642
internal/oserror.ErrInvalid -> internal/oserror..stmp_0
internal/oserror.ErrPermission -> internal/oserror..stmp_1
internal/oserror.ErrExist -> internal/oserror..stmp_2
internal/oserror.ErrNotExist -> internal/oserror..stmp_3
internal/oserror.ErrClosed -> internal/oserror..stmp_4
internal/oserror..stmp_0 -> go:string."invalid argument"
internal/oserror..stmp_1 -> go:string."permission denied"
internal/oserror..stmp_2 -> go:string."file already exists"
internal/oserror..stmp_3 -> go:string."file does not exist"
internal/oserror..stmp_4 -> go:string."file already closed"
internal/godebug..inittask -> internal/godebug.init.0
internal/godebug.init.0 -> internal/godebug.update·f
internal/godebug.init.0 -> internal/godebug.setUpdate
internal/godebug.init.0 -> internal/godebug.newIncNonDefault·f
internal/godebug.init.0 -> internal/godebug.setNewIncNonDefault
go:itab.*errors.errorString,error -> type:*errors.errorString <UsedInIface>
type:*errors.errorString <UsedInIface> -> type:.namedata.*errors.errorString-
type:*errors.errorString <UsedInIface> -> type:errors.errorString <UsedInIface>
type:*errors.errorString <UsedInIface> -> type:.importpath.errors.
type:func(string) <UsedInIface> -> type:.namedata.*func(string)-
go:itab.internal/reflectlite.rtype,internal/reflectlite.Type -> type:internal/reflectlite.Type
go:itab.internal/reflectlite.rtype,internal/reflectlite.Type -> type:internal/reflectlite.rtype <UsedInIface>
type:internal/reflectlite.Type -> type:.namedata.*reflectlite.Type.
type:internal/reflectlite.Type -> type:*internal/reflectlite.Type
type:internal/reflectlite.Type -> type:.importpath.internal/reflectlite.
type:internal/reflectlite.Type -> type:func(internal/reflectlite.Type) bool
type:internal/reflectlite.Type -> type:func() internal/reflectlite.Type
type:internal/reflectlite.Type -> type:func() internal/abi.Kind <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:.namedata.*reflectlite.rtype-
type:internal/reflectlite.rtype <UsedInIface> -> type:*internal/reflectlite.rtype <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:func(internal/reflectlite.Type) bool <UsedInIface>
type:internal/reflectlite.rtype <UsedInIface> -> type:func() internal/reflectlite.Type <UsedInIface>
go:info.internal/reflectlite.TypeOf$abstract -> go:info.internal/reflectlite.emptyInterface
go:itab.*os.fileStat,io/fs.FileInfo -> type:io/fs.FileInfo
type:io/fs.FileInfo -> type:.namedata.*fs.FileInfo.
type:io/fs.FileInfo -> type:*io/fs.FileInfo
type:io/fs.FileInfo -> type:func() time.Time <UsedInIface>
type:io/fs.FileInfo -> type:func() io/fs.FileMode <UsedInIface>
go:itab.syscall.Errno,error -> type:syscall.Errno <UsedInIface>
type:syscall.Errno <UsedInIface> -> type:.namedata.*syscall.Errno.
type:syscall.Errno <UsedInIface> -> type:*syscall.Errno <UsedInIface>
type:syscall.Errno <UsedInIface> -> type:.namedata.Is.
type:syscall.Errno <UsedInIface> -> type:.namedata.Temporary.
sync.(*RWMutex).RUnlock.wrapinfo -> sync.(*RWMutex).RUnlock
type:.eqfunc.os.fileStat -> type:.eq.os.fileStat
type:func() time.Time <UsedInIface> -> type:.namedata.*func() time.Time-
type:func() io/fs.FileMode <UsedInIface> -> type:.namedata.*func() fs.FileMode-
type:func(*os.file) error <UsedInIface> -> type:.namedata.*func(*os.file) error-
type:.eqfunc.os.SyscallError -> type:.eq.os.SyscallError
 -> go:info.*os.SyscallError
go:info.os.ignoringEINTR$abstract -> go:info.func() error
go:info.syscall.(*Timespec).Unix$abstract -> go:info.*syscall.Timespec
go:info.sync/atomic.(*Int32).Add$abstract -> go:info.*sync/atomic.Int32
go:info.sync/atomic.(*Value).Load$abstract -> go:info.*sync/atomic.Value
go:info.sync/atomic.(*Value).Load$abstract -> go:info.*sync/atomic.efaceWords
os.(*file).close·f -> os.(*file).close
os.(*file).close -> syscall.closedir
os.(*file).close -> internal/poll.(*FD).Close
os.(*file).close -> internal/poll.ErrFileClosing
os.(*file).close -> go:string."close"
os.(*file).close -> gclocals·Xts7OcECZRhSRBtANua2LQ==
os.(*file).close -> gclocals·xRcvuIOxpzKaUmhdAfzWhw==
 -> go:info.os.(*dirInfo).close$abstract
syscall.closedir -> syscall.libc_closedir_trampoline
internal/poll.(*FD).Close -> internal/poll.(*fdMutex).increfAndClose
internal/poll.(*FD).Close -> internal/poll.runtime_pollUnblock
internal/poll.(*FD).Close -> internal/poll.(*FD).decref
internal/poll.(*FD).Close -> internal/poll.runtime_Semacquire
internal/poll.(*FD).Close -> go:itab.internal/poll.errNetClosing,error
internal/poll.(*fdMutex).increfAndClose -> internal/poll.runtime_Semrelease
internal/poll.(*fdMutex).increfAndClose -> internal/poll..stmp_7
internal/poll.(*FD).decref -> internal/poll.(*FD).destroy
internal/poll.(*FD).decref -> internal/poll..stmp_11
internal/poll.(*FD).destroy -> internal/poll.runtime_pollClose
internal/poll.(*FD).destroy -> internal/poll.CloseFunc
internal/poll.ErrFileClosing -> internal/poll..stmp_3
internal/poll.CloseFunc -> syscall.Close·f
 -> go:info.func(int) error
internal/poll..stmp_3 -> go:string."use of closed file"
 -> go:info.*internal/poll.fdMutex
 -> go:info.internal/poll.(*fdMutex).decref$abstract
 -> go:info.internal/poll.(*pollDesc).close$abstract
 -> go:info.internal/poll.(*SysFile).destroy$abstract
 -> go:info.internal/poll.(*pollDesc).evict$abstract
 -> go:info.internal/poll.errClosing$abstract
go:info.os.(*dirInfo).close$abstract -> go:info.*os.dirInfo
type:func() internal/abi.Kind <UsedInIface> -> type:.namedata.*func() abi.Kind-
type:func() internal/abi.Kind <UsedInIface> -> type:internal/abi.Kind <UsedInIface>
type:internal/abi.Kind <UsedInIface> -> type:.namedata.*abi.Kind.
type:internal/abi.Kind <UsedInIface> -> type:*internal/abi.Kind <UsedInIface>
type:map[string]int -> type:.namedata.*map[string]int-
type:map[string]int -> type:noalg.map.bucket[string]int
type:noalg.map.bucket[string]int -> runtime.gcbits.aaaa000200000000
type:noalg.map.bucket[string]int -> type:.namedata.*map.bucket[string]int-
type:noalg.map.bucket[string]int -> type:noalg.[8]int
type:noalg.[8]int -> type:.namedata.*[8]int-
sync.poolCleanup·f -> sync.poolCleanup
sync.poolCleanup -> sync.oldPools
type:func(internal/reflectlite.Type) bool <UsedInIface> -> type:.namedata.*func(reflectlite.Type) bool-
type:func(internal/reflectlite.Type) bool <UsedInIface> -> type:internal/reflectlite.Type <UsedInIface>
type:internal/reflectlite.Type <UsedInIface> -> type:*internal/reflectlite.Type <UsedInIface>
type:func() internal/reflectlite.Type <UsedInIface> -> type:.namedata.*func() reflectlite.Type-
internal/bytealg.IndexByte -> internal/bytealg.IndexByte.args_stackmap
internal/bytealg.IndexByte -> internal/bytealg.IndexByte.arginfo0
type:.eqfunc.io/fs.PathError -> type:.eq.io/fs.PathError
 -> go:info.*io/fs.PathError
runtime.SetFinalizer.stkobj -> runtime.gcbits.3600000000000000
runtime.concatstring4.stkobj -> runtime.gcbits.5500000000000000
internal/poll.runtime_pollOpen -> runtime.pollcache
internal/poll.runtime_pollOpen -> runtime.(*pollCache).alloc
internal/poll.runtime_pollOpen -> runtime.(*pollDesc).publishInfo
internal/poll.runtime_pollOpen -> runtime.netpollopen
internal/poll.runtime_pollOpen -> runtime.(*pollCache).free
internal/poll.runtime_pollOpen -> go:string."runtime: blocked read on free polldesc"
internal/poll.runtime_pollOpen -> go:string."runtime: blocked write on free polldesc"
runtime.netpollopen -> gclocals·PywSJIYqXiMHWby6oWHnCg==
runtime.netpollopen -> runtime.netpollopen.stkobj
 -> go:info.runtime.pollCache
 -> go:info.*runtime.pollCache
 -> go:info.[2]runtime.keventt
runtime.netpollopen.stkobj -> runtime.gcbits.8800000000000000
internal/poll.runtime_pollClose -> go:string."runtime: blocked read on closing polldesc"
internal/poll.runtime_pollClose -> go:string."runtime: blocked write on closing polldesc"
internal/poll.runtime_pollClose -> go:string."runtime: close polldesc w/o unblock"
internal/poll.runtime_pollUnblock -> runtime.netpollgoready
internal/poll.runtime_pollUnblock -> go:string."runtime: unblock on closing polldesc"
internal/poll.runtime_pollUnblock -> gclocals·ObbMMIpVrAxUpCnzYk+HQQ==
runtime.netpollgoready -> runtime.netpollgoready.goready.func1
internal/godebug.setUpdate -> type:func(string, string) <UsedInIface>
internal/godebug.setUpdate -> runtime.godebugUpdate
internal/godebug.setUpdate -> runtime.godebugNotify
runtime.godebugNotify -> runtime.reparsedebugvars
runtime.reparsedebugvars -> gclocals·GMoPojWojcu2T072mcs6zQ==
runtime.reparsedebugvars -> runtime.reparsedebugvars.stkobj
 -> go:info.runtime/internal/atomic.Pointer[func(string, string)]
 -> go:info.func(string, string)
 -> go:info.*func(string, string)
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string, string)]).Store$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string, string)]).Load$abstract
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.string]).Load$abstract
type:func(string, string) <UsedInIface> -> type:.namedata.*func(string, string)-
internal/godebug.setNewIncNonDefault -> type:func(string) func()
 -> go:info.func(string) func()
 -> go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Store$abstract
sync.runtime_notifyListCheck -> go:string."runtime: bad notifyList size - sync="
sync.runtime_notifyListCheck -> go:string." runtime="
sync.runtime_notifyListCheck -> go:string."bad notifyList size"
syscall.syscall -> runtime.syscall
 -> go:info.struct { runtime.fn uintptr; runtime.a1 uintptr; runtime.a2 uintptr; runtime.a3 uintptr; runtime.r1 uintptr; runtime.r2 uintptr; runtime.err uintptr }
syscall.syscall6 -> runtime.syscall6
syscall.syscall6 -> runtime.doubleCheckHeapPointersInterior.arginfo1
 -> go:info.struct { runtime.fn uintptr; runtime.a1 uintptr; runtime.a2 uintptr; runtime.a3 uintptr; runtime.a4 uintptr; runtime.a5 uintptr; runtime.a6 uintptr; runtime.r1 uintptr; runtime.r2 uintptr; runtime.err uintptr }
go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string, string)]).Load$abstract -> go:info.*runtime/internal/atomic.Pointer[go.shape.func(string, string)]
go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string, string)]).Store$abstract -> go:info.*go.shape.func(string, string)
go:info.runtime/internal/atomic.(*Pointer[go.shape.func(string) func()]).Store$abstract -> go:info.*go.shape.func(string) func()
type:[2]int64 <UsedInIface> -> type:.namedata.*[2]int64-
type:func(string) func() -> type:.namedata.*func(string) func()-
runtime.forcegchelper·f -> runtime.forcegchelper
runtime.forcegchelper -> go:string."GC forced\n"
runtime.forcegchelper -> go:string."forcegc: phase error"
runtime.runfinq·f -> runtime.runfinq
runtime.runfinq -> runtime.intArgRegs
runtime.runfinq -> runtime.finalizercommit·f
runtime.runfinq -> go:string."bad kind in runfinq"
runtime.runfinq -> go:string."missing type in runfinq"
runtime.runfinq -> gclocals·kz6VQo8RBG8j9F8usE93nA==
runtime.runfinq -> gclocals·5DtMesfbWEqTJZiMdco9+g==
runtime.runfinq -> runtime.runfinq.stkobj
 -> go:info.runtime.assertE2I$abstract
 -> go:info.runtime/internal/atomic.(*Uint32).And$abstract
runtime.finalizercommit·f -> runtime.finalizercommit
runtime.syscall -> runtime.syscall.args_stackmap
runtime.syscall -> runtime.syscall.arginfo0
runtime.syscall6 -> runtime.syscall6.args_stackmap
runtime.syscall6 -> runtime.syscall6.arginfo0
go:info.sync/atomic.(*Pointer[go.shape.struct { Cur uint64; Max uint64 }]).Store$abstract -> go:info.*sync/atomic.Pointer[go.shape.struct { Cur uint64; Max uint64 }]
go:info.sync/atomic.(*Pointer[go.shape.struct { Cur uint64; Max uint64 }]).Store$abstract -> go:info.*go.shape.struct { Cur uint64; Max uint64 }
type:[14]syscall._C_int -> type:.namedata.*[14]syscall._C_int-
type:[14]syscall._C_int -> type:syscall._C_int
type:[14]syscall._C_int -> type:[]syscall._C_int
type:syscall._C_int -> type:.namedata.*syscall._C_int-
type:syscall._C_int -> type:*syscall._C_int
type:[]syscall._C_int -> type:.namedata.*[]syscall._C_int-
syscall.copyenv·f -> syscall.copyenv
syscall.execve·f -> syscall.execve
syscall.execve -> syscall.libc_execve_trampoline
syscall.execve -> syscall.recvfrom.stkobj
syscall.mmap·f -> syscall.mmap
syscall.mmap -> syscall.libc_mmap_trampoline
syscall.mmap -> syscall.syscall6X
syscall.syscall6X -> runtime.syscall6X
runtime.syscall6X -> runtime.syscall6X.args_stackmap
runtime.syscall6X -> runtime.syscall6X.arginfo0
syscall.munmap·f -> syscall.munmap
syscall.munmap -> syscall.libc_munmap_trampoline
syscall.libc_fcntl_trampoline -> syscall.libc_fcntl_trampoline.args_stackmap
syscall.libc_fcntl_trampoline -> syscall.libc_fcntl_trampoline.arginfo0
syscall.libc_closedir_trampoline -> libc_closedir
syscall.libc_closedir_trampoline -> syscall.libc_closedir_trampoline.args_stackmap
syscall.libc_closedir_trampoline -> syscall.libc_closedir_trampoline.arginfo0
syscall.libc_dup2_trampoline -> libc_dup2
syscall.libc_dup2_trampoline -> syscall.libc_dup2_trampoline.args_stackmap
syscall.libc_dup2_trampoline -> syscall.libc_dup2_trampoline.arginfo0
syscall.libc_getrlimit_trampoline -> libc_getrlimit
syscall.libc_getrlimit_trampoline -> syscall.libc_getrlimit_trampoline.args_stackmap
syscall.libc_getrlimit_trampoline -> syscall.libc_getrlimit_trampoline.arginfo0
syscall.libc_setrlimit_trampoline -> libc_setrlimit
syscall.libc_setrlimit_trampoline -> syscall.libc_setrlimit_trampoline.args_stackmap
syscall.libc_setrlimit_trampoline -> syscall.libc_setrlimit_trampoline.arginfo0
syscall.libc_mmap_trampoline -> syscall.libc_mmap_trampoline.args_stackmap
syscall.libc_mmap_trampoline -> syscall.libc_mmap_trampoline.arginfo0
syscall.libc_munmap_trampoline -> syscall.libc_munmap_trampoline.args_stackmap
syscall.libc_munmap_trampoline -> syscall.libc_munmap_trampoline.arginfo0
syscall.libc_execve_trampoline -> libc_execve
syscall.libc_execve_trampoline -> syscall.libc_execve_trampoline.args_stackmap
syscall.libc_execve_trampoline -> syscall.libc_execve_trampoline.arginfo0
syscall.libc_sysctl_trampoline -> syscall.libc_sysctl_trampoline.args_stackmap
syscall.libc_sysctl_trampoline -> syscall.libc_sysctl_trampoline.arginfo0
syscall.libc_getcwd_trampoline -> libc_getcwd
syscall.libc_getcwd_trampoline -> syscall.libc_getcwd_trampoline.args_stackmap
syscall.libc_getcwd_trampoline -> syscall.libc_getcwd_trampoline.arginfo0
syscall.libc_fstat64_trampoline -> libc_fstat64
syscall.libc_fstat64_trampoline -> syscall.libc_fstat64_trampoline.args_stackmap
syscall.libc_fstat64_trampoline -> syscall.libc_fstat64_trampoline.arginfo0
syscall.libc_stat64_trampoline -> libc_stat64
syscall.libc_stat64_trampoline -> syscall.libc_stat64_trampoline.args_stackmap
syscall.libc_stat64_trampoline -> syscall.libc_stat64_trampoline.arginfo0
go:itab.internal/poll.errNetClosing,error -> type:internal/poll.errNetClosing <UsedInIface>
type:internal/poll.errNetClosing <UsedInIface> -> type:.namedata.*poll.errNetClosing-
type:internal/poll.errNetClosing <UsedInIface> -> type:*internal/poll.errNetClosing <UsedInIface>
go:itab.*internal/poll.DeadlineExceededError,error -> type:*internal/poll.DeadlineExceededError <UsedInIface>
type:*internal/poll.DeadlineExceededError <UsedInIface> -> type:.namedata.*poll.DeadlineExceededError.
type:*internal/poll.DeadlineExceededError <UsedInIface> -> type:internal/poll.DeadlineExceededError <UsedInIface>
internal/poll..stmp_7 -> go:string."too many concurrent operations on a single file or socket (max 1048575)"
internal/poll..stmp_11 -> go:string."inconsistent poll.fdMutex"
go:info.internal/poll.(*SysFile).destroy$abstract -> go:info.*internal/poll.SysFile
internal/poll.runtime_pollServerInit·f -> internal/poll.runtime_pollServerInit
syscall.Close·f -> syscall.Close
syscall.Close -> syscall.libc_close_trampoline
syscall.libc_close_trampoline -> syscall.libc_close_trampoline.args_stackmap
syscall.libc_close_trampoline -> syscall.libc_close_trampoline.arginfo0
type:.eqfunc.time.zone -> type:.eq.time.zone
 -> go:info.*time.zone
type:[]time.zone <UsedInIface> -> type:.namedata.*[]time.zone-
type:[]time.zoneTrans <UsedInIface> -> type:.namedata.*[]time.zoneTrans-
type:[]time.zoneTrans <UsedInIface> -> type:time.zoneTrans <UsedInIface>
type:time.zoneTrans <UsedInIface> -> type:.eqfunc.time.zoneTrans
type:time.zoneTrans <UsedInIface> -> type:.namedata.*time.zoneTrans-
type:time.zoneTrans <UsedInIface> -> type:*time.zoneTrans <UsedInIface>
type:time.zoneTrans <UsedInIface> -> type:.namedata.index-
type:time.zoneTrans <UsedInIface> -> type:.namedata.isstd-
type:time.zoneTrans <UsedInIface> -> type:.namedata.isutc-
type:.eqfunc.time.zoneTrans -> type:.eq.time.zoneTrans
 -> go:info.*time.zoneTrans
type:map[string]*unicode.RangeTable -> type:.namedata.*map[string]*unicode.RangeTable-
type:map[string]*unicode.RangeTable -> type:*unicode.RangeTable
type:map[string]*unicode.RangeTable -> type:noalg.map.bucket[string]*unicode.RangeTable
type:*unicode.RangeTable -> type:.namedata.*unicode.RangeTable.
type:*unicode.RangeTable -> type:unicode.RangeTable
type:unicode.RangeTable -> type:.importpath.unicode.
type:unicode.RangeTable -> type:.namedata.R16.
type:unicode.RangeTable -> type:[]unicode.Range16
type:unicode.RangeTable -> type:.namedata.R32.
type:unicode.RangeTable -> type:[]unicode.Range32
type:unicode.RangeTable -> type:.namedata.LatinOffset.
type:[]unicode.Range16 -> type:.namedata.*[]unicode.Range16-
type:[]unicode.Range16 -> type:unicode.Range16
type:unicode.Range16 -> type:.eqfunc6
type:unicode.Range16 -> type:.namedata.*unicode.Range16.
type:unicode.Range16 -> type:*unicode.Range16
type:unicode.Range16 -> type:.namedata.Lo.
type:unicode.Range16 -> type:.namedata.Hi.
type:unicode.Range16 -> type:.namedata.Stride.
type:[]unicode.Range32 -> type:.namedata.*[]unicode.Range32-
type:[]unicode.Range32 -> type:unicode.Range32
type:unicode.Range32 -> type:.namedata.*unicode.Range32.
type:unicode.Range32 -> type:*unicode.Range32
type:noalg.map.bucket[string]*unicode.RangeTable -> runtime.gcbits.aaaafe0300000000
type:noalg.map.bucket[string]*unicode.RangeTable -> type:.namedata.*map.bucket[string]*unicode.RangeTable-
type:noalg.map.bucket[string]*unicode.RangeTable -> type:noalg.[8]*unicode.RangeTable
type:noalg.[8]*unicode.RangeTable -> type:.namedata.*[8]*unicode.RangeTable-
type:noalg.[8]*unicode.RangeTable -> type:[]*unicode.RangeTable
type:[]*unicode.RangeTable -> type:.namedata.*[]*unicode.RangeTable-
internal/godebug.newIncNonDefault·f -> internal/godebug.newIncNonDefault
internal/godebug.newIncNonDefault -> type:internal/godebug.Setting
internal/godebug.newIncNonDefault -> type:noalg.struct { F uintptr; R *internal/godebug.Setting }
internal/godebug.newIncNonDefault -> internal/godebug.(*Setting).IncNonDefault-fm
type:internal/godebug.Setting -> type:.eqfunc.internal/godebug.Setting
type:internal/godebug.Setting -> type:.namedata.*godebug.Setting.
type:internal/godebug.Setting -> type:*internal/godebug.Setting
type:internal/godebug.Setting -> type:.namedata.once-
type:internal/godebug.Setting -> type:.namedata.setting-.embedded
type:*internal/godebug.Setting -> type:.namedata.IncNonDefault.
type:*internal/godebug.Setting -> type:.namedata.Undocumented.
type:*internal/godebug.Setting -> type:.namedata.register-
 -> go:info.internal/godebug.New$abstract
type:.eqfunc.internal/godebug.Setting -> type:.eq.internal/godebug.Setting
type:noalg.struct { F uintptr; R *internal/godebug.Setting } -> type:.namedata.*struct { F uintptr; R *godebug.Setting }-
internal/godebug.update·f -> internal/godebug.update
internal/godebug.update -> internal/godebug.updateMu
internal/godebug.update -> internal/godebug.update.deferwrap1
internal/godebug.update -> internal/godebug.parse
internal/godebug.update -> internal/godebug.update.func1
internal/godebug.update -> sync.(*Map).Range
internal/godebug.update -> gclocals·d0+zYq6BHpMNXwMGAgVIMg==
internal/godebug.update -> gclocals·iy/yxL7xZJpRJOj1m2NbLA==
internal/godebug.update -> internal/godebug.update.stkobj
internal/godebug.update -> reflect.FuncOf.opendefer
sync.(*Map).Range -> gclocals·uhSR/cek+1H85S23t3z/Vw==
sync.(*Map).Range -> gclocals·pARaujNeX8xbIy+kb2lfgg==
sync.(*Map).Range -> sync.(*Map).Range.stkobj
 -> go:info.func(interface {}, interface {}) bool
internal/godebug.update.func1 -> gclocals·NyMzWkwXm/8IMJtDCfydFw==
internal/godebug.parse -> internal/bisect.New
internal/godebug.parse -> gclocals·Qk1QDc/bam1pg1nGf5Q6SA==
internal/godebug.parse -> gclocals·5L6DofzZ0S8CTWuwCKpToA==
internal/bisect.New -> type:internal/bisect.parseError
internal/bisect.New -> go:string."invalid pattern syntax: "
internal/bisect.New -> go:itab.*internal/bisect.parseError,error
internal/bisect.New -> go:string."y"
internal/bisect.New -> go:string."invalid pattern syntax (+ after -): "
internal/bisect.New -> go:string."pattern bits too long: "
internal/bisect.New -> gclocals·jloi1q1oVv77LY1DU2CFXw==
type:internal/bisect.parseError -> type:.namedata.*bisect.parseError-
type:internal/bisect.parseError -> type:*internal/bisect.parseError <UsedInIface>
type:*internal/bisect.parseError <UsedInIface> -> type:internal/bisect.parseError <UsedInIface>
type:runtime.errorString <UsedInIface> -> runtime.(*errorString).Error
type:runtime.errorString <UsedInIface> -> runtime.errorString.Error
type:*runtime.PanicNilError <UsedInIface> -> runtime.(*PanicNilError).Error
type:*runtime.TypeAssertionError <UsedInIface> -> runtime.(*TypeAssertionError).Error
type:*internal/abi.Type <UsedInIface> -> internal/abi.(*Type).Len
type:runtime.waitReason <UsedInIface> -> runtime.(*waitReason).String
type:runtime.waitReason <UsedInIface> -> runtime.waitReason.String
type:runtime.lockRank <UsedInIface> -> runtime.(*lockRank).String
type:runtime.lockRank <UsedInIface> -> runtime.lockRank.String
type:runtime.errorAddressString <UsedInIface> -> runtime.(*errorAddressString).Error
type:runtime.errorAddressString <UsedInIface> -> runtime.errorAddressString.Error
type:runtime.boundsError <UsedInIface> -> runtime.(*boundsError).Error
type:runtime.boundsError <UsedInIface> -> runtime.boundsError.Error
type:runtime.plainError <UsedInIface> -> runtime.(*plainError).Error
type:runtime.plainError <UsedInIface> -> runtime.plainError.Error
type:*fmt.pp <UsedInIface> -> fmt.(*pp).Write
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Len
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Less
type:*internal/fmtsort.SortedMap <UsedInIface> -> internal/fmtsort.(*SortedMap).Swap
type:reflect.Value <UsedInIface> -> reflect.(*Value).Kind
type:reflect.Value <UsedInIface> -> reflect.Value.Kind
type:reflect.Value <UsedInIface> -> reflect.(*Value).Len
type:reflect.Value <UsedInIface> -> reflect.Value.Len
type:reflect.Value <UsedInIface> -> reflect.(*Value).String
type:reflect.Value <UsedInIface> -> reflect.Value.String
type:*reflect.ValueError <UsedInIface> -> reflect.(*ValueError).Error
type:reflect.Kind <UsedInIface> -> reflect.(*Kind).String
type:reflect.Kind <UsedInIface> -> reflect.Kind.String
type:*internal/abi.FuncType <UsedInIface> -> internal/abi.(*FuncType).Len
type:*math/rand.lockedSource <UsedInIface> -> math/rand.(*lockedSource).Int63
type:*math/rand.lockedSource <UsedInIface> -> math/rand.(*lockedSource).Seed
type:*math/rand.rngSource <UsedInIface> -> math/rand.(*rngSource).Int63
type:*math/rand.runtimeSource <UsedInIface> -> math/rand.(*runtimeSource).Int63
type:*math/rand.runtimeSource <UsedInIface> -> math/rand.(*runtimeSource).Seed
type:*os.File <UsedInIface> -> os.(*File).Write
type:*internal/poll.FD <UsedInIface> -> internal/poll.(*FD).Write
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Elem
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Field
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Kind
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Len
type:reflect.ChanDir <UsedInIface> -> reflect.(*ChanDir).String
type:reflect.ChanDir <UsedInIface> -> reflect.ChanDir.String
type:*internal/godebug.runtimeStderr <UsedInIface> -> internal/godebug.(*runtimeStderr).Write
type:*os.SyscallError <UsedInIface> -> os.(*SyscallError).Error
type:io/fs.FileMode <UsedInIface> -> io/fs.(*FileMode).String
type:io/fs.FileMode <UsedInIface> -> io/fs.FileMode.String
type:*io/fs.PathError <UsedInIface> -> io/fs.(*PathError).Error
type:time.Time <UsedInIface> -> time.(*Time).GoString
type:time.Time <UsedInIface> -> time.Time.GoString
type:time.Time <UsedInIface> -> time.(*Time).String
type:time.Time <UsedInIface> -> time.Time.String
type:*time.Location <UsedInIface> -> time.(*Location).String
type:*errors.errorString <UsedInIface> -> errors.(*errorString).Error
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Elem
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Len
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.String
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Elem
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Len
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).String
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Error
type:syscall.Errno <UsedInIface> -> syscall.Errno.Error
type:internal/abi.Kind <UsedInIface> -> internal/abi.(*Kind).String
type:internal/abi.Kind <UsedInIface> -> internal/abi.Kind.String
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.(*errNetClosing).Error
type:internal/poll.errNetClosing <UsedInIface> -> internal/poll.errNetClosing.Error
type:*internal/poll.DeadlineExceededError <UsedInIface> -> internal/poll.(*DeadlineExceededError).Error
type:*internal/bisect.parseError <UsedInIface> -> internal/bisect.(*parseError).Error
fmt.(*pp).Write -> fmt.(*pp).Write.argliveinfo
 -> go:info.*errors.errorString
internal/fmtsort.(*SortedMap).Less -> internal/fmtsort.compare
internal/fmtsort.compare -> internal/fmtsort.compare.jump20
internal/fmtsort.compare -> reflect.Value.panicNotBool
internal/fmtsort.compare -> internal/fmtsort.nilCompare
internal/fmtsort.compare -> reflect.Value.Pointer
internal/fmtsort.compare -> reflect.Value.stringNonString
internal/fmtsort.compare -> go:string."reflect.Value.Complex"
internal/fmtsort.compare -> go:string."reflect.Value.Float"
internal/fmtsort.compare -> go:string."bad type in compare: "
internal/fmtsort.compare -> gclocals·JUNxvMpjQNQGr4IkDegLuQ==
internal/fmtsort.compare -> gclocals·uOfM34FHRRlFC67Ao7V+Hg==
internal/fmtsort.compare -> internal/fmtsort.compare.stkobj
internal/fmtsort.nilCompare -> go:string."reflect.Value.IsNil"
 -> go:info.internal/fmtsort.floatCompare$abstract
 -> go:info.internal/fmtsort.isNaN$abstract
os.(*File).Write -> io.ErrShortWrite
os.(*File).Write -> os.sigpipe
os.(*File).Write -> go:string."write"
os.(*File).Write -> os.(*File).wrapErr
io.ErrShortWrite -> io..stmp_0
io..stmp_0 -> go:string."short write"
os.(*File).wrapErr -> io.EOF
os.(*File).wrapErr -> os.checkWrapErr
os.(*File).wrapErr -> errors.Is
os.(*File).wrapErr -> go:string."unexpected error wrapping poll.ErrFileClosing: "
os.(*File).wrapErr -> gclocals·o5BbmPP8dP74f0b1Y5J7zA==
errors.Is -> errors.is
errors.Is -> gclocals·GxU2uwGux8EGCNGmwGodIQ==
errors.is -> errors..typeAssert.1
errors.is -> errors..interfaceSwitch.0
errors.is -> errors..typeAssert.2
errors.is -> errors..typeAssert.3
errors.is -> type:interface { Unwrap() []error }
errors.is -> runtime.panicnildottype
errors.is -> type:interface { Unwrap() error }
errors.is -> gclocals·HtQWSG/quPCw7m6YDA0NIw==
errors.is -> gclocals·+WHBATuCDUyMgFzewAtbFQ==
errors.is -> errors.is.arginfo1
errors..typeAssert.1 -> type:interface { Is(error) bool }
 -> go:info.interface { Is(error) bool }
 -> go:info.interface { Unwrap() error }
 -> go:info.interface { Unwrap() []error }
io.EOF -> io..stmp_3
io..stmp_3 -> go:string."EOF"
 -> go:info.os.(*File).checkValid$abstract
 -> go:info.os.(*File).write$abstract
 -> go:info.os.epipecheck$abstract
reflect.Kind.String -> reflect.kindNames
reflect.Kind.String -> strconv.FormatInt
reflect.Kind.String -> go:string."kind"
 -> go:info.strconv.small$abstract
reflect.(*rtype).Elem -> reflect.elem
reflect.elem -> go:string."reflect: Elem of invalid type "
reflect.(*rtype).Field -> reflect.(*structType).Field
reflect.(*rtype).Field -> go:string."reflect: Field of non-struct type "
reflect.(*rtype).Field -> gclocals·kPN+rskHSbX2T0yozFmULA==
reflect.(*rtype).Field -> gclocals·GG075s6mNZRufjxoNa6w/A==
reflect.(*rtype).Field -> reflect.(*rtype).Field.arginfo1
reflect.(*rtype).Field -> reflect.(*rtype).Field.argliveinfo
reflect.(*rtype).Len -> go:string."reflect: Len of non-array type "
reflect.ChanDir.String -> go:string."chan"
reflect.ChanDir.String -> go:string."ChanDir"
reflect.ChanDir.String -> go:string."chan<-"
reflect.ChanDir.String -> go:string."<-chan"
reflect.(*structType).Field -> type:[1]int
reflect.(*structType).Field -> reflect..stmp_23
reflect.(*structType).Field -> gclocals·UqUUURq9HOSTycFsoejJQQ==
reflect.(*structType).Field -> gclocals·wMKsMSm8vf2VTD01jix48g==
reflect.(*ValueError).Error -> go:string." Value"
reflect.(*ValueError).Error -> go:string."reflect: call of "
reflect.(*ValueError).Error -> go:string." on "
reflect.(*ValueError).Error -> go:string." on zero Value"
reflect.Value.Pointer -> reflect.dummy
reflect.Value.Pointer -> go:string."reflect.Value.Pointer"
reflect.Value.Pointer -> reflect..stmp_123
reflect.Value.stringNonString -> go:string." Value>"
reflect.Value.stringNonString -> go:string."<invalid Value>"
reflect.kindNames -> reflect..stmp_0
 -> go:info.struct { reflect.b bool; reflect.x interface {} }
reflect..stmp_0 -> go:string."invalid"
reflect..stmp_0 -> go:string."bool"
reflect..stmp_0 -> go:string."int"
reflect..stmp_0 -> go:string."int8"
reflect..stmp_0 -> go:string."int16"
reflect..stmp_0 -> go:string."int32"
reflect..stmp_0 -> go:string."int64"
reflect..stmp_0 -> go:string."uint"
reflect..stmp_0 -> go:string."uint8"
reflect..stmp_0 -> go:string."uint16"
reflect..stmp_0 -> go:string."uint32"
reflect..stmp_0 -> go:string."uint64"
reflect..stmp_0 -> go:string."uintptr"
reflect..stmp_0 -> go:string."float32"
reflect..stmp_0 -> go:string."float64"
reflect..stmp_0 -> go:string."complex64"
reflect..stmp_0 -> go:string."complex128"
reflect..stmp_0 -> go:string."array"
reflect..stmp_0 -> go:string."func"
reflect..stmp_0 -> go:string."interface"
reflect..stmp_0 -> go:string."map"
reflect..stmp_0 -> go:string."ptr"
reflect..stmp_0 -> go:string."slice"
reflect..stmp_0 -> go:string."string"
reflect..stmp_0 -> go:string."struct"
reflect..stmp_0 -> go:string."unsafe.Pointer"
 -> go:info.reflect.Kind.String$abstract
 -> go:info.strconv.Itoa$abstract
 -> go:info.reflect.(*rtype).Elem$abstract
 -> go:info.reflect.(*rtype).common$abstract
 -> go:info.reflect.StructField
 -> go:info.reflect.ChanDir
 -> go:info.reflect.escapes$abstract
internal/reflectlite.rtype.String -> internal/reflectlite.resolveNameOff
internal/reflectlite.rtype.Elem -> internal/reflectlite.elem
internal/reflectlite.rtype.Len -> internal/reflectlite..stmp_3
 -> go:info.internal/reflectlite.rtype
 -> go:info.internal/reflectlite.rtype.nameOff$abstract
 -> go:info.internal/reflectlite.rtype.Len$abstract
 -> go:info.internal/abi.(*Type).ArrayType$abstract
io/fs.FileMode.String -> go:string."dalTLDpSugct?"
io/fs.FileMode.String -> go:string."rwxrwxrwx"
 -> go:info.io/fs.FileMode
runtime.(*TypeAssertionError).Error -> go:string."interface conversion: "
runtime.(*TypeAssertionError).Error -> go:string." is "
runtime.(*TypeAssertionError).Error -> go:string.", not "
runtime.(*TypeAssertionError).Error -> runtime.rtype.pkgpath
runtime.(*TypeAssertionError).Error -> go:string." (types from different packages)"
runtime.(*TypeAssertionError).Error -> go:string." (types from different scopes)"
runtime.(*TypeAssertionError).Error -> go:string." is not "
runtime.(*TypeAssertionError).Error -> go:string.": missing method "
runtime.(*TypeAssertionError).Error -> go:string." is nil, not "
runtime.(*TypeAssertionError).Error -> gclocals·moM9VDCWT3RGVMLx5zFJhQ==
runtime.(*TypeAssertionError).Error -> gclocals·TvBahjg8QFllbt4WzXKGmg==
runtime.(*TypeAssertionError).Error -> runtime.(*TypeAssertionError).Error.stkobj
runtime.errorString.Error -> go:string."runtime error: "
runtime.boundsError.Error -> runtime.boundsErrorFmts
runtime.boundsError.Error -> runtime.boundsNegErrorFmts
runtime.boundsError.Error -> runtime.boundsError.RuntimeError.arginfo1
runtime.lockRank.String -> runtime.lockNames
runtime.lockRank.String -> go:string."BAD RANK"
runtime.lockRank.String -> go:string."LEAF"
runtime.lockRank.String -> go:string."UNKNOWN"
runtime.(*PanicNilError).Error -> go:string."panic called with nil argument"
runtime.rtype.pkgpath -> runtime.rtype.pkgpath.jump7
runtime.boundsErrorFmts -> go:string."index out of range [%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x] with capacity %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [%x:%y]"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [::%x] with length %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [::%x] with capacity %y"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [:%x:%y]"
runtime.boundsErrorFmts -> go:string."slice bounds out of range [%x:%y:]"
runtime.boundsErrorFmts -> go:string."cannot convert slice with length %y to array or pointer to array with length %x"
 -> go:info.[9]string
runtime.boundsNegErrorFmts -> go:string."index out of range [%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [:%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [%x:]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [::%x]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [:%x:]"
runtime.boundsNegErrorFmts -> go:string."slice bounds out of range [%x::]"
 -> go:info.[8]string
runtime.lockNames -> runtime..stmp_5
runtime..stmp_5 -> go:string."sysmon"
runtime..stmp_5 -> go:string."scavenge"
runtime..stmp_5 -> go:string."forcegc"
runtime..stmp_5 -> go:string."defer"
runtime..stmp_5 -> go:string."sweepWaiters"
runtime..stmp_5 -> go:string."assistQueue"
runtime..stmp_5 -> go:string."sweep"
runtime..stmp_5 -> go:string."testR"
runtime..stmp_5 -> go:string."testW"
runtime..stmp_5 -> go:string."allocmW"
runtime..stmp_5 -> go:string."execW"
runtime..stmp_5 -> go:string."cpuprof"
runtime..stmp_5 -> go:string."pollDesc"
runtime..stmp_5 -> go:string."wakeableSleep"
runtime..stmp_5 -> go:string."allocmR"
runtime..stmp_5 -> go:string."execR"
runtime..stmp_5 -> go:string."sched"
runtime..stmp_5 -> go:string."allg"
runtime..stmp_5 -> go:string."allp"
runtime..stmp_5 -> go:string."timers"
runtime..stmp_5 -> go:string."netpollInit"
runtime..stmp_5 -> go:string."hchan"
runtime..stmp_5 -> go:string."notifyList"
runtime..stmp_5 -> go:string."sudog"
runtime..stmp_5 -> go:string."root"
runtime..stmp_5 -> go:string."itab"
runtime..stmp_5 -> go:string."reflectOffs"
runtime..stmp_5 -> go:string."userArenaState"
runtime..stmp_5 -> go:string."traceBuf"
runtime..stmp_5 -> go:string."traceStrings"
runtime..stmp_5 -> go:string."fin"
runtime..stmp_5 -> go:string."spanSetSpine"
runtime..stmp_5 -> go:string."mspanSpecial"
runtime..stmp_5 -> go:string."gcBitsArenas"
runtime..stmp_5 -> go:string."profInsert"
runtime..stmp_5 -> go:string."profBlock"
runtime..stmp_5 -> go:string."profMemActive"
runtime..stmp_5 -> go:string."profMemFuture"
runtime..stmp_5 -> go:string."gscan"
runtime..stmp_5 -> go:string."stackpool"
runtime..stmp_5 -> go:string."stackLarge"
runtime..stmp_5 -> go:string."hchanLeaf"
runtime..stmp_5 -> go:string."wbufSpans"
runtime..stmp_5 -> go:string."mheap"
runtime..stmp_5 -> go:string."mheapSpecial"
runtime..stmp_5 -> go:string."globalAlloc"
runtime..stmp_5 -> go:string."trace"
runtime..stmp_5 -> go:string."traceStackTab"
runtime..stmp_5 -> go:string."deadlock"
runtime..stmp_5 -> go:string."raceFini"
runtime..stmp_5 -> go:string."allocmRInternal"
runtime..stmp_5 -> go:string."execRInternal"
runtime..stmp_5 -> go:string."testRInternal"
 -> go:info.runtime.errorString.Error$abstract
 -> go:info.runtime.errorAddressString.Error$abstract
 -> go:info.runtime.plainError.Error$abstract
 -> go:info.runtime.boundsError
 -> go:info.runtime.appendIntStr$abstract
 -> go:info.runtime.lockRank.String$abstract
 -> go:info.runtime.rtype.uncommon$abstract
syscall.Errno.Error -> syscall.errors
syscall.Errno.Error -> internal/itoa.Itoa
syscall.Errno.Error -> go:string."errno "
syscall.errors -> go:string."operation not permitted"
syscall.errors -> go:string."no such file or directory"
syscall.errors -> go:string."no such process"
syscall.errors -> go:string."interrupted system call"
syscall.errors -> go:string."input/output error"
syscall.errors -> go:string."device not configured"
syscall.errors -> go:string."argument list too long"
syscall.errors -> go:string."exec format error"
syscall.errors -> go:string."bad file descriptor"
syscall.errors -> go:string."no child processes"
syscall.errors -> go:string."resource deadlock avoided"
syscall.errors -> go:string."cannot allocate memory"
syscall.errors -> go:string."bad address"
syscall.errors -> go:string."block device required"
syscall.errors -> go:string."resource busy"
syscall.errors -> go:string."file exists"
syscall.errors -> go:string."cross-device link"
syscall.errors -> go:string."operation not supported by device"
syscall.errors -> go:string."not a directory"
syscall.errors -> go:string."is a directory"
syscall.errors -> go:string."too many open files in system"
syscall.errors -> go:string."too many open files"
syscall.errors -> go:string."inappropriate ioctl for device"
syscall.errors -> go:string."text file busy"
syscall.errors -> go:string."file too large"
syscall.errors -> go:string."no space left on device"
syscall.errors -> go:string."illegal seek"
syscall.errors -> go:string."read-only file system"
syscall.errors -> go:string."too many links"
syscall.errors -> go:string."broken pipe"
syscall.errors -> go:string."numerical argument out of domain"
syscall.errors -> go:string."result too large"
syscall.errors -> go:string."resource temporarily unavailable"
syscall.errors -> go:string."operation now in progress"
syscall.errors -> go:string."operation already in progress"
syscall.errors -> go:string."socket operation on non-socket"
syscall.errors -> go:string."destination address required"
syscall.errors -> go:string."message too long"
syscall.errors -> go:string."protocol wrong type for socket"
syscall.errors -> go:string."protocol not available"
syscall.errors -> go:string."protocol not supported"
syscall.errors -> go:string."socket type not supported"
syscall.errors -> go:string."operation not supported"
syscall.errors -> go:string."protocol family not supported"
syscall.errors -> go:string."address family not supported by protocol family"
syscall.errors -> go:string."address already in use"
syscall.errors -> go:string."can't assign requested address"
syscall.errors -> go:string."network is down"
syscall.errors -> go:string."network is unreachable"
syscall.errors -> go:string."network dropped connection on reset"
syscall.errors -> go:string."software caused connection abort"
syscall.errors -> go:string."connection reset by peer"
syscall.errors -> go:string."no buffer space available"
syscall.errors -> go:string."socket is already connected"
syscall.errors -> go:string."socket is not connected"
syscall.errors -> go:string."can't send after socket shutdown"
syscall.errors -> go:string."too many references: can't splice"
syscall.errors -> go:string."operation timed out"
syscall.errors -> go:string."connection refused"
syscall.errors -> go:string."too many levels of symbolic links"
syscall.errors -> go:string."file name too long"
syscall.errors -> go:string."host is down"
syscall.errors -> go:string."no route to host"
syscall.errors -> go:string."directory not empty"
syscall.errors -> go:string."too many processes"
syscall.errors -> go:string."too many users"
syscall.errors -> go:string."disc quota exceeded"
syscall.errors -> go:string."stale NFS file handle"
syscall.errors -> go:string."too many levels of remote in path"
syscall.errors -> go:string."RPC struct is bad"
syscall.errors -> go:string."RPC version wrong"
syscall.errors -> go:string."RPC prog. not avail"
syscall.errors -> go:string."program version wrong"
syscall.errors -> go:string."bad procedure for program"
syscall.errors -> go:string."no locks available"
syscall.errors -> go:string."function not implemented"
syscall.errors -> go:string."inappropriate file type or format"
syscall.errors -> go:string."authentication error"
syscall.errors -> go:string."need authenticator"
syscall.errors -> go:string."device power is off"
syscall.errors -> go:string."device error"
syscall.errors -> go:string."value too large to be stored in data type"
syscall.errors -> go:string."bad executable (or shared library)"
syscall.errors -> go:string."bad CPU type in executable"
syscall.errors -> go:string."shared library version mismatch"
syscall.errors -> go:string."malformed Mach-o file"
syscall.errors -> go:string."operation canceled"
syscall.errors -> go:string."identifier removed"
syscall.errors -> go:string."no message of desired type"
syscall.errors -> go:string."illegal byte sequence"
syscall.errors -> go:string."attribute not found"
syscall.errors -> go:string."bad message"
syscall.errors -> go:string."EMULTIHOP (Reserved)"
syscall.errors -> go:string."no message available on STREAM"
syscall.errors -> go:string."ENOLINK (Reserved)"
syscall.errors -> go:string."no STREAM resources"
syscall.errors -> go:string."not a STREAM"
syscall.errors -> go:string."protocol error"
syscall.errors -> go:string."STREAM ioctl timeout"
syscall.errors -> go:string."operation not supported on socket"
syscall.errors -> go:string."policy not found"
syscall.errors -> go:string."state not recoverable"
syscall.errors -> go:string."previous owner died"
 -> go:info.[106]string
internal/poll.errNetClosing.Error -> go:string."use of closed network connection"
internal/poll.errNetClosing.Error -> runtime.heapBits.next.arginfo1
internal/poll.(*DeadlineExceededError).Error -> go:string."i/o timeout"
internal/poll.(*FD).Write -> internal/poll.(*fdMutex).rwlock
internal/poll.(*FD).Write -> internal/poll.(*FD).Write.deferwrap1
internal/poll.(*FD).Write -> internal/poll.(*pollDesc).prepare
internal/poll.(*FD).Write -> internal/poll..stmp_31
internal/poll.(*FD).Write -> internal/poll.(*pollDesc).wait
internal/poll.(*FD).Write -> syscall.write
internal/poll.(*FD).Write -> io.ErrUnexpectedEOF
internal/poll.(*FD).Write -> gclocals·PqEMqfC48CFkZwLLSCWA1A==
internal/poll.(*FD).Write -> gclocals·kwqcf289EdQmy0EfQ1FwVg==
internal/poll.(*FD).Write -> os.ReadFile.opendefer
io.ErrUnexpectedEOF -> io..stmp_4
io..stmp_4 -> go:string."unexpected EOF"
syscall.write -> syscall.libc_write_trampoline
internal/poll.(*pollDesc).prepare -> internal/poll.runtime_pollReset
internal/poll.(*pollDesc).prepare -> internal/poll.ErrNotPollable
internal/poll.(*pollDesc).prepare -> go:string."unreachable:  "
internal/poll.(*pollDesc).prepare -> internal/poll..stmp_18
internal/poll.(*pollDesc).wait -> internal/poll.runtime_pollWait
internal/poll.(*pollDesc).wait -> go:string."waiting for unsupported file type"
internal/poll.(*FD).Write.deferwrap1 -> internal/poll.(*FD).writeUnlock
internal/poll.(*FD).Write.deferwrap1 -> internal/poll.(*FD).writeUnlock.wrapinfo
internal/poll.(*FD).writeUnlock -> internal/poll.(*fdMutex).rwunlock
internal/poll.ErrNotPollable -> internal/poll..stmp_6
internal/poll..stmp_6 -> go:string."not pollable"
 -> go:info.internal/poll.errNetClosing.Error$abstract
 -> go:info.*internal/poll.DeadlineExceededError
 -> go:info.internal/poll.convertErr$abstract
 -> go:info.errors.New$abstract
 -> go:info.internal/poll.(*FD).writeLock$abstract
 -> go:info.internal/poll.(*pollDesc).prepareWrite$abstract
 -> go:info.internal/poll.ignoringEINTRIO$abstract
 -> go:info.syscall.Write$abstract
 -> go:info.internal/poll.(*pollDesc).pollable$abstract
 -> go:info.internal/poll.(*pollDesc).waitWrite$abstract
time.Time.String -> go:string."2006-01-02 15:04:05.999999999 -0700 MST"
time.Time.String -> time.Time.Format
time.Time.String -> time.appendInt
time.appendInt -> runtime.panicmakeslicelen
time.appendInt -> sort.IntSlice.Less.arginfo1
time.appendInt -> sort.siftDown_func.argliveinfo
time.Time.GoString -> time.Time.abs
time.Time.GoString -> time.absDate
time.Time.GoString -> time.longMonthNames
time.Time.GoString -> time.UTC
time.Time.GoString -> time.quote
time.Time.GoString -> gclocals·58z1mGvLs14h2/lZ3ir9cg==
time.Time.GoString -> gclocals·h9HXqGtE5gYSHK/ZRMuIvw==
time.Time.Format -> time.Time.AppendFormat
time.Time.Format -> sort.SearchStrings.arginfo1
time.Time.AppendFormat -> go:string."2006-01-02T15:04:05.999999999Z07:00"
time.Time.AppendFormat -> time.Time.appendFormatRFC3339
time.Time.AppendFormat -> go:string."2006-01-02T15:04:05Z07:00"
time.Time.AppendFormat -> time.Time.appendFormat
time.Time.AppendFormat -> gclocals·VAl31sLNaHwRpAg1aHbVOw==
time.Time.AppendFormat -> time.Time.AppendFormat.arginfo1
time.Time.AppendFormat -> time.Time.AppendFormat.argliveinfo
time.Time.appendFormat -> time.Time.locabs
time.Time.appendFormat -> time.nextStdChunk
time.Time.appendFormat -> time.appendNano
time.Time.appendFormat -> time.longDayNames
time.Time.appendFormat -> go:string."%!Weekday("
time.Time.appendFormat -> go:string."%!Month("
time.Time.appendFormat -> gclocals·MiyH8QGE6Ig3mZqhb2cCdw==
time.Time.appendFormat -> gclocals·1sQYPSf5VGowAMR04EU8xQ==
time.nextStdChunk -> time.std0x
time.quote -> runtime.intstring
runtime.intstring -> runtime.encoderune
time.Time.appendFormatRFC3339 -> reflect.FuncOf.arginfo1
time.Time.appendFormatRFC3339 -> reflect.Value.call.argliveinfo
time.Time.abs -> time.(*Location).get
time.Time.abs -> time.utcLoc
time.Time.abs -> time.(*Location).lookup
time.Time.abs -> time.Time.IsZero.stkobj
time.Time.locabs -> go:string."UTC"
time.absDate -> time.daysBefore
time.(*Location).get -> time.localOnce
time.(*Location).get -> time.initLocal·f
time.(*Location).lookup -> time.(*Location).lookupFirstZone
time.(*Location).lookup -> time.tzset
time.(*Location).lookup -> gclocals·2BQlZctc2lt+9WCVI0G/lQ==
time.tzset -> time.tzsetName
time.tzset -> time.tzsetOffset
time.tzset -> go:string.",M3.2.0,M11.1.0"
time.tzset -> time.tzsetRule
time.tzset -> time.tzruleTime
time.tzset -> gclocals·CE1FQgh0mjM/tyIqvYScPg==
time.tzsetRule -> gclocals·SvLktiEPfjtM1AF1Pm3duQ==
time.tzsetRule -> gclocals·oXuWcfSUPVX2co00OPP3Yg==
time.tzruleTime -> time.tzruleTime.arginfo1
time.tzruleTime -> time.tzruleTime.argliveinfo
 -> go:info.[6]int
time.longDayNames -> time..stmp_0
time.longMonthNames -> time..stmp_3
 -> go:info.[13]int32
time..stmp_0 -> go:string."Sunday"
time..stmp_0 -> go:string."Monday"
time..stmp_0 -> go:string."Tuesday"
time..stmp_0 -> go:string."Wednesday"
time..stmp_0 -> go:string."Thursday"
time..stmp_0 -> go:string."Friday"
time..stmp_0 -> go:string."Saturday"
time..stmp_3 -> go:string."January"
time..stmp_3 -> go:string."February"
time..stmp_3 -> go:string."March"
time..stmp_3 -> go:string."April"
time..stmp_3 -> go:string."May"
time..stmp_3 -> go:string."June"
time..stmp_3 -> go:string."July"
time..stmp_3 -> go:string."August"
time..stmp_3 -> go:string."September"
time..stmp_3 -> go:string."October"
time..stmp_3 -> go:string."November"
time..stmp_3 -> go:string."December"
 -> go:info.time.startsWithLowerCase$abstract
 -> go:info.time.isDigit[go.shape.string]$abstract
 -> go:info.time.stdFracSecond$abstract
 -> go:info.time.appendInt.func1$abstract
 -> go:info.time.digitsLen$abstract
 -> go:info.time.separator$abstract
 -> go:info.time.Time
 -> go:info.time.Month
 -> go:info.time.absClock$abstract
 -> go:info.time.Time.Nanosecond$abstract
 -> go:info.time.(*Time).nsec$abstract
 -> go:info.time.Time.Location$abstract
 -> go:info.time.absWeekday$abstract
 -> go:info.time.Month.String$abstract
 -> go:info.time.fmtInt$abstract
 -> go:info.time.Weekday.String$abstract
 -> go:info.time.(*Time).unixSec$abstract
 -> go:info.time.(*Time).sec$abstract
 -> go:info.time.isLeap$abstract
 -> go:info.time.(*Location).firstZoneUsed$abstract
 -> go:info.time.rule
 -> go:info.time.daysSinceEpoch$abstract
 -> go:info.time.tzsetNum$abstract
 -> go:info.time.daysIn$abstract
internal/itoa.Itoa -> go:string."0"
 -> go:info.internal/itoa.Uitoa$abstract
internal/abi.Kind.String -> internal/abi.kindNames
internal/abi.kindNames -> internal/abi..stmp_0
 -> go:info.internal/abi.Kind.String$abstract
math/rand.(*runtimeSource).Seed -> math/rand..stmp_5
 -> go:info.*math/rand.runtimeSource
 -> go:info.math/rand.(*rngSource).Int63$abstract
 -> go:info.math/rand.(*rngSource).Uint64$abstract
 -> go:info.*internal/godebug.runtimeStderr
 -> go:info.*internal/bisect.parseError
type:interface { Is(error) bool } -> type:.namedata.*interface { Is(error) bool }-
type:interface { Is(error) bool } -> type:func(error) bool <UsedInIface>
type:func(error) bool <UsedInIface> -> type:.namedata.*func(error) bool-
type:interface { Unwrap() []error } -> type:.namedata.*interface { Unwrap() []error }-
type:interface { Unwrap() []error } -> type:func() []error
type:func() []error -> type:.namedata.*func() []error-
type:func() []error -> type:[]error
type:interface { Unwrap() error } -> type:.namedata.*interface { Unwrap() error }-
type:interface { Unwrap() error } -> type:func() error <UsedInIface>
type:func() error <UsedInIface> -> type:.namedata.*func() error-
go:info.time.(*Time).sec$abstract -> go:info.*time.Time
go:info.internal/itoa.Uitoa$abstract -> go:info.[20]uint8
reflect..stmp_23 -> go:string."reflect: Field index out of bounds"
reflect..stmp_123 -> go:string."reflect: reflect.Value.Pointer on an invalid notinheap pointer"
reflect.(*Kind).String -> runtime.panicwrap
 -> go:info.*reflect.Kind
runtime.panicwrap -> go:string."panicwrap: unexpected string after package name: "
runtime.panicwrap -> go:string."panicwrap: unexpected string after type name: "
runtime.panicwrap -> go:string."value method "
runtime.panicwrap -> go:string." called using nil *"
runtime.panicwrap -> go:string." pointer"
runtime.panicwrap -> go:string."panicwrap: no ) in "
runtime.panicwrap -> go:string."panicwrap: no ( in "
runtime.panicwrap -> gclocals·L5dy2NHL6v5bzqhZaRqYew==
runtime.panicwrap -> runtime.panicwrap.stkobj
 -> go:info.*reflect.ChanDir
 -> go:info.*reflect.Value
type:[1]int -> type:.namedata.*[1]int-
internal/reflectlite..stmp_3 -> go:string."reflect: Len of non-array type"
 -> go:info.*internal/reflectlite.rtype
go:info.internal/abi.Kind.String$abstract -> go:info.internal/abi.Kind
 -> go:info.*io/fs.FileMode
runtime.(*TypeAssertionError).Error.stkobj -> runtime.gcbits.5505000000000000
runtime.panicwrap.stkobj -> runtime.gcbits.5555010000000000
 -> go:info.runtime.netpollcheckerr$abstract
 -> go:info.runtime.(*pollDesc).info$abstract
 -> go:info.runtime.pollInfo.closing$abstract
 -> go:info.runtime.pollInfo.expiredReadDeadline$abstract
 -> go:info.runtime.pollInfo.expiredWriteDeadline$abstract
 -> go:info.runtime.pollInfo.eventErr$abstract
internal/poll.runtime_pollWait -> runtime.netpollblock
runtime.netpollblock -> runtime.netpollblockcommit·f
runtime.netpollblock -> go:string."runtime: corrupted polldesc"
runtime.netpollblock -> go:string."runtime: double wait"
 -> go:info.runtime/internal/atomic.(*Uintptr).Swap$abstract
os.sigpipe -> runtime.sigpipe·f
 -> go:info.*runtime.lockRank
 -> go:info.*runtime.waitReason
 -> go:info.*runtime.errorString
 -> go:info.*runtime.plainError
go:info.runtime.pollInfo.closing$abstract -> go:info.runtime.pollInfo
go:info.runtime.errorString.Error$abstract -> go:info.runtime.errorString
go:info.runtime.errorAddressString.Error$abstract -> go:info.runtime.errorAddressString
go:info.runtime.plainError.Error$abstract -> go:info.runtime.plainError
type:[]error -> type:.namedata.*[]error-
runtime.netpollblockcommit·f -> runtime.netpollblockcommit
runtime.sigpipe·f -> runtime.sigpipe
 -> go:info.*syscall.Errno
syscall.libc_write_trampoline -> syscall.libc_write_trampoline.args_stackmap
syscall.libc_write_trampoline -> syscall.libc_write_trampoline.arginfo0
 -> go:info.*internal/poll.errNetClosing
go:info.internal/poll.ignoringEINTRIO$abstract -> go:info.func(int, []uint8) (int, error)
go:info.internal/poll.errNetClosing.Error$abstract -> go:info.internal/poll.errNetClosing
go:info.time.isDigit[go.shape.string]$abstract -> go:info.go.shape.string
go:info.time.(*Location).firstZoneUsed$abstract -> go:info.time.zoneTrans
go:info.time.Weekday.String$abstract -> go:info.time.Weekday
time.initLocal·f -> time.initLocal
time.initLocal -> go:string."TZ"
time.initLocal -> time.platformZoneSources
time.initLocal -> time.loadLocation
time.initLocal -> go:string."Local"
time.initLocal -> go:string."/etc"
time.initLocal -> go:string."localtime"
time.initLocal -> gclocals·rm/heZXgZeGY7cq5R0pqeA==
time.loadLocation -> time.loadTzinfo
time.loadLocation -> time.LoadLocationFromTZData
time.loadLocation -> time.loadFromEmbeddedTZData
time.loadLocation -> runtime.stringtoslicebyte
time.loadLocation -> go:string."GOROOT"
time.loadLocation -> runtime.defaultGOROOT
time.loadLocation -> go:string."/lib/time/zoneinfo.zip"
time.loadLocation -> go:string."unknown time zone "
time.loadLocation -> gclocals·FGvGjfJNKFxDIbtF5nmJqQ==
time.loadLocation -> gclocals·w6LfmUJk+0Wxp+d69vAW2A==
runtime.stringtoslicebyte -> runtime.rawbyteslice
runtime.rawbyteslice -> gclocals·lUgQyKx2gV0d+E2SxNDfkg==
time.LoadLocationFromTZData -> time.errBadData
time.LoadLocationFromTZData -> time.(*dataIO).big8
time.LoadLocationFromTZData -> gclocals·+eo6uzycgwpFIHZSE3ONfA==
time.LoadLocationFromTZData -> gclocals·+wyosEc50v5zA7WNk5m5RA==
time.LoadLocationFromTZData -> time.LoadLocationFromTZData.stkobj
time.loadTzinfo -> time.loadTzinfoFromTzdata
time.loadTzinfo -> time.loadTzinfoFromDirOrZip
time.loadTzinfoFromDirOrZip -> time.loadTzinfoFromZip
time.loadTzinfoFromDirOrZip -> time.readFile
time.loadTzinfoFromZip -> syscall.Open
time.loadTzinfoFromZip -> time.loadTzinfoFromZip.deferwrap1
time.loadTzinfoFromZip -> time.preadn
time.loadTzinfoFromZip -> go:string."corrupt zip file "
time.loadTzinfoFromZip -> go:string."unsupported compression for "
time.loadTzinfoFromZip -> go:string." in "
time.loadTzinfoFromZip -> gclocals·vTRdJ5DsP6Qjso5yCvL/rg==
time.loadTzinfoFromZip -> gclocals·KKEFiXiZIlP2DEQKjnDX7A==
time.loadTzinfoFromZip -> time.loadTzinfoFromZip.opendefer
syscall.Open -> syscall.libc_open_trampoline
syscall.Open -> os.OpenFile.arginfo1
time.preadn -> syscall.Seek
time.preadn -> syscall.read
time.preadn -> go:string."short read"
time.preadn -> io.(*SectionReader).ReadAt.arginfo1
time.preadn -> sort.partition.argliveinfo
syscall.read -> syscall.libc_read_trampoline
syscall.Seek -> syscall.libc_lseek_trampoline
syscall.Seek -> syscall.syscallX
time.loadTzinfoFromZip.deferwrap1 -> time.closefd.wrapinfo
time.readFile -> time.readFile.deferwrap1
time.readFile -> go:itab.time.fileSizeError,error
time.readFile -> gclocals·A7JP7livcq76Lx45V1WYoQ==
 -> go:info.func(string) (string, error)
time.errBadData -> time..stmp_8
 -> go:info.func(string, string) ([]uint8, error)
time.platformZoneSources -> time..stmp_9
time..stmp_8 -> go:string."malformed time zone information"
time..stmp_9 -> go:string."/usr/share/zoneinfo/"
time..stmp_9 -> go:string."/usr/share/lib/zoneinfo/"
time..stmp_9 -> go:string."/usr/lib/locale/TZ/"
time..stmp_9 -> go:string."/etc/zoneinfo"
 -> go:info.syscall.Read$abstract
 -> go:info.*time.dataIO
 -> go:info.time.(*dataIO).big4$abstract
 -> go:info.time.(*dataIO).read$abstract
 -> go:info.[]time.zone
 -> go:info.[]time.zoneTrans
 -> go:info.time.dataIO
 -> go:info.time.(*dataIO).rest$abstract
 -> go:info.time.(*dataIO).byte$abstract
 -> go:info.time.byteString$abstract
 -> go:info.time.findZone$abstract
 -> go:info.time.open$abstract
 -> go:info.time.get4$abstract
 -> go:info.time.get2$abstract
 -> go:info.time.closefd$abstract
 -> go:info.runtime.GOROOT$abstract
 -> go:info.time.gorootZoneSource$abstract
 -> go:info.[4096]uint8
 -> go:info.time.read$abstract
syscall.syscallX -> runtime.syscallX
runtime.syscallX -> runtime.syscallX.args_stackmap
runtime.syscallX -> runtime.syscallX.arginfo0
syscall.libc_open_trampoline -> syscall.libc_open_trampoline.args_stackmap
syscall.libc_open_trampoline -> syscall.libc_open_trampoline.arginfo0
syscall.libc_read_trampoline -> syscall.libc_read_trampoline.args_stackmap
syscall.libc_read_trampoline -> syscall.libc_read_trampoline.arginfo0
syscall.libc_lseek_trampoline -> libc_lseek
syscall.libc_lseek_trampoline -> syscall.libc_lseek_trampoline.args_stackmap
syscall.libc_lseek_trampoline -> syscall.libc_lseek_trampoline.arginfo0
go:itab.time.fileSizeError,error -> type:time.fileSizeError <UsedInIface>
type:time.fileSizeError <UsedInIface> -> type:.namedata.*time.fileSizeError-
type:time.fileSizeError <UsedInIface> -> type:*time.fileSizeError <UsedInIface>
time.closefd.wrapinfo -> time.closefd
go:info.time.findZone$abstract -> go:info.time.zone
 -> go:info.*internal/abi.Kind
math/rand..stmp_5 -> go:string."internal error: call to runtimeSource.Seed"
type:reflect.Value <UsedInIface> -> reflect.(*Value).Comparable
type:reflect.Value <UsedInIface> -> reflect.Value.Comparable
type:*reflect.rtype <UsedInIface> -> reflect.(*rtype).Comparable
type:*os.SyscallError <UsedInIface> -> os.(*SyscallError).Unwrap
type:*io/fs.PathError <UsedInIface> -> io/fs.(*PathError).Unwrap
type:internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.rtype.Comparable
type:*internal/reflectlite.rtype <UsedInIface> -> internal/reflectlite.(*rtype).Comparable
type:syscall.Errno <UsedInIface> -> syscall.(*Errno).Is
type:syscall.Errno <UsedInIface> -> syscall.Errno.Is
type:time.fileSizeError <UsedInIface> -> time.(*fileSizeError).Error
type:time.fileSizeError <UsedInIface> -> time.fileSizeError.Error
 -> go:info.internal/reflectlite.rtype.Comparable$abstract
syscall.Errno.Is -> errors.ErrUnsupported
errors.ErrUnsupported -> errors..stmp_0
errors..stmp_0 -> go:string."unsupported operation"
 -> go:info.syscall.Errno.Is$abstract
time.fileSizeError.Error -> go:string." is too large"
time.fileSizeError.Error -> go:string."time: file "
 -> go:info.time.fileSizeError.Error$abstract
 -> go:info.*time.fileSizeError
go:info.time.fileSizeError.Error$abstract -> go:info.time.fileSizeError
